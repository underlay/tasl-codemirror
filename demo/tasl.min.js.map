{"version":3,"sources":["webpack://@underlay/tasl-codemirror/./src/tasl/config.ts","webpack://@underlay/tasl-codemirror/./src/tasl/error.ts","webpack://@underlay/tasl-codemirror/./src/tasl/index.ts","webpack://@underlay/tasl-codemirror/./src/tasl/lint.ts","webpack://@underlay/tasl-codemirror/./src/tasl/syntax.ts","webpack://@underlay/tasl-codemirror/./node_modules/lezer/dist/index.cjs","webpack://@underlay/tasl-codemirror/./node_modules/lezer/node_modules/lezer-tree/dist/tree.cjs","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/history/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/fold/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/closebrackets/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/autocomplete/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/rectangular-selection/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/goto-line/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/basic-setup/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/commands/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/comment/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/gutter/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/highlight-selection/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/highlight/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/language/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/lint/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/matchbrackets/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/panel/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/rangeset/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/search/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/state/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/text/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/tooltip/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/w3c-keyname/index.es.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/view/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/apg.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/mapping.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/morphism.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/namespace.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/type.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/utils.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/value.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/rng.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/regex.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/validate.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/stringify.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/v1.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/parse.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/v35.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/md5.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/v3.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/v4.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/sha1.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/v5.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/nil.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/node_modules/uuid/dist/esm-browser/version.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/grammar/tasl.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/grammar/taslx.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/src/index.ts","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/src/stdlib.ts","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/src/tasl.ts","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/src/taslx.ts","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/src/utils.ts","webpack://@underlay/tasl-codemirror/./node_modules/lezer-tree/src/tree.ts","webpack://@underlay/tasl-codemirror/./node_modules/n3.ts/es6/rdf.js","webpack://@underlay/tasl-codemirror/./node_modules/n3.ts/es6/xsd.js","webpack://@underlay/tasl-codemirror/./node_modules/n3.ts/es6/DataFactory.js","webpack://@underlay/tasl-codemirror/./node_modules/n3.ts/es6/Store.js","webpack://@underlay/tasl-codemirror/./node_modules/n3.ts/es6/Parse.js","webpack://@underlay/tasl-codemirror/./node_modules/style-mod/src/style-mod.js","webpack://@underlay/tasl-codemirror/./node_modules/ziterable/index.js","webpack://@underlay/tasl-codemirror/webpack/bootstrap","webpack://@underlay/tasl-codemirror/webpack/runtime/compat get default export","webpack://@underlay/tasl-codemirror/webpack/runtime/define property getters","webpack://@underlay/tasl-codemirror/webpack/runtime/hasOwnProperty shorthand","webpack://@underlay/tasl-codemirror/webpack/runtime/make namespace object","webpack://@underlay/tasl-codemirror/./demo/tasl.js"],"names":["readOnlyConfig","EditorView","editable","of","lineNumbers","defaultHighlightStyle","highlightSelectionMatches","syntax","editableConfig","basicSetup","keymap","defaultKeymap","commentKeymap","key","preventDefault","run","indentMore","indentLess","errorUnit","APG","product","lintView","state","cursor","syntaxTree","slice","from","to","doc","sliceString","parseState","error","node","message","LintError","namespaces","references","types","defaultTypes","schema","diagnostics","name","push","severity","errors","firstChild","type","isError","namespace","term","getChild","uriPattern","test","namespacePattern","source","identifier","prefix","expression","getType","uri","getURI","terms","getChildren","uris","map","length","sourceNode","labelNode","targetNode","label","target","components","ns","reference","value","head","coproduct","none","some","tail","reportChildErrors","nextSibling","Object","entries","filter","sorted","sort","a","c","b","d","defaultNamespaces","fromEntries","parseURI","e","datatype","literal","component","options","option","Error","parent","makeLinter","onChange","linter","view","props","undefined","LezerLanguage","define","parser","configure","indentNodeProp","add","Product","continuedIndent","except","Coproduct","foldNodeProp","subtree","styleTags","Comment","tags","comment","Prefix","TypeName","typeName","Variable","Term","className","propertyName","Uri","string","Literal","Pointer","operator","Optional","bracket","separator","keyword","class","edge","list","languageData","closeBrackets","brackets","indentOnInput","commentTokens","line","defineProperty","exports","Recover","lezerTree","Stack","cx","stack","reducePos","pos","score","buffer","bufferBase","this","_","i","concat","start","action","depth","dPrec","dynamicPrecedence","minRepeatTerm","storeNode","pushState","getGoto","base","count","stateFlag","baseStateID","pop","end","size","isReduce","cur","top","index","next","nextEnd","nextState","maxNode","reduce","shift","reused","off","isNode","sim","SimulatedStack","stateSlot","hasAction","force","before","frame","indexOf","nextStates","best","s","result","split","validAction","forceReduce","data","other","dialectID","dialect","flags","rest","offset","goto","StackBufferCursor","maybeNext","Token","TokenGroup","id","input","token","group","groupMask","scan","accEnd","allows","overrides","accept","get","low","high","mid","readToken","decodeArray","Type","Uint16Array","array","out","charCodeAt","stop","digit","prototype","contextual","fallback","extend","verbose","process","env","LOG","stackIDs","cutAt","tree","side","childBefore","childAfter","prevSibling","FragmentCursor","fragments","fragment","safeFrom","safeTo","trees","nextFragment","fr","openStart","openEnd","nextStart","last","children","positions","TreeBuffer","CachedToken","super","arguments","extended","mask","dummyToken","TokenCache","tokens","mainToken","actions","tokenizers","actionIndex","main","tokenizer","updateCachedToken","startIndex","addActions","eofTerm","clear","specialized","specializers","read","set","putAction","pair","Rec","Parse","startPos","context","recovering","nextStackID","nested","nestEnd","nestWrap","topTerm","stacks","advance","finishNested","stopped","stoppedTokens","maybeNest","newStacks","nest","checkNest","advanceStack","tok","startNested","finished","findFinished","stackToTree","strict","console","log","getName","SyntaxError","runRecovery","forceAll","maxRemaining","outer","j","sameState","splice","stackID","cached","nodeAt","match","nodeSet","useNode","Tree","inner","defaultReduce","getActions","localStack","apply","pushStackDedup","restarted","tokenEnd","deadEnd","restart","done","advanceFully","forceBase","insert","recoverByInsert","recoverByDelete","forceFinish","build","create","topID","maxBufferLength","bufferLength","minRepeatType","info","findNested","spec","scanForNestEnd","filterEnd","wrapType","startParse","clip","endToken","NodeType","placeholder","WeakMap","String","fromCodePoint","Dialect","disabled","Parser","DefaultBufferLength","nextStateCache","cachedDialect","version","RangeError","tokenArray","tokenData","nodeNames","repeatNodeCount","nodeProps","setProp","nodeID","prop","deserialize","propSpec","states","Uint32Array","stateData","topTerms","keys","topRules","r","NodeSet","skipped","skippedNodes","maxTerm","dialects","dynamicPrecedences","tokenPrecTable","tokenPrec","termNames","l","parseDialect","stringInput","loose","table","groupTag","terminal","slot","flag","max","prev","iPrev","findOffset","config","copy","assign","t","found","find","obj","hasOwnProperty","call","prec","values","part","Uint8Array","NodeProp","TreeCursor","ExternalTokenizer","nextPropID","CachedNode","str","Number","propObj","closedBy","openedBy","noProps","src","Array","isArray","direct","groups","newTypes","newProps","toString","join","JSON","stringify","scope","topNode","moveTo","_tree","TreeNode","enter","leave","mustLeave","isAnonymous","BalanceBranchFactor","balanceRange","_a","FlatBufferCursor","takeNode","parentStart","minPos","inRepeat","maxSize","fork","skip","minStart","nodeSize","localSkipped","nodeStart","findBufferSize","endPos","copyToBuffer","localChildren","localPositions","localInRepeat","reverse","bufferStart","buildTree","empty","childString","endIndex","dir","after","pick","_parent","full","findChild","BufferNode","BufferContext","hasChild","nextChild","val","nextSignificantParent","is","child","externalSibling","bufferNode","yieldNode","n","unshift","yieldBuf","yield","sibling","atLastNode","move","cache","ch","outerType","innerType","maxChild","Math","ceil","groupFrom","groupStart","only","containsType","nodes","elt","TreeFragment","open","changes","minGap","fI","nextF","cI","nextC","nextPos","fromA","cut","fFrom","fTo","min","toA","toB","partial","f","StringInput","at","fromHistory","Annotation","isolateHistory","invertedEffects","Facet","historyConfig","combine","configs","combineConfig","minDepth","newGroupDelay","historyField","StateField","HistoryState","tr","facet","fromHist","annotation","item","HistEvent","fromTransaction","undone","updateBranch","addSelection","startState","selection","isolate","Transaction","addMapping","desc","event","time","userEvent","addChanges","cmd","dispatch","historyState","field","undo","redo","undoSelection","redoSelection","histState","branch","effects","mapped","startSelection","selectionsAfter","invert","selections","maxLen","newEvent","newBranch","conc","lastEvent","sels","eq","setSelAfter","popSelection","addMappingToBranch","mapping","mapEvent","extraSelections","mappedChanges","mapDesc","fullMapping","composeDesc","StateEffect","prevTime","prevUserEvent","ranges","isAdjacent","iterChangedRanges","_f","_t","compose","update","annotations","historyKeymap","mac","mapRange","range","mapPos","foldEffect","unfoldEffect","selectedLines","lines","visualLineAt","foldState","Decoration","folded","foldExists","foldWidget","filterFrom","filterTo","onSelection","primary","between","provide","foldInside","maybeEnable","append","codeFolding","foldKeymap","foldable","reconfigure","defaultConfig","placeholderDOM","placeholderText","foldConfig","baseTheme","widget","WidgetType","conf","element","document","createElement","textContent","setAttribute","phrase","title","themeClass","onclick","posAtDOM","foldGutterDefaults","openText","closedText","FoldMarker","GutterMarker","span","$foldPlaceholder","backgroundColor","border","color","borderRadius","margin","padding","defaults","closeBracketEffect","MapMode","skipBracketEffect","closedBracket","startSide","endSide","bracketState","lineStart","lineAt","prevLineStart","effect","definedClosing","closing","charAt","languageDataAt","closeBracketsKeymap","dont","changeByRange","prevChar","nextChar","EditorSelection","scrollIntoView","closedBracketAt","handleOpen","close","closeBefore","anchor","handleClose","_open","moved","primaryIndex","handleSame","allowTriple","isTriple","sliceDoc","charCategorizer","CharCategory","resolve","CompletionContext","explicit","abortListeners","text","expr","search","ensureAnchor","_type","listener","Option","completion","addStart","addEnd","RegExp","ignoreCase","applyCompletion","FuzzyMatcher","pattern","chars","any","precise","byWord","p","char","upper","toUpperCase","toLowerCase","astral","word","first","len","anyTo","preciseTo","byWordTo","byWordFolded","adjacentTo","adjacentStart","adjacentEnd","prevType","completionConfig","activateOnTyping","override","maxRenderedOptions","fontFamily","overflowY","whiteSpace","maxHeight","listStyle","lineHeight","background_fallback","color_fallback","content","opacity","display","textAlign","position","width","maxWidth","MaxInfoWidth","right","left","verticalAlign","height","borderLeft","$completionMatchedText","textDecoration","$completionDetail","marginLeft","fontStyle","$completionIcon","fontSize","paddingRight","createListBox","ul","li","appendChild","icon","labelElt","detail","createTextNode","detailElt","classList","rangeAroundSelected","total","selected","floor","CompletionTooltip","stateField","placeInfo","measureInfo","write","positionInfo","cState","dom","addEventListener","parentNode","nodeName","exec","requestMeasure","updateSel","prevState","remove","updateSelectedOption","createInfoDialog","opt","hasAttribute","removeAttribute","container","getBoundingClientRect","self","scrollTop","bottom","sel","querySelector","rect","clientHeight","textDirection","Direction","spaceLeft","spaceRight","innerWidth","style","toggle","CompletionDialog","attrs","tooltip","timestamp","makeAttrs","active","hasResult","matcher","boost","cmpOption","sortOptions","selectedValue","completionState","Date","now","CompletionState","random","ActiveSource","every","touchesRange","iA","iB","endA","endB","sameResults","docChanged","setSelectedEffect","setSelected","baseAttrs","dScore","lA","lB","handleUserEvent","handleChange","startCompletionEffect","closeCompletionEffect","setActiveEffect","_tr","ActiveResult","sources","moveCompletionSelection","forward","by","step","offsetHeight","acceptCompletion","RunningQuery","updates","completionPlugin","ViewPlugin","debounceUpdate","running","debounceAccept","composing","startQuery","selectionSet","doesReset","transactions","query","handler","logException","clearTimeout","q","setTimeout","startUpdate","pending","Promise","then","aborted","scheduleAccept","err","updated","current","eventHandlers","fieldMarker","fieldRange","ActiveSnippet","deco","setActive","moveToField","snippetState","selectionInsideField","moveField","precedence","completionKeymap","MaxOff","getPos","posAtCoords","x","clientX","y","clientY","col","ref","coordsAtPos","viewport","round","abs","defaultCharacterWidth","absoluteColumn","tabSize","number","extTag","Symbol","createLineDialog","innerHTML","go","parseInt","isNaN","focus","keyCode","gotoLineKeymap","panel","highlightSpecialChars","fullConfig","canFold","canUnfold","gutter","lineMarker","initialSpacer","domEventHandlers","click","foldGutter","drawSelection","EditorState","closed","handleInsertion","autocompletion","eventFilter","altKey","button","startSel","newStart","newLine","_extend","multiple","startLine","endLine","startOff","endOff","startCol","endCol","leftOver","rectangleFor","rectangleSelectionStyle","rectangularSelection","highlightActiveLine","lintKeymap","setSel","moveSel","how","rangeEnd","cursorByChar","moveByChar","cursorCharLeft","cursorCharRight","cursorCharForward","cursorCharBackward","cursorByGroup","moveByGroup","cursorGroupLeft","cursorGroupRight","cursorGroupForward","cursorGroupBackward","interestingNode","bracketProp","moveBySyntax","newPos","matched","cursorSyntaxLeft","cursorSyntaxRight","cursorByLine","moveVertically","cursorLineUp","cursorLineDown","cursorByPage","cursorPageUp","cursorPageDown","moveByLineBoundary","moveToLineBoundary","space","cursorLineBoundaryForward","cursorLineBoundaryBackward","cursorLineStart","cursorLineEnd","toMatchingBracket","matching","cursorMatchingBracket","selectMatchingBracket","extendSel","goalColumn","selectByChar","selectCharLeft","selectCharRight","selectCharForward","selectCharBackward","selectByGroup","selectGroupLeft","selectGroupRight","selectGroupForward","selectGroupBackward","selectSyntaxLeft","selectSyntaxRight","selectByLine","selectLineUp","selectLineDown","selectByPage","selectPageUp","selectPageDown","selectLineBoundaryForward","selectLineBoundaryBackward","selectLineStart","selectLineEnd","cursorDocStart","cursorDocEnd","selectDocStart","selectDocEnd","selectAll","selectLine","selectedLineBlocks","selectParentSyntax","simplifySelection","deleteBy","towards","deleteByChar","codePoint","drop","getIndentUnit","findClusterBreak","deleteCodePointBackward","deleteCodePointForward","deleteCharBackward","deleteCharForward","deleteByGroup","categorize","cat","nextCat","deleteGroupBackward","deleteGroupForward","deleteToLineEnd","lineEnd","deleteTrailingWhitespace","iter","lineBreak","trailing","splitLine","transposeChars","blocks","upto","moveLine","block","nextLine","moveLineUp","moveLineDown","copyLine","copyLineUp","copyLineDown","deleteLine","insertNewline","replaceSelection","insertNewlineAndIndent","explode","isBetweenBrackets","IndentContext","simulateBreak","simulateDoubleBreak","indent","getIndentation","indentString","lineIndent","changeBySelectedLine","atLine","changeSet","indentSelection","overrideIndentation","norm","indentUnit","keep","emacsStyleKeymap","standardKeymap","toggleLineComment","toggleLineCommentWithOption","CommentOption","Toggle","lineComment","OnlyComment","lineUncomment","OnlyUncomment","toggleBlockComment","toggleBlockCommentWithOption","blockComment","blockUncomment","getConfig","BlockCommenter","LineCommenter","selectionCommented","isSelectionCommented","isRangeCommented","startText","endText","textBefore","SearchMargin","textAfter","spaceBefore","spaceAfter","beforeOff","startSpace","endSpace","lineCommentToken","linesAcrossSelection","linesAcrossRange","getLinesInRange","column","isRangeLineSkipped","isLineSkipped","minCol","posAfter","marginLen","_state","Infinity","isRangeLineDiscarded","constructor","_view","elementClass","mapMode","renderEmptyElements","elementStyle","markers","updateSpacer","activeGutters","gutters","$gutters","boxSizing","borderRight","$gutter","flexDirection","flexShrink","overflow","$gutterElement","minWidth","unfixGutters","gutterView","fixed","SingleGutterView","scrollDOM","insertBefore","contentDOM","updateGutters","contexts","UpdateContext","viewportLines","BlockType","finish","minHeight","contentHeight","change","heightChanged","viewportChanged","known","g","PluginField","offsetWidth","localMarkers","forLine","above","elements","newElt","GutterElement","compare","sameMarkers","removeChild","spacer","visualLineAtHeight","cssText","prevMarkers","eltClass","cssClass","marginTop","lastChild","cls","m","toDOM","lineNumberMarkers","lineNumberConfig","formatNumber","exists","NumberMarker","lineNumberGutter","others","maxLineNumber","defaultTheme","activeLineHighlighter","lineDeco","attributes","decorations","getDeco","lastLineStart","v","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","highlightConfig","ext","matchHighlighter","matchDeco","mainMatchDeco","check","wordAt","trim","visibleRanges","nextTagID","Tag","modified","tag","mod","Modifier","nextModifierID","instances","mods","permute","byName","pieces","mode","parse","rule","Rule","ruleNodeProp","highlightStyleProp","stylings","highlightStyle","specs","styling","Styling","module","modSpec","treeHighlighter","language","TreeHighlighter","nodeStack","classStack","inheritStack","markCache","getTree","buildDeco","curClass","builder","flush","mark","iterate","inheritedClass","opaque","matchContext","st","_s","backTo","heading","punctuation","meta","docComment","variableName","labelName","macroName","docString","character","integer","float","bool","regexp","escape","url","null","atom","unit","modifier","operatorKeyword","controlKeyword","definitionKeyword","derefOperator","arithmeticOperator","logicOperator","bitwiseOperator","compareOperator","updateOperator","definitionOperator","typeOperator","controlOperator","angleBracket","squareBracket","paren","brace","heading1","heading2","heading3","heading4","heading5","heading6","quote","emphasis","strong","link","monospace","inserted","deleted","changed","invalid","documentMeta","processingInstruction","definition","defineModifier","constant","function","standard","local","special","fontWeight","languageDataProp","defineLanguageFacet","baseData","Language","extraExtensions","setState","EditorParseContext","work","takeTree","LanguageState","extension","ParseWorker","languageDataFacetAt","timeout","isTop","hasNested","lang","DocInput","cursorPos","prevString","stringStart","syncTo","skippedUntil","endTime","newState","fromB","startLen","cutFragments","until","requestIdle","window","requestIdleCallback","callback","cancelIdle","cancelIdleCallback","working","bind","scheduleWork","updateViewport","reset","takeSkipped","deadline","timeRemaining","indentService","cols","ts","service","ast","scanPos","strategy","indentStrategy","TreeIndentContext","syntaxIndentation","_b","overriden","countColumn","delimitedStrategy","ignoreClosed","topIndent","textAfterPos","atBreak","isParent","delimitedIndent","align","units","closedAt","aligned","openToken","openLine","isSkipped","bracketedAligned","baseIndent","flatIndent","matchExcept","rules","newDoc","newSelection","foldService","syntaxFolding","SelectedDiagnostic","diagnostic","LintState","findDiagnostic","maybeEnableLint","lintState","activeMark","lintTooltip","setDiagnostics","setDiagnosticsEffect","togglePanel","movePanelSelection","selPos","DiagnosticWidget","LintPanel","stackStart","stackEnd","renderDiagnostic","openLintPanel","closeLintPanel","nextDiagnostic","LintDelay","lintTime","onmousedown","PanelItem","items","tabIndex","moveSelection","selectedIndex","contains","needsSync","newSelectedItem","_start","_end","sync","domPos","rm","underline","btoa","$diagnostic","$diagnosticAction","font","$lintRange","backgroundPosition","backgroundRepeat","backgroundImage","$lintPoint","borderBottom","borderBottomColor","background","$matchingBracket","$nonmatchingBracket","DefaultBrackets","bracketMatchingConfig","afterCursor","maxScanDistance","matchingMark","nonmatchingMark","bracketMatchingUnique","matchBrackets","bracketMatching","matchingNodes","byProp","matches","sub","_pos","firstToken","matchMarkedBrackets","tokenType","startCh","startToken","iterRange","distance","basePos","matchPlainBrackets","panelConfig","topContainer","bottomContainer","panels","panelPlugin","showPanel","getPanel","plugin","PanelGroup","panelClass","mount","syncClasses","scrollMargin","classes","syncDOM","curDOM","themeClasses","$panels","borderTop","RangeValue","Range","point","cmpRange","Far","Chunk","maxPoint","startAt","arr","lo","hi","diff","findIndex","newFrom","newTo","curFrom","curTo","RangeSet","chunkPos","chunk","nextLayer","chunkEnd","updateSpec","LayerCursor","spill","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","finishInner","chunks","touch","HeapCursor","sets","oldSets","newSets","textDiff","comparator","minPoint","minPointSize","sharedChunks","inA","Map","shared","Set","findSharedChunks","sideA","SpanCursor","sideB","iterGaps","iterator","activeForPoint","chunkStart","lastFrom","lastTo","setMaxPoint","newArrays","finishChunk","layer","rank","gotoInner","has","heap","heapBubble","childIndex","activeTo","activeRank","minActive","pointFrom","pointRank","removeActive","findMinIndex","trackOpen","trackExtra","nextVal","addActive","startA","startB","dPos","clipEnd","comparePoint","sameValues","compareRange","foundPos","basicNormalize","normalize","SearchCursor","bufferPos","peek","fromCharCode","code","Query","replace","caseInsensitive","setQuery","searchState","SearchState","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","highlight","valid","searchCommand","openSearchPanel","findNextMatch","findNext","maybeAnnounceMatch","findPrevInRange","findPrevious","selectMatches","replaceNext","replaceAll","buildPanel","select","searchExtensions","closeSearchPanel","root","activeElement","searchKeymap","searchField","onchange","onkeyup","replaceField","caseField","checked","updateQuery","onkeydown","runScopeHandlers","shiftKey","Break","DefaultSplit","ChangeDesc","sections","ins","posA","posB","individual","iterChanges","composeSets","mapSet","assoc","Simple","TrackDel","TrackBefore","TrackAfter","ChangeSet","_toB","resultSections","resultInserted","filteredSections","SectionIter","addSection","addInsert","filtered","parts","toJSON","lineSep","insText","insLen","json","forceJoin","setA","setB","mkSet","len2","sectionLen","insB","textBit","forward2","SelectionRange","level","which","fromJSON","normalized","bidiLevel","goal","checkSelection","docLength","nextID","compareInput","isStatic","default","sameArray","static","FacetProvider","deps","maybePrec","compute","computeN","dependencies","addresses","getter","idx","multi","depDoc","depSel","depAddrs","dep","addr","ensureAddr","newVal","oldVal","compareArray","dynamicFacetSlot","providers","providerAddrs","providerTypes","dynamic","oldAddr","address","dynAddr","getAddr","createF","updateF","compareF","facets","oldIdx","maybeIndex","Prec","PrecExtension","Configuration","replacements","dynamicSlots","staticValues","statusTemplate","oldState","fields","seen","tagsSeen","getOwnPropertySymbols","flatten","dynamicSlot","status","applying","allowMultipleSelections","lineSeparator","changeFilter","transactionFilter","transactionExtender","AnnotationType","StateEffectType","_doc","newLength","applyTransaction","ann","joinRanges","mergeTransaction","sequential","mapForA","mapForB","mapEffects","resolveTransactionInner","docSize","reconf","single","asArray","resolveTransaction","seq","extenders","extendTransaction","back","invertedDesc","filters","filterTransaction","addToHistory","nonASCIISingleCaseWordChar","wordChar","require","toText","result1","newChanges","newMapped","mapBy","extensions","configuration","staticFacet","asSingle","phrases","provider","wordChars","Space","hasWordChar","Word","Other","isExtendingChar","isRegionalIndicator","nextClusterBreak","surrogateLow","surrogateHigh","codePointAt","codePointSize","countBefore","prevClusterBreak","code0","code1","findColumn","Text","lineCache","cacheLine","lineInner","decompose","TextNode","iterA","RawTextCursor","iterB","offA","offB","strA","strB","eqContent","PartialTextCursor","LineCursor","iterLines","textLength","TextLeaf","lineCachePos","isLine","Line","sliceText","newLen","appendText","lineLengthTo","lineLengthFrom","lastLineLength","firstLineLength","lengthDiff","chunkLength","maxLength","minLength","chunked","currentLength","currentChunk","childLength","offsets","limit","LineContent","contextStart","strings","tooltipPlugin","inView","measureReq","readMeasure","writeMeasure","tooltips","showTooltip","tooltipViews","tp","createTooltip","views","tip","tooltipView","maybeMeasure","editor","innerHeight","measured","tView","strictSide","positioned","$tooltip","zIndex","HoverPlugin","setHover","lastMouseMove","hoverTimeout","mouseInside","checkHover","mouseenter","mouseleave","mousemove","lastMove","timeStamp","isOverRange","nodeType","isInTooltip","removeEventListener","createRange","fromDOM","domAtPos","setEnd","setStart","rects","getClientRects","hoverTooltip","hoverState","hideOnChange","nFrom","8","9","10","12","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","106","107","108","109","110","111","144","145","160","161","162","163","164","165","173","186","187","188","189","190","191","192","219","220","221","222","229","48","49","50","51","52","53","54","55","56","57","chrome","navigator","userAgent","safari","vendor","gecko","platform","ie","brokenModifierNames","nav","documentElement","ie_edge","ie_upto10","ie_11up","webkit","browser","ie_version","documentMode","gecko_version","chrome_version","ios","android","webkit_version","getSelection","hasSelection","anchorNode","clientRectsFor","tempRange","nodeValue","isEquivalentPosition","targetOff","scanFor","domIndex","previousSibling","maxOffset","childNodes","flattenRect","windowRect","win","DOMSelection","anchorOffset","focusNode","focusOffset","domSel","scratchRange","preventScrollSupported","focusPreventScroll","scrollLeft","ownerDocument","preventScroll","DOMPos","ContentView","dirty","editorView","posBefore","posAtStart","breakAfter","_side","track","reuseDOM","written","syncNodeInto","_dom","bias","fromI","fromStart","toI","toEnd","domBoundsAround","startDOM","endDOM","andParent","markParentsDirty","childList","cmView","markDirty","setParent","_rec","_event","ChildCursor","childCursor","findPos","none$1","InlineView","_other","TextView","textDOM","setDOM","createDOM","_from","_to","textCoords","MarkView","tagName","mergeInlineChildren","sliceInlineChildren","inlineDOMAtPos","coordsInChildren","WidgetView","customView","updateDOM","contentEditable","ignoreEvent","CompositionView","elts","toOff","fromOff","dLen","merge","become","replaceChildren","getSide","joinInlineInto","coordsAt","combineAttrs","attrsEq","keysA","keysB","updateAttrs","_widget","MarkDecoration","PointDecoration","getInclusive","LineDecoration","estimatedHeight","isReplace","WidgetRange","WidgetBefore","WidgetAfter","inclusiveStart","inclusiveEnd","inclusive","addRange","theme","strs","darkTheme","baseThemeID","expandThemeClasses","buildTheme","template","selector","$","outline_fallback","outline","$scroller","alignItems","overflowX","$content","flexGrow","caretColor","$line","$selectionLayer","contain","$selectionBackground","$cursorLayer","pointerEvents","animation","visibility","$cursor","borderLeftColor","$placeholder","$button","$textfield","LineClass","LineView","prevAttrs","takeDeco","transferDOM","setDeco","none$2","childPos","hack","cmIgnore","totalWidth","charWidth","docView","BlockWidgetView","_takeDeco","posAtEnd","ContentBuilder","curLine","breakAtStart","textOff","posCovered","getLine","take","wrapMarks","buildText","addWidget","NullWidget","addLineDeco","LTR","RTL","dec","LowTypes","ArabicTypes","BidiRE","BidiSpan","order","maybe","computeOrder","direction","trivialOrder","prevStrong","beforeL","rtl","movedOver","moveVisually","spanI","indexForward","nextIndex","nextSpan","wrappingWhiteSpace","HeightOracle","lineWrapping","heightSamples","lineLength","lineHeights","newHeight","h","knownHeights","MeasuredHeights","heights","BlockInfo","QueryType","HeightMap","oracle","oldDoc","me","ByPosNoHeight","NodeBuilder","updateHeight","HeightMapText","break","brk","HeightMapBranch","HeightMapBlock","_height","_value","blockAt","_force","more","setHeight","outdated","collapsed","widgetHeight","HeightMapGap","heightForLine","firstLine","lastLine","ByHeight","heightForGap","rightTop","rightOffset","subQuery","ByPos","forEachLine","rightStart","balanced","decomposeLeft","mergeGaps","decomposeRight","rebalance","around","covering","writtenTo","isCovered","heightRelevant","addBlock","blankContent","gap","enterLine","ensureLine","DecorationComparator","none$3","clickAddsSelectionRange","dragMovesSelection","mouseSelectionStyle","exceptionSink","updateListener","inputHandler","exception","onerror","PluginFieldProvider","scrollMargins","nextPluginID","viewPlugin","handlers","pluginDecorations","PluginInstance","dummy","destroy","editorAttributes","contentAttributes","styleModule","ChangedRange","dI","rI","addToSet","ViewUpdate","changedRanges","hasFocus","inputState","notifiedFocused","LineGap","gA","gB","wrapping","LineGapWidget","vertical","ViewState","pixelViewport","paddingTop","paddingBottom","contentWidth","heightOracle","heightMap","scrollTo","printing","mustEnforceCursorAssoc","applyChanges","setDoc","getViewport","lineGaps","ensureLineGaps","lineGapDeco","draw","computeVisibleRanges","newDeco","contentChanges","heightChanges","extendWithRanges","comp","heightRelevantDecoChanges","prevHeight","mapViewport","viewportIsAppropriate","updateLineGaps","mapLineGaps","repeated","getComputedStyle","scrollHeight","scrollWidth","clientWidth","parentRect","host","visiblePixelRange","dTop","dBottom","measureVisibleLineHeights","refresh","mustRefresh","measureTextSize","enforceCursorAssoc","Viewport","newTop","newBottom","gaps","viewFrom","viewTo","structure","lineStructure","findPosition","gapTo","gapFrom","gapSize","findFraction","ratio","same","editorTop","dist","counted","none$4","DocView","viewports","compositionDeco","minWidthFrom","minWidthTo","impreciseAnchor","impreciseHead","updateInner","updateDeco","textNode","nearbyTextNode","cView","nearest","CompositionWidget","computeCompositionDeco","forceSelection","prevDeco","decoDiff","DecorationComparator$1","findChangedDeco","pointerSel","updateSelection","oldLength","updateChildren","observer","ignore","viewState","replaceRange","breakAtEnd","fromPointer","mayControlSelection","nextToUneditable","nextTo","collapse","cursorBidiLevel","removeAllRanges","modify","domView","rootView","localPosFromDOM","measure","visible","BlockGapWidget","computeBlockGapDeco","pluginField","mLeft","mRight","mTop","mBottom","margins","defaultView","bounding","body","moveX","moveY","scrollBy","scrollRectIntoView","MaxNodeHeight","remaining","getdx","getdy","yOverlap","upTop","upBot","domPosAtCoords","closest","closestRect","closestX","closestY","below","aboveRect","belowRect","dx","dy","domPosInText","clipX","halfLine","defaultLineHeight","bounced","blockAtHeight","elementFromPoint","caretPositionFromPoint","offsetNode","caretRangeFromPoint","startContainer","startOffset","posFromDOM","spans","bidiSpans","InputState","lastKeyCode","lastKeyTime","lastSelectionOrigin","lastSelectionTime","scrollHandlers","registeredEvents","customHandlers","compositionEndedAt","mouseSelection","eventBelongsToEditor","ignoreDuringComposition","mustFlushObserver","forceFlush","runCustomHandlers","ensureHandlers","origin","defaultPrevented","scroll","MouseSelection","startEvent","up","metaKey","ctrlKey","addsSelectionRange","dragMove","dragMovesSelection$1","dragging","rangeCount","getRangeAt","isInPrimarySelection","buttons","bubbles","brokenClipboardAPI","doPaste","byLine","lastLinewiseCopy","rangeForClick","linePos","groupAt","keydown","macCtrl","mustCapture","setSelectionOrigin","touchdown","touchmove","mousedown","makeStyle","queryPos","BadMouseDetail","lastMouseDown","lastMouseDownCount","getClickType","startRange","basicMouseSelection","startMouseSelection","insideY","inside","findPositionSide","dragstart","dataTransfer","setData","effectAllowed","dropPos","getData","del","paste","clipboardData","capturePaste","forceClearComposition","linewise","copiedRange","clearData","selectionEnd","selectionStart","captureCopy","blur","beforeprint","compositionstart","compositionupdate","compositionend","observeOptions","characterData","characterDataOldValue","useCharData","DOMObserver","onScrollChanged","ignoreSelection","delayedFlush","queue","scrollTargets","intersection","intersecting","parentCheck","MutationObserver","mutations","mut","removedNodes","oldValue","flushSoon","onCharData","prevValue","onSelectionChange","onScroll","IntersectionObserver","listenForScroll","intersectionRatio","createEvent","observe","disconnect","takeRecords","clearSelection","records","newSel","typeOver","record","readMutation","rec","ignoreMutation","curView","DOMReader","points","findPointBefore","readNode","nextView","isBlockElement","fromView","overrideDOMText","readRange","findPointIn","DOMPoint","dispatchKey","cancelable","down","KeyboardEvent","dispatchEvent","plugins","editorAttrs","contentAttrs","bidiCache","updateState","measureScheduled","measureRequests","_dispatch","bounds","selPoints","selectionPoints","reader","selectionFromPoints","preferredPos","preferredSide","minLen","findDiff","iHead","iAnchor","isCollapsed","selectionCollapsed","applyDOMChange","runScrollHandlers","mountStyles","resizeDebounce","handleResize","redrawn","CachedOrder","updatePlugins","styleModules","prevSpecs","newPlugins","cancelAnimationFrame","measuring","warn","BadMeasure","scrollPosIntoView","spellcheck","contenteditable","role","request","requestAnimationFrame","takeField","inst","readMeasured","ensureTop","lineAtHeight","initial","byGroup","includeWrap","coords","editorRect","lineView","startCoords","resolvedGoal","startY","extra","goalCol","otherLine","MaxBidiLine","entry","dark","given","querySelectorAll","lastDir","currentPlatform","modifiers","keymaps","handleKeyEvents","runHandlers","bindings","buildKeymap","storedPrefix","bound","isPrefix","checkPrefix","command","scopeObj","k","alt","ctrl","normalizeKeyName","commands","ourObj","binding","maps","keyName","isChar","fallthrough","runFor","baseName","CanHidePrimary","selectionConfig","cursorBlinkRate","drawRangeCursor","drawSelectionPlugin","hideNativeSelection","Piece","fromClass","rangePieces","cursors","readPos","drawSel","selectionLayer","cursorLayer","setBlinkRate","animationDuration","confChanged","geometryChanged","animationName","ltr","contentRect","getBase","lineStyle","leftSide","paddingLeft","rightSide","visualStart","visualEnd","wrappedLine","drawForLine","piece","selectionClass","horizontal","addSpan","fromOpen","toOpen","fromCoords","toCoords","docLine","spanFrom","spanTo","measureRange","prim","measureCursor","themeSpec","primaryCursorClass","cursorClass","Specials","Names","0","7","11","8203","8204","8205","8206","8207","8232","8233","65279","65532","_supportsTabSize","supportsTabSize","styles","MozTabSize","UnicodeRegexpSupport","unicode","specialCharConfig","render","specialChars","addSpecialChars","replaceTabs","specialCharPlugin","tabStyle","decorationCache","recompute","confChange","getDecorationsFor","TabWidget","SpecialCharWidget","ph","placeHolder","custom","tab","Placeholder","wrap","__test","tuple","injection","projection","dereference","isVariant","Variant","isRecord","Record","isLiteralValue","isNamedNode","isPointer","instance","isCoproduct","isProduct","isLiteral","isUri","isReference","__esModule","_getRequireWildcardCache","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","_interopRequireWildcard","_utils","labels","freeze","forEntries","termType","unitKeys","unitValues","slots","cases","_exportNames","_mapping","forEach","enumerable","_morphism","validateMapping","M","S","T","validateExpressions","fold","delta","TI","SI","mapKeys","indices","imageValue","mapExpressions","pullback","getKeys","N3","_ziterable","signalInvalidType","expressions","NamedNode","rootId","k1","k2","pullbackComponents","applyExpressions","isTypeAssignable","applyCases","unify","path","CASE","identity","forType","includes","isTypeEqual","A","B","keyA","keyB","unifyComponents","unifyOptions","object","getKeyIndex","keyMap","_uuid","v4","validateInstance","validateValue","forValue","leaf","getRandomValues","rnds8","rng","crypto","msCrypto","uuid","byteToHex","substr","TypeError","_nodeId","_clockseq","_lastMSecs","_lastNSecs","buf","clockseq","seedBytes","msecs","nsecs","dt","tl","tmh","hashfunc","generateUUID","unescape","encodeURIComponent","bytes","stringToBytes","DNS","URL","getOutputLength","inputLength8","safeAdd","lsw","md5cmn","num","cnt","md5ff","md5gg","md5hh","md5ii","v35","msg","output","length32","hexTab","hex","md5ToHexEncodedArray","olda","oldb","oldc","oldd","wordsToMd5","length8","bytesToWords","rnds","z","ROTL","K","H","N","_i","pow","_i2","W","_t2","_lezer","spec_identifier","__proto__","xsd","boolean","double","date","dateTime","base64Binary","rdf","parseType","names","parseExpr","exprs","parseExprs","termNodes","printSyntax","nil","langString","Decimal","dateTimeStamp","gYear","gMonth","gDay","gYearMonth","gMonthDay","duration","yearMonthDuration","dayTimeDuration","unsignedByte","unsignedShort","unsignedInt","unsignedLong","positiveInteger","nonNegativeInteger","nonPositiveInteger","hexBinary","anyURI","normalizedString","NMTOKEN","Name","NCNames","_blankNodeCounter","xsdString","rdfLangString","equals","BlankNode","DefaultGraph","Default","fromId","lastIndexOf","toId","Quad","subject","predicate","graph","namedNode","iri","blankNode","variable","languageOrDataType","defaultGraph","quad","SPO","POS","OSP","Store","quads","sizeCache","graphMap","ids","entities","blankNodeIndex","addQuads","subjects","predicates","objects","index0","key0","key1","key2","existed","index1","index2","delete","rotation","generateIndex1","value0","generateIndex2","value1","makeQuad","value2","entity0","entity1","entity2","name0","name1","name2","countInIndex1","graphIndex","newGraphIndex","args","getGraphIndex","o","addToIndex","addQuad","removeFromIndex","stream","removeQuad","removeMatches","graphId","getGraphId","graphs","getGraphIndices","generateIndex","getIds","countInIndex","loopBy2Keys","loopByKey1","loopByKey0","unique","suggestedName","nnClosingTagError","unexpectedCharError","quadClosingPeriodError","nnOpeningToken","nnOpeningTokenOffset","nnClosingPostfix","nnClosingPostfixOffset","bnOpeningPrefix","bnOpeningPrefixOffset","bnClosingToken","bnClosingTokenOffset","ltOpeningTokenOffset","ltReservedReplace","ltReservedReplaceFn","lgOpeningPrefixOffset","dtSplitPrefix","dtSplitPrefixOffset","rightBoundary","leftBoundary","namedNodeValue","substring","blankNodeValue","objEndIndex","literalValue","COUNT","for","SET","globalThis","StyleModule","processSelector","selectors","isAt","modules","StyleSet","adoptedSet","adoptedStyleSheets","CSSStyleSheet","sheet","styleTag","insertRule","getRules","iterators","arg","results","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","toStringTag","getElementById"],"mappings":"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","file":"tasl.min.js","sourcesContent":["import { basicSetup } from \"@codemirror/next/basic-setup\"\nimport {\n\tdefaultKeymap,\n\tindentMore,\n\tindentLess,\n} from \"@codemirror/next/commands\"\nimport { EditorView, keymap } from \"@codemirror/next/view\"\nimport { commentKeymap } from \"@codemirror/next/comment\"\n\nimport { Extension } from \"@codemirror/next/state\"\n\nimport { lineNumbers } from \"@codemirror/next/gutter\"\nimport { highlightSelectionMatches } from \"@codemirror/next/highlight-selection\"\nimport { defaultHighlightStyle } from \"@codemirror/next/highlight\"\n\nimport { syntax } from \"./syntax.js\"\n\nexport const readOnlyConfig: Extension[] = [\n\tEditorView.editable.of(false),\n\tlineNumbers(),\n\tdefaultHighlightStyle,\n\thighlightSelectionMatches(),\n\tsyntax,\n]\n\nexport const editableConfig: Extension[] = [\n\tbasicSetup,\n\tsyntax,\n\tkeymap([\n\t\t...defaultKeymap,\n\t\t...commentKeymap,\n\t\t{\n\t\t\tkey: \"Tab\",\n\t\t\tpreventDefault: true,\n\t\t\trun: indentMore,\n\t\t},\n\t\t{\n\t\t\tkey: \"Shift-Tab\",\n\t\t\tpreventDefault: true,\n\t\t\trun: indentLess,\n\t\t},\n\t]),\n]\n","import { APG } from \"@underlay/apg\"\n\nexport const errorUnit = APG.product({})\n","export * from \"./syntax.js\"\nexport * from \"./lint.js\"\nexport * from \"./config.js\"\nexport * from \"./error.js\"\n","import { EditorState, Extension } from \"@codemirror/next/state\"\nimport { Diagnostic, linter } from \"@codemirror/next/lint\"\nimport { EditorView } from \"@codemirror/next/view\"\nimport { syntaxTree } from \"@codemirror/next/language\"\nimport { SyntaxNode, TreeCursor } from \"lezer-tree\"\n\nimport { APG, ns } from \"@underlay/apg\"\n\nimport {\n\tdefaultTypes,\n\tdefaultNamespaces,\n\tLintError,\n\tnamespacePattern,\n\tParseState,\n\tparseURI,\n\turiPattern,\n} from \"@underlay/tasl-lezer\"\nimport { errorUnit } from \"./error.js\"\n\nexport interface UpdateProps {\n\terrors: number\n\tstate: EditorState\n\tschema: APG.Schema\n\tnamespaces: Record<string, string>\n}\n\ninterface parseState extends ParseState {\n\treferences: { from: number; to: number; key: string }[]\n\ttypes: Record<string, APG.Type>\n\tschema: Record<string, APG.Type>\n}\n\nexport function lintView({\n\tstate,\n}: EditorView): UpdateProps & { diagnostics: Diagnostic[] } {\n\tconst cursor = syntaxTree(state).cursor()\n\n\tconst slice = ({ from, to }: SyntaxNode) => state.doc.sliceString(from, to)\n\tconst error = (node: SyntaxNode, message: string) =>\n\t\tnew LintError(node.from, node.to, slice(node), message)\n\n\tconst parseState: parseState = {\n\t\tslice,\n\t\terror,\n\t\tnamespaces: {},\n\t\treferences: [],\n\t\ttypes: { ...defaultTypes },\n\t\tschema: {},\n\t}\n\n\tconst diagnostics: Diagnostic[] = []\n\n\tif (cursor.name === \"Schema\") {\n\t\tcursor.firstChild()\n\t} else {\n\t\tdiagnostics.push({\n\t\t\tfrom: cursor.from,\n\t\t\tto: cursor.to,\n\t\t\tmessage: \"Syntax error: invalid document\",\n\t\t\tseverity: \"error\",\n\t\t})\n\t\treturn { errors: 1, state, schema: {}, namespaces: {}, diagnostics }\n\t}\n\n\tdo {\n\t\tif (cursor.type.isError) {\n\t\t} else if (cursor.type.name === \"Namespace\") {\n\t\t\tlet namespace = \"\"\n\n\t\t\tconst term = cursor.node.getChild(\"Term\")\n\t\t\tif (term !== null) {\n\t\t\t\tnamespace = parseState.slice(term)\n\t\t\t\tif (!uriPattern.test(namespace)) {\n\t\t\t\t\tconst { from, to } = term\n\t\t\t\t\tconst message = `Invalid URI: URIs must match ${uriPattern.source}`\n\t\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t\t} else if (!namespacePattern.test(namespace)) {\n\t\t\t\t\tconst { from, to } = term\n\t\t\t\t\tconst message = \"Invalid namespace: namespaces must end in / or #\"\n\t\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst identifier = cursor.node.getChild(\"Prefix\")\n\t\t\tif (identifier !== null) {\n\t\t\t\tconst prefix = parseState.slice(identifier)\n\t\t\t\tif (prefix in parseState.namespaces) {\n\t\t\t\t\tconst { from, to } = identifier\n\t\t\t\t\tconst message = `Duplicate namespace: ${prefix}`\n\t\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t\t} else {\n\t\t\t\t\tparseState.namespaces[prefix] = namespace\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Type\") {\n\t\t\tconst identifier = cursor.node.getChild(\"TypeName\")\n\t\t\tconst expression = cursor.node.getChild(\"Expression\")\n\t\t\tconst type =\n\t\t\t\texpression === null\n\t\t\t\t\t? errorUnit\n\t\t\t\t\t: getType(parseState, diagnostics, expression)\n\t\t\tif (identifier !== null) {\n\t\t\t\tconst name = parseState.slice(identifier)\n\t\t\t\tif (name in parseState.types) {\n\t\t\t\t\tconst { from, to } = identifier\n\t\t\t\t\tconst message = `Invalid type declaration: type ${name} has already been declared`\n\t\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t\t} else {\n\t\t\t\t\tparseState.types[name] = type\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Class\") {\n\t\t\tconst term = cursor.node.getChild(\"Term\")\n\t\t\tif (term !== null) {\n\t\t\t\tconst uri = getURI(parseState, diagnostics, term)\n\t\t\t\tif (uri !== null) {\n\t\t\t\t\tif (uri in parseState.schema) {\n\t\t\t\t\t\tconst { from, to } = term\n\t\t\t\t\t\tconst message = `Invalid class declaration: class ${uri} has already been declared`\n\t\t\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst expression = cursor.node.getChild(\"Expression\")\n\t\t\t\t\t\tparseState.schema[uri] =\n\t\t\t\t\t\t\texpression === null\n\t\t\t\t\t\t\t\t? errorUnit\n\t\t\t\t\t\t\t\t: getType(parseState, diagnostics, expression)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Edge\") {\n\t\t\tconst terms = cursor.node.getChildren(\"Term\")\n\t\t\tconst uris = terms.map((uri) => getURI(parseState, diagnostics, uri))\n\t\t\tif (terms.length === 3 && uris.length === 3) {\n\t\t\t\tconst [sourceNode, labelNode, targetNode] = terms\n\t\t\t\tconst [source, label, target] = uris\n\t\t\t\tif (label in parseState.schema) {\n\t\t\t\t\tconst { from, to } = labelNode\n\t\t\t\t\tconst message = `Invalid edge declaration: class ${label} has already been declared`\n\t\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t\t}\n\n\t\t\t\tif (!(source in parseState.schema)) {\n\t\t\t\t\tconst { from, to } = sourceNode\n\t\t\t\t\tparseState.references.push({ from, to, key: source })\n\t\t\t\t}\n\n\t\t\t\tif (!(target in parseState.schema)) {\n\t\t\t\t\tconst { from, to } = targetNode\n\t\t\t\t\tparseState.references.push({ from, to, key: target })\n\t\t\t\t}\n\n\t\t\t\tconst components: Record<string, APG.Type> = {\n\t\t\t\t\t[ns.source]: APG.reference(source),\n\t\t\t\t\t[ns.target]: APG.reference(target),\n\t\t\t\t}\n\n\t\t\t\tconst expression = cursor.node.getChild(\"Expression\")\n\t\t\t\tif (expression !== null) {\n\t\t\t\t\tcomponents[ns.value] = getType(parseState, diagnostics, expression)\n\t\t\t\t}\n\n\t\t\t\tparseState.schema[label] = APG.product(components)\n\t\t\t}\n\t\t} else if (cursor.type.name === \"List\") {\n\t\t\tconst term = cursor.node.getChild(\"Term\")\n\t\t\tconst expression = cursor.node.getChild(\"Expression\")\n\t\t\tconst head =\n\t\t\t\texpression === null\n\t\t\t\t\t? errorUnit\n\t\t\t\t\t: getType(parseState, diagnostics, expression)\n\n\t\t\tif (term !== null) {\n\t\t\t\tconst uri = getURI(parseState, diagnostics, term)\n\t\t\t\tif (uri in parseState.schema) {\n\t\t\t\t\tconst { from, to } = term\n\t\t\t\t\tconst message = `Invalid list declaration: class ${uri} has already been declared`\n\t\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t\t}\n\n\t\t\t\tparseState.schema[uri] = APG.coproduct({\n\t\t\t\t\t[ns.none]: APG.product({}),\n\t\t\t\t\t[ns.some]: APG.coproduct({\n\t\t\t\t\t\t[ns.head]: head,\n\t\t\t\t\t\t[ns.tail]: APG.reference(uri),\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treportChildErrors(diagnostics, cursor)\n\t} while (cursor.nextSibling())\n\n\tconst namespaces: [string, string][] = Object.entries(\n\t\tparseState.namespaces\n\t).filter(([_, base]) => base !== null) as [string, string][]\n\n\tfor (const { from, to, key } of parseState.references) {\n\t\tif (key in parseState.schema) {\n\t\t\tcontinue\n\t\t} else {\n\t\t\tconst message = `Reference error: class ${key} is not defined`\n\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t}\n\t}\n\n\tconst sorted = diagnostics.sort(({ from: a, to: c }, { from: b, to: d }) =>\n\t\ta < b ? -1 : b < a ? 1 : c < d ? -1 : d < c ? 1 : 0\n\t)\n\n\treturn {\n\t\terrors: sorted.length,\n\t\tstate: state,\n\t\tschema: parseState.schema,\n\t\tnamespaces: { ...defaultNamespaces, ...Object.fromEntries(namespaces) },\n\t\tdiagnostics: sorted,\n\t}\n}\n\nexport const makeLinter = (\n\tonChange?: (props: UpdateProps) => void\n): Extension =>\n\tlinter((view: EditorView) => {\n\t\tconst { diagnostics, ...props } = lintView(view)\n\t\tif (onChange !== undefined) {\n\t\t\tonChange(props)\n\t\t}\n\t\treturn diagnostics\n\t})\n\nfunction getURI(\n\tstate: parseState,\n\tdiagnostics: Diagnostic[],\n\tnode: SyntaxNode\n): string {\n\ttry {\n\t\treturn parseURI(state, node)\n\t} catch (e) {\n\t\tif (e instanceof LintError) {\n\t\t\tconst { from, to, message, value } = e\n\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\treturn value\n\t\t} else {\n\t\t\tthrow e\n\t\t}\n\t}\n}\n\n// Variable | Optional | Reference | Unit | Iri | Literal | Product | Coproduct\nfunction getType(\n\tstate: parseState,\n\tdiagnostics: Diagnostic[],\n\tnode: SyntaxNode\n): APG.Type {\n\tif (node.name === \"Variable\") {\n\t\tconst value = state.slice(node)\n\t\tif (value in state.types) {\n\t\t\treturn state.types[value]\n\t\t} else {\n\t\t\tconst { from, to } = node\n\t\t\tconst message = `Type ${value} is not defined`\n\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\treturn errorUnit\n\t\t}\n\t} else if (node.name === \"Optional\") {\n\t\tconst expression = node.getChild(\"Expression\")\n\t\tconst type =\n\t\t\texpression === null ? errorUnit : getType(state, diagnostics, expression)\n\t\treturn APG.coproduct({ [ns.none]: APG.product({}), [ns.some]: type })\n\t} else if (node.name === \"Reference\") {\n\t\tconst term = node.getChild(\"Term\")\n\t\tif (term === null) {\n\t\t\treturn errorUnit\n\t\t}\n\n\t\tconst key = getURI(state, diagnostics, term)\n\t\tif (!(key in state.schema)) {\n\t\t\tconst { from, to } = term\n\t\t\tstate.references.push({ from, to, key })\n\t\t}\n\n\t\treturn APG.reference(key)\n\t} else if (node.name === \"Uri\") {\n\t\treturn APG.uri()\n\t} else if (node.name === \"Literal\") {\n\t\tconst term = node.getChild(\"Term\")\n\t\tif (term === null) {\n\t\t\treturn errorUnit\n\t\t}\n\t\tconst datatype = getURI(state, diagnostics, term)\n\t\treturn APG.literal(datatype)\n\t} else if (node.name === \"Product\") {\n\t\tconst components: Record<string, APG.Type> = {}\n\t\tfor (const component of node.getChildren(\"Component\")) {\n\t\t\tconst term = component.getChild(\"Term\")\n\t\t\tif (term === null) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst key = getURI(state, diagnostics, term)\n\t\t\tif (key in components) {\n\t\t\t\tconst { from, to } = term\n\t\t\t\tconst message = `Duplicate product component key`\n\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t}\n\n\t\t\tconst expression = component.getChild(\"Expression\")\n\t\t\tcomponents[key] =\n\t\t\t\texpression === null\n\t\t\t\t\t? errorUnit\n\t\t\t\t\t: getType(state, diagnostics, expression)\n\t\t}\n\n\t\treturn { type: \"product\", components }\n\t} else if (node.name === \"Coproduct\") {\n\t\tconst options: Record<string, APG.Type> = {}\n\t\tfor (const option of node.getChildren(\"Option\")) {\n\t\t\tconst term = option.getChild(\"Term\")\n\t\t\tif (term === null) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst key = getURI(state, diagnostics, term)\n\t\t\tif (key in options) {\n\t\t\t\tconst { from, to } = term\n\t\t\t\tconst message = `Duplicate coproduct option key`\n\t\t\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t\t\t}\n\n\t\t\tconst expression = option.getChild(\"Expression\")\n\t\t\toptions[key] =\n\t\t\t\texpression === null\n\t\t\t\t\t? APG.product({})\n\t\t\t\t\t: getType(state, diagnostics, expression)\n\t\t}\n\n\t\treturn { type: \"coproduct\", options }\n\t} else {\n\t\tthrow new Error(\"Unexpected Expression node\")\n\t}\n}\n\nfunction reportChildErrors(diagnostics: Diagnostic[], cursor: TreeCursor) {\n\tif (cursor.type.isError) {\n\t\tconst { from, to } = cursor\n\t\tconst message = `Syntax error: unexpected or missing token (that's all we know)`\n\t\tdiagnostics.push({ from, to, message, severity: \"error\" })\n\t}\n\tif (cursor.firstChild()) {\n\t\tdo {\n\t\t\treportChildErrors(diagnostics, cursor)\n\t\t} while (cursor.nextSibling())\n\t\tcursor.parent()\n\t}\n}\n","import {\n\tcontinuedIndent,\n\tindentNodeProp,\n\tfoldNodeProp,\n\tLezerLanguage,\n} from \"@codemirror/next/language\"\n\nimport { styleTags, tags } from \"@codemirror/next/highlight\"\nimport { SyntaxNode } from \"lezer-tree\"\n\nimport { parser } from \"@underlay/tasl-lezer/grammar/tasl.js\"\n\nexport const syntax = LezerLanguage.define({\n\tparser: parser.configure({\n\t\tprops: [\n\t\t\tindentNodeProp.add({\n\t\t\t\tProduct: continuedIndent({ except: /^\\s*\\}/ }),\n\t\t\t\tCoproduct: continuedIndent({ except: /^\\s*\\]/ }),\n\t\t\t}),\n\t\t\tfoldNodeProp.add({\n\t\t\t\tProduct(subtree: SyntaxNode) {\n\t\t\t\t\treturn { from: subtree.from + 1, to: subtree.to - 1 }\n\t\t\t\t},\n\t\t\t\tCoproduct(subtree: SyntaxNode) {\n\t\t\t\t\treturn { from: subtree.from + 1, to: subtree.to - 1 }\n\t\t\t\t},\n\t\t\t}),\n\t\t\tstyleTags({\n\t\t\t\tComment: tags.comment,\n\t\t\t\tPrefix: tags.namespace,\n\t\t\t\tTypeName: tags.typeName,\n\t\t\t\tVariable: tags.typeName,\n\t\t\t\tTerm: tags.name,\n\t\t\t\t\"Class/Term\": tags.className,\n\t\t\t\t\"Edge/Term\": tags.className,\n\t\t\t\t\"Product/Term\": tags.propertyName,\n\t\t\t\t\"Coproduct/Term\": tags.propertyName,\n\t\t\t\tUri: tags.string,\n\t\t\t\tLiteral: tags.string,\n\t\t\t\t\"Literal/Term\": tags.string,\n\t\t\t\t\"Reference/Term\": tags.className,\n\t\t\t\tPointer: tags.operator,\n\t\t\t\tOptional: tags.operator,\n\t\t\t\t\"{ }\": tags.bracket,\n\t\t\t\t\"[ ]\": tags.bracket,\n\t\t\t\t\"->\": tags.separator,\n\t\t\t\t\"<-\": tags.separator,\n\t\t\t\t\";\": tags.separator,\n\t\t\t\t\"Namespace/Uri\": tags.namespace,\n\t\t\t\tnamespace: tags.keyword,\n\t\t\t\ttype: tags.keyword,\n\t\t\t\tclass: tags.keyword,\n\t\t\t\tedge: tags.keyword,\n\t\t\t\tlist: tags.keyword,\n\t\t\t}),\n\t\t],\n\t}),\n\tlanguageData: {\n\t\tcloseBrackets: { brackets: [\"[\", \"{\", \"<\"] },\n\t\tindentOnInput: /^\\s*[\\}\\]]$/,\n\t\tcommentTokens: { line: \"#\" },\n\t},\n})\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar lezerTree = require('lezer-tree');\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// A group of values that the stack will share with all\n    /// split instances\n    ///@internal\n    cx, \n    /// Holds state, pos, value stack pos (15 bits array index, 15 bits\n    /// buffer index) triplets for all but the top state\n    /// @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.cx = cx;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(cx, state, pos = 0) {\n        return new Stack(cx, [], state, pos, pos, 0, [], 0, null);\n    }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.cx;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let start = this.pos, nextState = action, { parser } = this.cx;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            if (next <= this.cx.parser.maxNode)\n                this.buffer.push(next, this.pos, nextEnd, 4);\n            this.pos = nextEnd;\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt node into the buffer. This may be a reused node or\n    // the result of running a nested parser.\n    /// @internal\n    useNode(value, next) {\n        let index = this.cx.reused.length - 1;\n        if (index < 0 || this.cx.reused[index] != value) {\n            this.cx.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.cx.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 200 /* Token */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    /// Find the start position of the rule that is currently being parsed.\n    get ruleStart() {\n        for (let state = this.state, base = this.stack.length;;) {\n            let force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);\n            if (!(force & 65536 /* ReduceFlag */))\n                return 0;\n            base -= 3 * (force >> 19 /* ReduceDepthShift */);\n            if ((force & 65535 /* ValueMask */) < this.cx.parser.minRepeatTerm)\n                return this.stack[base + 1];\n            state = this.stack[base];\n        }\n    }\n    /// Find the start position of an instance of any of the given term\n    /// types, or return `null` when none of them are found.\n    ///\n    /// **Note:** this is only reliable when there is at least some\n    /// state that unambiguously matches the given rule on the stack.\n    /// I.e. if you have a grammar like this, where the difference\n    /// between `a` and `b` is only apparent at the third token:\n    ///\n    ///     a { b | c }\n    ///     b { \"x\" \"y\" \"x\" }\n    ///     c { \"x\" \"y\" \"z\" }\n    ///\n    /// Then a parse state after `\"x\"` will not reliably tell you that\n    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n    /// for either of those two rules (assuming that `a` isn't part of\n    /// some rule that includes other things starting with `\"x\"`).\n    ///\n    /// When `before` is given, this keeps scanning up the stack until\n    /// it finds a match that starts before that position.\n    startOf(types, before) {\n        let state = this.state, frame = this.stack.length, { parser } = this.cx;\n        for (;;) {\n            let force = parser.stateSlot(state, 5 /* ForcedReduce */);\n            let depth = force >> 19 /* ReduceDepthShift */, term = force & 65535 /* ValueMask */;\n            if (types.indexOf(term) > -1) {\n                let base = frame - (3 * (force >> 19 /* ReduceDepthShift */)), pos = this.stack[base + 1];\n                if (before == null || before > pos)\n                    return pos;\n            }\n            if (frame == 0)\n                return null;\n            if (depth == 0) {\n                frame -= 3;\n                state = this.stack[frame];\n            }\n            else {\n                frame -= 3 * (depth - 1);\n                state = parser.getGoto(this.stack[frame - 3], term, true);\n            }\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.cx.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next));\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)\n                    if (best.indexOf(nextStates[i]) < 0)\n                        best.push(nextStates[i]);\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {\n            if (nextStates[i] == this.state)\n                continue;\n            let stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(nextStates[i], this.pos);\n            stack.score -= 200 /* Token */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        if (!this.cx.parser.validAction(this.state, reduce)) {\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.cx;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.cx.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.cx.parser.dialect.flags[dialectID]; }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Token\"] = 200] = \"Token\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);\n        this.top = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack) {\n        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n/// Tokenizers write the tokens they read into instances of this class.\nclass Token {\n    constructor() {\n        /// The start of the token. This is set by the parser, and should not\n        /// be mutated by the tokenizer.\n        this.start = -1;\n        /// This starts at -1, and should be updated to a term id when a\n        /// matching token is found.\n        this.value = -1;\n        /// When setting `.value`, you should also set `.end` to the end\n        /// position of the token. (You'll usually want to use the `accept`\n        /// method.)\n        this.end = -1;\n    }\n    /// Accept a token, setting `value` and `end` to the given values.\n    accept(value, end) {\n        this.value = value;\n        this.end = end;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, token, stack) { readToken(this.data, input, token, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// Exports that are used for `@external tokens` in the grammar should\n/// export an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream and a token object,\n    /// [fills](#lezer.Token.accept) the token object if it recognizes a\n    /// token. `token.start` should be used as the start position to\n    /// scan from.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, token, stack, group) {\n    let state = 0, groupMask = 1 << group, dialect = stack.cx.parser.dialect;\n    scan: for (let pos = token.start;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value))) {\n                    token.accept(term, pos);\n                    break;\n                }\n            }\n        let next = input.get(pos++);\n        // Do a binary search on the state's edges\n        for (let low = 0, high = data[state + 2]; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError)\n                    return side < 0 ? cursor.to - 1 : cursor.from + 1;\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        this.fragments = fragments;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            else if (start == pos && start + next.length <= this.safeTo) {\n                return start == pos && start >= this.safeFrom ? next : null;\n            }\n            if (next instanceof lezerTree.TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    }\n}\nclass CachedToken extends Token {\n    constructor() {\n        super(...arguments);\n        this.extended = -1;\n        this.mask = 0;\n    }\n    clear(start) {\n        this.start = start;\n        this.value = this.extended = -1;\n    }\n}\nconst dummyToken = new Token;\nclass TokenCache {\n    constructor(parser) {\n        this.tokens = [];\n        this.mainToken = dummyToken;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack, input) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.cx, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {\n                this.updateCachedToken(token, tokenizer, stack, input);\n                token.mask = mask;\n            }\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (!main) {\n            main = dummyToken;\n            main.start = stack.pos;\n            if (stack.pos == input.length)\n                main.accept(stack.cx.parser.eofTerm, stack.pos);\n            else\n                main.accept(0 /* Err */, stack.pos + 1);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    updateCachedToken(token, tokenizer, stack, input) {\n        token.clear(stack.pos);\n        tokenizer.token(input, token, stack);\n        if (token.value > -1) {\n            let { parser } = stack.cx;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](input.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.cx.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else if (stack.pos == input.length) {\n            token.accept(stack.cx.parser.eofTerm, stack.pos);\n        }\n        else {\n            token.accept(0 /* Err */, stack.pos + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.cx, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 1), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    Rec[Rec[\"MinBufferLengthPrune\"] = 200] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n})(Rec || (Rec = {}));\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nclass Parse {\n    constructor(parser, input, startPos, context) {\n        this.parser = parser;\n        this.input = input;\n        this.startPos = startPos;\n        this.context = context;\n        // The position to which the parse has advanced.\n        this.pos = 0;\n        this.recovering = 0;\n        this.nextStackID = 0x2654;\n        this.nested = null;\n        this.nestEnd = 0;\n        this.nestWrap = null;\n        this.reused = [];\n        this.tokens = new TokenCache(parser);\n        this.topTerm = parser.top[1];\n        this.stacks = [Stack.start(this, parser.top[0], this.startPos)];\n        let fragments = context === null || context === void 0 ? void 0 : context.fragments;\n        this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        if (this.nested) {\n            let result = this.nested.advance();\n            this.pos = this.nested.pos;\n            if (result) {\n                this.finishNested(this.stacks[0], result);\n                this.nested = null;\n            }\n            return null;\n        }\n        let stacks = this.stacks, pos = this.pos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        let maybeNest;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], nest;\n            for (;;) {\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (nest = this.checkNest(stack)) {\n                    if (!maybeNest || maybeNest.stack.score < stack.score)\n                        maybeNest = nest;\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.mainToken;\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (maybeNest) {\n            this.startNested(maybeNest);\n            return null;\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + this.parser.getName(this.tokens.mainToken.value));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.pos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.pos)\n                this.pos = newStacks[i].pos;\n        return null;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { input, parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.fragments) {\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof lezerTree.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof lezerTree.Tree)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        let actions = this.tokens.getActions(stack, input);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            let nest = this.checkNest(stack);\n            if (nest)\n                return nest;\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        let maybeNest;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done) {\n                    if (done !== true)\n                        maybeNest = done;\n                    continue;\n                }\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done) {\n                    if (done !== true)\n                        maybeNest = done;\n                    break;\n                }\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.input.length > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        if (finished)\n            return finished;\n        if (maybeNest)\n            for (let s of this.stacks)\n                if (s.score > maybeNest.stack.score) {\n                    maybeNest = undefined;\n                    break;\n                }\n        if (maybeNest)\n            this.startNested(maybeNest);\n        return null;\n    }\n    forceFinish() {\n        let stack = this.stacks[0].split();\n        if (this.nested)\n            this.finishNested(stack, this.nested.forceFinish());\n        return this.stackToTree(stack.forceAll());\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack, pos = stack.pos) {\n        return lezerTree.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.startPos,\n            length: pos - this.startPos,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    checkNest(stack) {\n        let info = this.parser.findNested(stack.state);\n        if (!info)\n            return null;\n        let spec = info.value;\n        if (typeof spec == \"function\")\n            spec = spec(this.input, stack);\n        return spec ? { stack, info, spec } : null;\n    }\n    startNested(nest) {\n        let { stack, info, spec } = nest;\n        this.stacks = [stack];\n        this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);\n        this.nestWrap = typeof spec.wrapType == \"number\" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;\n        if (spec.startParse) {\n            this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);\n        }\n        else {\n            this.finishNested(stack);\n        }\n    }\n    scanForNestEnd(stack, endToken, filter) {\n        for (let pos = stack.pos; pos < this.input.length; pos++) {\n            dummyToken.start = pos;\n            dummyToken.value = -1;\n            endToken.token(this.input, dummyToken, stack);\n            if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))\n                return pos;\n        }\n        return this.input.length;\n    }\n    finishNested(stack, tree) {\n        if (this.nestWrap)\n            tree = new lezerTree.Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);\n        else if (!tree)\n            tree = new lezerTree.Tree(lezerTree.NodeType.none, [], [], this.nestEnd - stack.pos);\n        let info = this.parser.findNested(stack.state);\n        stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));\n        if (verbose)\n            console.log(this.stackID(stack) + ` (via unnest)`);\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nclass Parser {\n    /// @internal\n    constructor(spec) {\n        /// @internal\n        this.bufferLength = lezerTree.DefaultBufferLength;\n        /// @internal\n        this.strict = false;\n        this.nextStateCache = [];\n        this.cachedDialect = null;\n        if (spec.version != 13 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);\n        let tokenArray = decodeArray(spec.tokenData);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n        this.specializers = [];\n        if (spec.specialized)\n            for (let i = 0; i < spec.specialized.length; i++) {\n                this.specialized[i] = spec.specialized[i].term;\n                this.specializers[i] = spec.specialized[i].get;\n            }\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        this.nodeSet = new lezerTree.NodeSet(nodeNames.map((name, i) => lezerTree.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {\n            return { name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };\n        });\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        for (let i = 0, l = this.states.length / 6 /* Size */; i < l; i++)\n            this.nextStateCache[i] = null;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    /// Parse a given string or stream.\n    parse(input, startPos = 0, context = {}) {\n        if (typeof input == \"string\")\n            input = lezerTree.stringInput(input);\n        let cx = new Parse(this, input, startPos, context);\n        for (;;) {\n            let done = cx.advance();\n            if (done)\n                return done;\n        }\n    }\n    /// Start an incremental parse.\n    startParse(input, startPos = 0, context = {}) {\n        if (typeof input == \"string\")\n            input = lezerTree.stringInput(input);\n        return new Parse(this, input, startPos, context);\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    findNested(state) {\n        let flags = this.stateSlot(state, 0 /* Flags */);\n        return flags & 4 /* StartNest */ ? this.nested[flags >> 10 /* NestShift */] : null;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let cached = this.nextStateCache[state];\n        if (cached)\n            return cached;\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && result.indexOf(this.data[i + 1]) < 0)\n                result.push(this.data[i + 1]);\n        }\n        let table = this.goto, max = table[0];\n        for (let term = 0; term < max; term++) {\n            for (let pos = table[term + 1];;) {\n                let groupTag = table[pos++], target = table[pos++];\n                for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                    if (table[pos] == state && result.indexOf(target) < 0)\n                        result.push(target);\n                if (groupTag & 1)\n                    break;\n            }\n        }\n        return this.nextStateCache[state] = result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(Parser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.nested)\n            copy.nested = this.nested.map(obj => {\n                if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))\n                    return obj;\n                return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };\n            });\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// Tells you whether this grammar has any nested grammars.\n    get hasNested() { return this.nested.length > 0; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        if (this.cachedDialect && this.cachedDialect.source == dialect)\n            return this.cachedDialect;\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return this.cachedDialect = new Dialect(dialect, flags, disabled);\n    }\n    /// (used by the output of the parser generator) @internal\n    static deserialize(spec) {\n        return new Parser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        if (stack.pos == stack.cx.input.length &&\n            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\n\nexports.NodeProp = lezerTree.NodeProp;\nexports.NodeSet = lezerTree.NodeSet;\nexports.NodeType = lezerTree.NodeType;\nexports.Tree = lezerTree.Tree;\nexports.TreeCursor = lezerTree.TreeCursor;\nexports.ExternalTokenizer = ExternalTokenizer;\nexports.Parser = Parser;\nexports.Stack = Stack;\nexports.Token = Token;\n//# sourceMappingURL=index.cjs.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nconst CachedNode = new WeakMap();\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type. You can optionally pass a\n    /// `deserialize` function.\n    constructor({ deserialize } = {}) {\n        this.id = nextPropID++;\n        this.deserialize = deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// Create a string-valued node prop whose deserialize function is\n    /// the identity function.\n    static string() { return new NodeProp({ deserialize: str => str }); }\n    /// Create a number-valued node prop whose deserialize function is\n    /// just `Number`.\n    static number() { return new NodeProp({ deserialize: Number }); }\n    /// Creates a boolean-valued node prop whose deserialize function\n    /// returns true for any input.\n    static flag() { return new NodeProp({ deserialize: () => true }); }\n    /// Store a value for this prop in the given object. This can be\n    /// useful when building up a prop object to pass to the\n    /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n    /// argument.\n    set(propObj, value) {\n        propObj[this.id] = value;\n        return propObj;\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n    /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n    /// values for each node type in the set. Takes a [match\n    /// object](#tree.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src)\n                    src[0].set(props, src[1]);\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#tree.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#tree.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#tree.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    add[0].set(newProps, add[1]);\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. You usually want to go through\n    /// [`Tree.build`](#tree.Tree^build) instead.\n    constructor(type, \n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n    }\n    /// @internal\n    toString() {\n        let children = this.children.map(c => c.toString()).join();\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n    /// to the given position and side.\n    cursor(pos, side = 0) {\n        let scope = (pos != null && CachedNode.get(this)) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        if (pos != null) {\n            cursor.moveTo(pos, side);\n            CachedNode.set(this, cursor._tree);\n        }\n        return cursor;\n    }\n    /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n    /// nodes.\n    fullCursor() {\n        return new TreeCursor(this.topNode, true);\n    }\n    /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    resolve(pos, side = 0) {\n        return this.cursor(pos, side).node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, the given node\n    /// will not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor();;) {\n            let mustLeave = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n                if (c.firstChild())\n                    continue;\n                if (!c.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(c.type, c.from, c.to);\n                mustLeave = c.type.isAnonymous;\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Balance the direct children of this tree.\n    balance(maxBufferLength = DefaultBufferLength) {\n        return this.children.length <= BalanceBranchFactor ? this\n            : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length);\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nclass TreeBuffer {\n    /// Create a tree buffer @internal\n    constructor(\n    /// @internal\n    buffer, \n    // The total length of the group of nodes in the buffer.\n    length, \n    /// @internal\n    set, type = NodeType.none) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n        this.type = type;\n    }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, after) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (after != -100000000 /* None */) {\n                let start = buffer[i + 1], end = buffer[i + 2];\n                if (dir > 0) {\n                    if (end > after)\n                        pick = i;\n                    if (end > after)\n                        break;\n                }\n                else {\n                    if (start < after)\n                        pick = i;\n                    if (end >= after)\n                        break;\n                }\n            }\n            else {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n}\nclass TreeNode {\n    constructor(node, from, index, _parent) {\n        this.node = node;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this.node.type; }\n    get name() { return this.node.type.name; }\n    get to() { return this.from + this.node.length; }\n    nextChild(i, dir, after, full = false) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (after != -100000000 /* None */ && (dir < 0 ? start >= after : start + next.length <= after))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    let index = next.findChild(0, next.buffer.length, dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - start);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if (full || (!next.type.isAnonymous || hasChild(next))) {\n                    let inner = new TreeNode(next, start, i, parent);\n                    return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);\n                }\n            }\n            if (full || !parent.type.isAnonymous)\n                return null;\n            i = parent.index + dir;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, -100000000 /* None */); }\n    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -100000000 /* None */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos); }\n    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos); }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;\n    }\n    get prevSibling() {\n        return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;\n    }\n    get cursor() { return new TreeCursor(this); }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this.node.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor, result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, after) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.context.start);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, -100000000 /* None */); }\n    get lastChild() { return this.child(-1, -100000000 /* None */); }\n    childAfter(pos) { return this.child(1, pos); }\n    childBefore(pos) { return this.child(-1, pos); }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));\n    }\n    get cursor() { return new TreeCursor(this); }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, full = false) {\n        this.full = full;\n        this.buffer = null;\n        this.stack = [];\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enter(dir, after) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000 /* None */ ? -100000000 /* None */ : after - this.buffer.start);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enter(1, -100000000 /* None */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enter(-1, -100000000 /* None */); }\n    /// Move the cursor to the first child that starts at or after `pos`.\n    childAfter(pos) { return this.enter(1, pos); }\n    /// Move to the last child that ends at or before `pos`.\n    childBefore(pos) { return this.enter(-1, pos); }\n    /// Move the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000 /* None */, this.full));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000 /* None */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000 /* None */, this.full)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n                let child = parent.node.children[i];\n                if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))\n                    return false;\n            }\n        }\n        return true;\n    }\n    move(dir) {\n        if (this.enter(dir, -100000000 /* None */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty, its next sibling or the next sibling of\n    /// the first parent node that has one.\n    next() { return this.move(1); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by ist last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev() { return this.move(-1); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        for (;;) {\n            if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))\n                break;\n            if (this.from == this.to ||\n                (side < 1 ? this.from >= pos : this.from > pos) ||\n                (side > -1 ? this.to <= pos : this.to < pos)) {\n                this.parent();\n                break;\n            }\n        }\n        return this;\n    }\n    /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#tree.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#tree.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree.node;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));\n}\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\nconst BalanceBranchFactor = 8;\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        while (id == inRepeat) {\n            cursor.next();\n            ({ id, start, end, size } = cursor);\n        }\n        let startPos = start - parentStart;\n        if (size < 0) { // Reused node\n            children.push(reused[id]);\n            positions.push(startPos);\n            cursor.next();\n            return;\n        }\n        let type = types[id], node, buffer;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index, inRepeat);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            while (cursor.pos > endPos)\n                takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n                node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start);\n            else\n                node = new Tree(type, localChildren, localPositions, end - start);\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let nodeSize = fork.size, startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0)\n                    break scan;\n                if (fork.id >= minRepeatType)\n                    localSkipped += 4;\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index, inRepeat) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (id == inRepeat)\n            return index;\n        let startIndex = index;\n        if (size > 4) {\n            let endPos = cursor.pos - (size - 4);\n            while (cursor.pos > endPos)\n                index = copyToBuffer(bufferStart, buffer, index, inRepeat);\n        }\n        if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[topID], children.reverse(), positions.reverse(), length);\n}\nfunction balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length) {\n    let localChildren = [], localPositions = [];\n    if (length <= maxBufferLength) {\n        for (let i = from; i < to; i++) {\n            localChildren.push(children[i]);\n            localPositions.push(positions[i] - start);\n        }\n    }\n    else {\n        let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i];\n            i++;\n            for (; i < to; i++) {\n                let nextEnd = positions[i] + children[i].length;\n                if (nextEnd - groupStart > maxChild)\n                    break;\n            }\n            if (i == groupFrom + 1) {\n                let only = children[groupFrom];\n                if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n                    for (let j = 0; j < only.children.length; j++) {\n                        localChildren.push(only.children[j]);\n                        localPositions.push(only.positions[j] + groupStart - start);\n                    }\n                    continue;\n                }\n                localChildren.push(only);\n            }\n            else if (i == groupFrom + 1) {\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart);\n                if (innerType != NodeType.none && !containsType(inner.children, innerType))\n                    inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length);\n                localChildren.push(inner);\n            }\n            localPositions.push(groupStart - start);\n        }\n    }\n    return new Tree(outerType, localChildren, localPositions, length);\n}\nfunction containsType(nodes, type) {\n    for (let elt of nodes)\n        if (elt.type == type)\n            return true;\n    return false;\n}\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nclass TreeFragment {\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, open) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = open;\n    }\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        let cI = 0, pos = 0, off = 0;\n        for (;;) {\n            let nextC = cI < changes.length ? changes[cI++] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null :\n                            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 /* Start */ : 0) | (nextC ? 2 /* End */ : 0));\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the token at its\n    /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 /* End */ : 0)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n}\n// Creates an `Input` that is backed by a single, flat string.\nfunction stringInput(input) { return new StringInput(input); }\nclass StringInput {\n    constructor(string, length = string.length) {\n        this.string = string;\n        this.length = length;\n    }\n    get(pos) {\n        return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);\n    }\n    lineAfter(pos) {\n        if (pos < 0)\n            return \"\";\n        let end = this.string.indexOf(\"\\n\", pos);\n        return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));\n    }\n    read(from, to) { return this.string.slice(from, Math.min(this.length, to)); }\n    clip(at) { return new StringInput(this.string, at); }\n}\n\nexports.DefaultBufferLength = DefaultBufferLength;\nexports.NodeProp = NodeProp;\nexports.NodeSet = NodeSet;\nexports.NodeType = NodeType;\nexports.Tree = Tree;\nexports.TreeBuffer = TreeBuffer;\nexports.TreeCursor = TreeCursor;\nexports.TreeFragment = TreeFragment;\nexports.stringInput = stringInput;\n//# sourceMappingURL=tree.cjs.map\n","import { Annotation, Facet, combineConfig, StateField, Transaction, StateEffect } from '@codemirror/next/state';\n\nconst fromHistory = Annotation.define();\n/// Transaction annotation that will prevent that annotation from\n/// being combined with other annotations in the undo history. Given\n/// `\"before\"`, it'll prevent merging with previous transactions. With\n/// `\"after\"`, subsequent transactions won't be combined with this\n/// one. With `\"full\"`, the transaction is isolated on both sides.\nconst isolateHistory = Annotation.define();\n/// This facet provides a way to register functions that, given a\n/// transaction, provide a set of effects that the history should\n/// store when inverting the transaction. This can be used to\n/// integrate some kinds of effects in the history, so that they can\n/// be undone (and redone again).\nconst invertedEffects = Facet.define();\nconst historyConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            minDepth: 100,\n            newGroupDelay: 500\n        }, { minDepth: Math.max, newGroupDelay: Math.min });\n    }\n});\nconst historyField = StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr), from = fromHist.side;\n            let other = from == 0 /* Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* Done */ ? fromHist.rest : other, from == 0 /* Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(Transaction.addToHistory) === false)\n            return tr.changes.length ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    }\n});\n/// Create a history extension with the given configuration.\nfunction history(config = {}) {\n    // FIXME register beforeinput handler\n    return [\n        historyField,\n        historyConfig.of(config)\n    ];\n}\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        let historyState = state.field(historyField, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/// Undo a single group of history events. Returns false if no group\n/// was available.\nconst undo = cmd(0 /* Done */, false);\n/// Redo a group of history events. Returns false if no group was\n/// available.\nconst redo = cmd(1 /* Undone */, false);\n/// Undo a selection change.\nconst undoSelection = cmd(0 /* Done */, true);\n/// Redo a selection change.\nconst redoSelection = cmd(1 /* Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/// The amount of undoable change events available in a given state.\nconst undoDepth = depth(0 /* Done */);\n/// The amount of redoable change events available in a given state.\nconst redoDepth = depth(1 /* Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, newGroupDelay, maxLen) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes &&\n            time - this.prevTime < newGroupDelay &&\n            !lastEvent.selectionsAfter.length &&\n            lastEvent.changes.length && event.changes &&\n            isAdjacent(lastEvent.changes, event.changes)) {\n            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, maxLen, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == \"keyboardselection\" && this.prevUserEvent == userEvent &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, selection) {\n        let branch = side == 0 /* Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1];\n        if (selection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch) })\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest }),\n                filter: false\n            });\n        }\n    }\n}\nHistoryState.empty = new HistoryState(none, none);\n/// Default key bindings for the undo history.\n///\n/// - Mod-z: [`undo`](#history.undo).\n/// - Mod-y (Mod-Shift-z on macOS): [`redo`](#history.redo).\n/// - Mod-u: [`undoSelection`](#history.undoSelection).\n/// - Alt-u (Mod-Shift-u on macOS): [`redoSelection`](#history.redoSelection).\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\nexport { history, historyKeymap, invertedEffects, isolateHistory, redo, redoDepth, redoSelection, undo, undoDepth, undoSelection };\n","import { StateEffect, StateField, Facet, combineConfig } from '@codemirror/next/state';\nimport { Decoration, EditorView, WidgetType, themeClass } from '@codemirror/next/view';\nimport { foldable } from '@codemirror/next/language';\nimport { gutter, GutterMarker } from '@codemirror/next/gutter';\n\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : { from, to };\n}\nconst foldEffect = StateEffect.define({ map: mapRange });\nconst unfoldEffect = StateEffect.define({ map: mapRange });\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges) {\n        if (lines.some(l => l.from <= head && l.to >= head))\n            continue;\n        lines.push(view.visualLineAt(head));\n    }\n    return lines;\n}\nconst foldState = StateField.define({\n    create() {\n        return Decoration.none;\n    },\n    update(folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects) {\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))\n                folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });\n            else if (e.is(unfoldEffect)) {\n                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from, filterTo: e.value.to });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.primary;\n            folded.between(head, head, (a, b) => { if (a < head && b > head)\n                onSelection = true; });\n            if (onSelection)\n                folded = folded.update({\n                    filterFrom: head,\n                    filterTo: head,\n                    filter: (a, b) => b <= head || a >= head\n                });\n        }\n        return folded;\n    },\n    provide: [EditorView.decorations]\n});\nfunction foldInside(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n        if (!found || found.from > from)\n            found = ({ from, to });\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b) => { if (a == from && b == to)\n        found = true; });\n    return found;\n}\nfunction maybeEnable(state) {\n    return state.field(foldState, false) ? undefined : { append: codeFolding() };\n}\n/// Fold the lines that are selected, if possible.\nconst foldCode = view => {\n    for (let line of selectedLines(view)) {\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({ effects: foldEffect.of(range),\n                reconfigure: maybeEnable(view.state) });\n            return true;\n        }\n    }\n    return false;\n};\n/// Unfold folded ranges on selected lines.\nconst unfoldCode = view => {\n    if (!view.state.field(foldState, false))\n        return false;\n    let effects = [];\n    for (let line of selectedLines(view)) {\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded)\n            effects.push(unfoldEffect.of(folded));\n    }\n    if (effects.length)\n        view.dispatch({ effects });\n    return effects.length > 0;\n};\n/// Fold all top-level foldable ranges.\nconst foldAll = view => {\n    let { state } = view, effects = [];\n    for (let pos = 0; pos < state.doc.length;) {\n        let line = view.visualLineAt(pos), range = foldable(state, line.from, line.to);\n        if (range)\n            effects.push(foldEffect.of(range));\n        pos = (range ? view.visualLineAt(range.to) : line).to + 1;\n    }\n    if (effects.length)\n        view.dispatch({ effects, reconfigure: maybeEnable(view.state) });\n    return !!effects.length;\n};\n/// Unfold all folded code.\nconst unfoldAll = view => {\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size)\n        return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });\n    view.dispatch({ effects });\n    return true;\n};\n/// Default fold-related key bindings.\n///\n///  - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](#fold.foldCode).\n///  - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](#fold.unfoldCode).\n///  - Ctrl-Alt-[: [`foldAll`](#fold.foldAll).\n///  - Ctrl-Alt-]: [`unfoldAll`](#fold.unfoldAll).\nconst foldKeymap = [\n    { key: \"Ctrl-Shift-[\", mac: \"Cmd-Alt-[\", run: foldCode },\n    { key: \"Ctrl-Shift-]\", mac: \"Cmd-Alt-]\", run: unfoldCode },\n    { key: \"Ctrl-Alt-[\", run: foldAll },\n    { key: \"Ctrl-Alt-]\", run: unfoldAll }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = Facet.define({\n    combine(values) { return combineConfig(values, defaultConfig); }\n});\n/// Create an extension that configures code folding.\nfunction codeFolding(config) {\n    let result = [foldState, baseTheme];\n    if (config)\n        result.push(foldConfig.of(config));\n    return result;\n}\nconst foldWidget = Decoration.replace({ widget: new class extends WidgetType {\n        ignoreEvents() { return false; }\n        toDOM(view) {\n            let { state } = view, conf = state.facet(foldConfig);\n            if (conf.placeholderDOM)\n                return conf.placeholderDOM();\n            let element = document.createElement(\"span\");\n            element.textContent = conf.placeholderText;\n            element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n            element.title = state.phrase(\"unfold\");\n            element.className = themeClass(\"foldPlaceholder\");\n            element.onclick = event => {\n                let line = view.visualLineAt(view.posAtDOM(event.target));\n                let folded = foldInside(view.state, line.from, line.to);\n                if (folded)\n                    view.dispatch({ effects: unfoldEffect.of(folded) });\n                event.preventDefault();\n            };\n            return element;\n        }\n    } });\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\"\n};\nclass FoldMarker extends GutterMarker {\n    constructor(config, open) {\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) { return this.config == other.config && this.open == other.open; }\n    toDOM(view) {\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/// Create an extension that registers a fold gutter, which shows a\n/// fold status indicator before lines which can be clicked to fold or\n/// unfold the line.\nfunction foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    return [\n        gutter({\n            style: \"foldGutter\",\n            lineMarker(view, line) {\n                // FIXME optimize this. At least don't run it for updates that\n                // don't change anything relevant\n                let folded = foldInside(view.state, line.from, line.to);\n                if (folded)\n                    return canUnfold;\n                if (foldable(view.state, line.from, line.to))\n                    return canFold;\n                return null;\n            },\n            initialSpacer() {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: {\n                click: (view, line) => {\n                    let folded = foldInside(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({ effects: unfoldEffect.of(folded) });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({ effects: foldEffect.of(range) });\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme = EditorView.baseTheme({\n    $foldPlaceholder: {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \"$gutterElement.foldGutter\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n\nexport { codeFolding, foldAll, foldCode, foldGutter, foldKeymap, unfoldAll, unfoldCode };\n","import { EditorView } from '@codemirror/next/view';\nimport { StateEffect, MapMode, StateField, EditorSelection, Transaction, CharCategory } from '@codemirror/next/state';\nimport { RangeValue, RangeSet } from '@codemirror/next/rangeset';\nimport { codePointSize, codePointAt, fromCodePoint } from '@codemirror/next/text';\nimport { syntaxTree } from '@codemirror/next/language';\n\nconst defaults = {\n    brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    before: \")]}'\\\":;>\"\n};\nconst closeBracketEffect = StateEffect.define({\n    map(value, mapping) {\n        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst skipBracketEffect = StateEffect.define({\n    map(value, mapping) { return mapping.mapPos(value); }\n});\nconst closedBracket = new class extends RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = StateField.define({\n    create() { return RangeSet.empty; },\n    update(value, tr) {\n        if (tr.selection) {\n            let lineStart = tr.state.doc.lineAt(tr.selection.primary.head).from;\n            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.primary.head).from;\n            if (lineStart != tr.changes.mapPos(prevLineStart, -1))\n                value = RangeSet.empty;\n        }\n        value = value.map(tr.changes);\n        for (let effect of tr.effects) {\n            if (effect.is(closeBracketEffect))\n                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });\n            else if (effect.is(skipBracketEffect))\n                value = value.update({ filter: from => from != effect.value });\n        }\n        return value;\n    }\n});\n/// Extension to enable bracket-closing behavior. When a closeable\n/// bracket is typed, its closing bracket is immediately inserted\n/// after the cursor. When closing a bracket directly in front of that\n/// closing bracket, the cursor moves over the existing bracket.\nfunction closeBrackets() {\n    return [EditorView.inputHandler.of(handleInput), bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return fromCodePoint(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nfunction handleInput(view, from, to, insert) {\n    if (view.composing)\n        return false;\n    let sel = view.state.selection.primary;\n    if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 ||\n        from != sel.from || to != sel.to)\n        return false;\n    let tr = handleInsertion(view.state, insert);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n}\n/// Command that implements deleting a pair of matching brackets when\n/// the cursor is between them.\nconst deleteBracketPair = ({ state, dispatch }) => {\n    let conf = config(state, state.selection.primary.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens) {\n                if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))\n                    return { changes: { from: range.head - token.length, to: range.head + token.length },\n                        range: EditorSelection.cursor(range.head - token.length),\n                        annotations: Transaction.userEvent.of(\"delete\") };\n            }\n        }\n        return { range: dont = range };\n    });\n    if (!dont)\n        dispatch(state.update(changes, { scrollIntoView: true }));\n    return !dont;\n};\n/// Close-brackets related key bindings. Binds Backspace to\n/// [`deleteBracketPair`](#closebrackets.deleteBracketPair).\nconst closeBracketsKeymap = [\n    { key: \"Backspace\", run: deleteBracketPair }\n];\n/// Implements the extension's behavior on text insertion. @internal\nfunction handleInsertion(state, ch) {\n    let conf = config(state, state.selection.primary.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens) {\n        let closed = closing(codePointAt(tok, 0));\n        if (ch == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1)\n                : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (ch == closed && closedBracketAt(state, state.selection.primary.from))\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, from => {\n        if (from == pos)\n            found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, codePointSize(codePointAt(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],\n                effects: closeBracketEffect.of(range.to + open.length),\n                range: EditorSelection.range(range.anchor + open.length, range.head + open.length) };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1)\n            return { changes: { insert: open + close, from: range.head },\n                effects: closeBracketEffect.of(range.head + open.length),\n                range: EditorSelection.cursor(range.head + open.length) };\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        annotations: Transaction.userEvent.of(\"input\")\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, moved = state.selection.ranges.map(range => {\n        if (range.empty && nextChar(state.doc, range.head) == close)\n            return EditorSelection.cursor(range.head + close.length);\n        return dont = range;\n    });\n    return dont ? null : state.update({\n        selection: EditorSelection.create(moved, state.selection.primaryIndex),\n        scrollIntoView: true,\n        effects: state.selection.ranges.map(({ from }) => skipBracketEffect.of(from))\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],\n                effects: closeBracketEffect.of(range.to + token.length),\n                range: EditorSelection.range(range.anchor + token.length, range.head + token.length) };\n        let pos = range.head, next = nextChar(state.doc, pos);\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n            }\n            else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                return { range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),\n                    effects: skipBracketEffect.of(pos) };\n            }\n        }\n        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&\n            nodeStart(state, pos - 2 * token.length)) {\n            return { changes: { insert: token + token + token + token, from: pos },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: EditorSelection.cursor(pos + token.length) };\n        }\n        else if (state.charCategorizer(pos)(next) != CharCategory.Word) {\n            let prev = state.sliceDoc(pos - 1, pos);\n            if (prev != token && state.charCategorizer(pos)(prev) != CharCategory.Word)\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n        }\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        annotations: Transaction.userEvent.of(\"input\")\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = syntaxTree(state).resolve(pos + 1);\n    return tree.parent && tree.from == pos;\n}\n\nexport { closeBrackets, closeBracketsKeymap, deleteBracketPair, handleInsertion };\n","import { showTooltip, tooltips } from '@codemirror/next/tooltip';\nimport { Facet, combineConfig, StateEffect, StateField, Transaction, Text, EditorSelection, precedence } from '@codemirror/next/state';\nimport { syntaxTree, indentUnit } from '@codemirror/next/language';\nimport { EditorView, Direction, themeClass, ViewPlugin, logException, Decoration, WidgetType, keymap } from '@codemirror/next/view';\nimport { codePointAt, codePointSize, fromCodePoint } from '@codemirror/next/text';\n\n/// An instance of this is passed to completion source functions.\nclass CompletionContext {\n    /// Create a new completion context. (Mostly useful for testing\n    /// completion sources—in the editor, the extension will create\n    /// these for you.)\n    constructor(\n    /// The editor state that the completion happens in.\n    state, \n    /// The position at which the completion happens.\n    pos, \n    /// Indicates whether completion was activated explicitly, or\n    /// implicitly by typing. The usual way to respond to this is to\n    /// only return completions when either there is part of a\n    /// completable entity at the cursor, or explicit is true.\n    explicit) {\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /// @internal\n        this.abortListeners = [];\n    }\n    /// Get the extent, content, and (if there is a token) type of the\n    /// token before `this.pos`.\n    tokenBefore(types) {\n        let token = syntaxTree(this.state).resolve(this.pos, -1);\n        while (token && types.indexOf(token.name) < 0)\n            token = token.parent;\n        return token ? { from: token.from, to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type } : null;\n    }\n    /// Get the match of the given expression directly before the\n    /// cursor.\n    matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\n    }\n    /// Yields true when the query has been aborted. Can be useful in\n    /// asynchronous queries to avoid doing work that will be ignored.\n    get aborted() { return this.abortListeners == null; }\n    /// Allows you to register abort handlers, which will be called when\n    /// the query is\n    /// [aborted](#autocomplete.CompletionContext.aborted).\n    addEventListener(_type, listener) {\n        if (this.abortListeners)\n            this.abortListeners.push(listener);\n    }\n}\nclass Option {\n    constructor(completion, source, match) {\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n    }\n}\nfunction cur(state) { return state.selection.primary.head; }\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd)\n        return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\n}\nfunction applyCompletion(view, option) {\n    let apply = option.completion.apply || option.completion.label;\n    let result = option.source;\n    if (typeof apply == \"string\") {\n        view.dispatch({\n            changes: { from: result.from, to: result.to, insert: apply },\n            selection: { anchor: result.from + apply.length }\n        });\n    }\n    else {\n        apply(view, option.completion, result.from, result.to);\n    }\n}\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        for (let p = 0; p < pattern.length;) {\n            let char = codePointAt(pattern, p), size = codePointSize(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return null for no match, and otherwise an array that starts\n    // with the match score, followed by any number of `from, to` pairs\n    // indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0)\n            return [0];\n        if (word.length < this.pattern.length)\n            return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = codePointAt(word, 0);\n            return first == chars[0] ? [0, 0, codePointSize(first)]\n                : first == folded[0] ? [-200 /* CaseFold */, 0, codePointSize(first)] : null;\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0)\n            return [0, 0, this.pattern.length];\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n                let next = codePointAt(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo])\n                    any[anyTo++] = i;\n                i += codePointSize(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len)\n                return null;\n        }\n        let preciseTo = 0;\n        let byWordTo = 0, byWordFolded = false;\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {\n            let next = codePointAt(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo])\n                    precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0)\n                            adjacentStart = i;\n                        adjacentEnd = i;\n                        adjacentTo++;\n                    }\n                    else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)\n                : ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);\n            if (type == 1 /* Upper */ || prevType == 0 /* NonWord */ && type != 0 /* NonWord */ &&\n                (this.chars[byWordTo] == next || (this.folded[byWordTo] == next && (byWordFolded = true))))\n                byWord[byWordTo++] = i;\n            prevType = type;\n            i += codePointSize(next);\n        }\n        if (byWordTo == len && byWord[0] == 0)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0)\n            return [-200 /* CaseFold */, 0, adjacentEnd];\n        if (direct > -1)\n            return [-700 /* NotStart */, direct, direct + this.pattern.length];\n        if (adjacentTo == len)\n            return [-200 /* CaseFold */ + -700 /* NotStart */, adjacentStart, adjacentEnd];\n        if (byWordTo == len)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */, byWord, word);\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);\n    }\n    result(score, positions, word) {\n        let result = [score], i = 1;\n        for (let pos of positions) {\n            let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n            if (i > 1 && result[i - 1] == pos)\n                result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return result;\n    }\n}\n\nconst completionConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            activateOnTyping: true,\n            override: null,\n            maxRenderedOptions: 100\n        });\n    }\n});\n\nconst MaxInfoWidth = 300;\nconst baseTheme = EditorView.baseTheme({\n    \"$tooltip.autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            overflowY: \"auto\",\n            whiteSpace: \"nowrap\",\n            maxHeight: \"10em\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li\": {\n                cursor: \"pointer\",\n                padding: \"1px 1em 1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li[aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            }\n        }\n    },\n    \"$completionListIncompleteTop:before, $completionListIncompleteBottom:after\": {\n        content: '\"···\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \"$tooltip.completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: MaxInfoWidth + \"px\",\n    },\n    \"$tooltip.completionInfo.left\": { right: \"100%\" },\n    \"$tooltip.completionInfo.right\": { left: \"100%\" },\n    \"$$light $snippetField\": { backgroundColor: \"#ddd\" },\n    \"$$dark $snippetField\": { backgroundColor: \"#333\" },\n    \"$snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    $completionMatchedText: {\n        textDecoration: \"underline\"\n    },\n    $completionDetail: {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    $completionIcon: {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\"\n    },\n    \"$completionIcon.function, $completionIcon.method\": {\n        \"&:after\": { content: \"'ƒ'\" }\n    },\n    \"$completionIcon.class\": {\n        \"&:after\": { content: \"'○'\" }\n    },\n    \"$completionIcon.interface\": {\n        \"&:after\": { content: \"'◌'\" }\n    },\n    \"$completionIcon.variable\": {\n        \"&:after\": { content: \"'𝑥'\" }\n    },\n    \"$completionIcon.constant\": {\n        \"&:after\": { content: \"'𝐶'\" }\n    },\n    \"$completionIcon.type\": {\n        \"&:after\": { content: \"'𝑡'\" }\n    },\n    \"$completionIcon.enum\": {\n        \"&:after\": { content: \"'∪'\" }\n    },\n    \"$completionIcon.property\": {\n        \"&:after\": { content: \"'□'\" }\n    },\n    \"$completionIcon.keyword\": {\n        \"&:after\": { content: \"'🔑\\uFE0E'\" } // Disable emoji rendering\n    },\n    \"$completionIcon.namespace\": {\n        \"&:after\": { content: \"'▢'\" }\n    },\n    \"$completionIcon.text\": {\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n    }\n});\n\nfunction createListBox(options, id, range) {\n    const ul = document.createElement(\"ul\");\n    ul.id = id;\n    ul.setAttribute(\"role\", \"listbox\");\n    ul.setAttribute(\"aria-expanded\", \"true\");\n    for (let i = range.from; i < range.to; i++) {\n        let { completion, match } = options[i];\n        const li = ul.appendChild(document.createElement(\"li\"));\n        li.id = id + \"-\" + i;\n        let icon = li.appendChild(document.createElement(\"div\"));\n        icon.className = themeClass(\"completionIcon\" + (completion.type ? \".\" + completion.type : \"\"));\n        icon.setAttribute(\"aria-hidden\", \"true\");\n        let labelElt = li.appendChild(document.createElement(\"span\"));\n        labelElt.className = themeClass(\"completionLabel\");\n        let { label, detail } = completion, off = 0;\n        for (let j = 1; j < match.length;) {\n            let from = match[j++], to = match[j++];\n            if (from > off)\n                labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n            let span = labelElt.appendChild(document.createElement(\"span\"));\n            span.appendChild(document.createTextNode(label.slice(from, to)));\n            span.className = themeClass(\"completionMatchedText\");\n            off = to;\n        }\n        if (off < label.length)\n            labelElt.appendChild(document.createTextNode(label.slice(off)));\n        if (detail) {\n            let detailElt = li.appendChild(document.createElement(\"span\"));\n            detailElt.className = themeClass(\"completionDetail\");\n            detailElt.textContent = detail;\n        }\n        li.setAttribute(\"role\", \"option\");\n    }\n    if (range.from)\n        ul.classList.add(themeClass(\"completionListIncompleteTop\"));\n    if (range.to < options.length)\n        ul.classList.add(themeClass(\"completionListIncompleteBottom\"));\n    return ul;\n}\nfunction createInfoDialog(option) {\n    let dom = document.createElement(\"div\");\n    dom.className = themeClass(\"tooltip.completionInfo\");\n    let { info } = option.completion;\n    if (typeof info == \"string\")\n        dom.textContent = info;\n    else\n        dom.appendChild(info(option.completion));\n    return dom;\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max)\n        return { from: 0, to: total };\n    if (selected <= (total >> 1)) {\n        let off = Math.floor(selected / max);\n        return { from: off * max, to: (off + 1) * max };\n    }\n    let off = Math.floor((total - selected) / max);\n    return { from: total - (off + 1) * max, to: total - off * max };\n}\nclass CompletionTooltip {\n    constructor(view, stateField) {\n        this.view = view;\n        this.stateField = stateField;\n        this.info = null;\n        this.placeInfo = {\n            read: () => this.measureInfo(),\n            write: (pos) => this.positionInfo(pos),\n            key: this\n        };\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.addEventListener(\"mousedown\", (e) => {\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.list = this.dom.appendChild(createListBox(options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", () => {\n            if (this.info)\n                this.view.requestMeasure(this.placeInfo);\n        });\n    }\n    mount() { this.updateSel(); }\n    update(update) {\n        if (update.state.field(this.stateField) != update.prevState.field(this.stateField))\n            this.updateSel();\n    }\n    positioned() {\n        if (this.info)\n            this.view.requestMeasure(this.placeInfo);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.list.remove();\n            this.list = this.dom.appendChild(createListBox(open.options, cState.id, this.range));\n            this.list.addEventListener(\"scroll\", () => {\n                if (this.info)\n                    this.view.requestMeasure(this.placeInfo);\n            });\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            if (this.info) {\n                this.info.remove();\n                this.info = null;\n            }\n            let option = open.options[open.selected];\n            if (option.completion.info) {\n                this.info = this.dom.appendChild(createInfoDialog(option));\n                this.view.requestMeasure(this.placeInfo);\n            }\n        }\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n            if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            }\n            else {\n                if (opt.hasAttribute(\"aria-selected\"))\n                    opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set)\n            scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel)\n            return null;\n        let rect = this.dom.getBoundingClientRect();\n        let top = sel.getBoundingClientRect().top - rect.top;\n        if (top < 0 || top > this.list.clientHeight - 10)\n            return null;\n        let left = this.view.textDirection == Direction.RTL;\n        let spaceLeft = rect.left, spaceRight = innerWidth - rect.right;\n        if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight))\n            left = false;\n        else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft))\n            left = true;\n        return { top, left };\n    }\n    positionInfo(pos) {\n        if (this.info && pos) {\n            this.info.style.top = pos.top + \"px\";\n            this.info.classList.toggle(\"cm-tooltip-completionInfo-left\", pos.left);\n            this.info.classList.toggle(\"cm-tooltip-completionInfo-right\", !pos.left);\n        }\n    }\n}\n// We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\nfunction completionTooltip(stateField) {\n    return (view) => new CompletionTooltip(view, stateField);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    if (self.top < parent.top)\n        container.scrollTop -= parent.top - self.top;\n    else if (self.bottom > parent.bottom)\n        container.scrollTop += self.bottom - parent.bottom;\n}\n\nconst MaxOptions = 300;\nfunction sortOptions(active, state) {\n    let options = [];\n    for (let a of active)\n        if (a.hasResult()) {\n            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;\n            for (let option of a.result.options)\n                if (match = matcher.match(option.label)) {\n                    if (option.boost != null)\n                        match[0] += option.boost;\n                    options.push(new Option(option, a, match));\n                }\n        }\n    options.sort(cmpOption);\n    return options.length > MaxOptions ? options.slice(0, MaxOptions) : options;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected) {\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n    }\n    static build(active, state, id, prev) {\n        let options = sortOptions(active, state);\n        if (!options.length)\n            return null;\n        let selected = 0;\n        if (prev) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for (let i = 0; i < options.length && !selected; i++) {\n                if (options[i].completion == selectedValue)\n                    selected = i;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), [{\n                pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n                style: \"autocomplete\",\n                create: completionTooltip(completionState)\n            }], prev ? prev.timestamp : Date.now(), selected);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, [Object.assign(Object.assign({}, this.tooltip[0]), { pos: changes.mapPos(this.tooltip[0].pos) })], this.timestamp, this.selected);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open) {\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state));\n        let active = sources.map(source => {\n            let value = this.active.find(s => s.source == source) || new ActiveSource(source, 0 /* Inactive */, false);\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\n            active = this.active;\n        let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\n            !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open)\n            : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n        for (let effect of tr.effects)\n            if (effect.is(setSelectedEffect))\n                open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() { return this.open ? this.open.tooltip : none; }\n    get attrs() { return this.open ? this.open.attrs : baseAttrs; }\n}\nfunction sameResults(a, b) {\n    if (a == b)\n        return true;\n    for (let iA = 0, iB = 0;;) {\n        while (iA < a.length && !a[iA].hasResult)\n            iA++;\n        while (iB < b.length && !b[iB].hasResult)\n            iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB)\n            return endA == endB;\n        if (a[iA++].result != b[iB++].result)\n            return false;\n    }\n}\nfunction makeAttrs(id, selected) {\n    return {\n        \"aria-autocomplete\": \"list\",\n        \"aria-activedescendant\": id + \"-\" + selected,\n        \"aria-owns\": id\n    };\n}\nconst baseAttrs = { \"aria-autocomplete\": \"list\" }, none = [];\nfunction cmpOption(a, b) {\n    let dScore = b.match[0] - a.match[0];\n    if (dScore)\n        return dScore;\n    let lA = a.completion.label, lB = b.completion.label;\n    return lA < lB ? -1 : lA == lB ? 0 : 1;\n}\nclass ActiveSource {\n    constructor(source, state, explicit) {\n        this.source = source;\n        this.state = state;\n        this.explicit = explicit;\n    }\n    hasResult() { return false; }\n    update(tr, conf) {\n        let event = tr.annotation(Transaction.userEvent), value = this;\n        if (event == \"input\" || event == \"delete\")\n            value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged)\n            value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* Inactive */)\n            value = new ActiveSource(value.source, 0 /* Inactive */, false);\n        for (let effect of tr.effects) {\n            if (effect.is(startCompletionEffect))\n                value = new ActiveSource(value.source, 1 /* Pending */, effect.value);\n            else if (effect.is(closeCompletionEffect))\n                value = new ActiveSource(value.source, 0 /* Inactive */, false);\n            else if (effect.is(setActiveEffect))\n                for (let active of effect.value)\n                    if (active.source == value.source)\n                        value = active;\n        }\n        return value;\n    }\n    handleUserEvent(_tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this : new ActiveSource(this.source, 1 /* Pending */, false);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */, false) : this;\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicit, result, from, to, span) {\n        super(source, 2 /* Result */, explicit);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n        this.span = span;\n    }\n    hasResult() { return true; }\n    handleUserEvent(tr, type, conf) {\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicit ? pos < from : pos <= from) || pos > to)\n            return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */, false);\n        if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to))))\n            return new ActiveResult(this.source, this.explicit, this.result, from, to, this.span);\n        return new ActiveSource(this.source, 1 /* Pending */, this.explicit);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to)\n            ? new ActiveSource(this.source, 0 /* Inactive */, false)\n            : new ActiveResult(this.source, this.explicit, this.result, tr.changes.mapPos(this.from), tr.changes.mapPos(this.to, 1), this.span);\n    }\n    map(mapping) {\n        return new ActiveResult(this.source, this.explicit, this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n    }\n}\nconst startCompletionEffect = StateEffect.define();\nconst closeCompletionEffect = StateEffect.define();\nconst setActiveEffect = StateEffect.define({\n    map(sources, mapping) { return sources.map(s => s.hasResult() && !mapping.empty ? s.map(mapping) : s); }\n});\nconst setSelectedEffect = StateEffect.define();\nconst completionState = StateField.define({\n    create() { return CompletionState.start(); },\n    update(value, tr) { return value.update(tr); },\n    provide: [\n        showTooltip.nFrom(state => state.tooltip),\n        EditorView.contentAttributes.from(state => state.attrs)\n    ]\n});\n\nconst CompletionInteractMargin = 75;\n/// Returns a command that moves the completion selection forward or\n/// backward by the given amount.\nfunction moveCompletionSelection(forward, by = \"option\") {\n    return (view) => {\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n            return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = view.dom.querySelector(\".cm-tooltip-autocomplete\")))\n            step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));\n        let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;\n        if (selected < 0)\n            selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length)\n            selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\n        return true;\n    };\n}\n/// Accept the current completion.\nconst acceptCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n        return false;\n    applyCompletion(view, cState.open.options[cState.open.selected]);\n    return true;\n};\n/// Explicitly start autocompletion.\nconst startCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState)\n        return false;\n    view.dispatch({ effects: startCompletionEffect.of(true) });\n    return true;\n};\n/// Close the currently active completion.\nconst closeCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))\n        return false;\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\n    return true;\n};\nclass RunningQuery {\n    constructor(source, context) {\n        this.source = source;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.composing = 0 /* None */;\n        for (let active of view.state.field(completionState).active)\n            if (active.state == 1 /* Pending */)\n                this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.prevState.field(completionState) == cState)\n            return;\n        let doesReset = update.transactions.some(tr => {\n            let event = tr.annotation(Transaction.userEvent);\n            return (tr.selection || tr.docChanged) && event != \"input\" && event != \"delete\";\n        });\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (doesReset ||\n                query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n                for (let handler of query.context.abortListeners) {\n                    try {\n                        handler();\n                    }\n                    catch (e) {\n                        logException(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            }\n            else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1)\n            clearTimeout(this.debounceUpdate);\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.source == a.source))\n            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n        if (this.composing != 0 /* None */)\n            for (let tr of update.transactions) {\n                if (tr.annotation(Transaction.userEvent) == \"input\")\n                    this.composing = 2 /* Changed */;\n                else if (this.composing == 2 /* Changed */ && tr.selection)\n                    this.composing = 3 /* ChangedAndMoved */;\n            }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active) {\n            if (active.state == 1 /* Pending */ && !this.running.some(r => r.source == active.source))\n                this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicit);\n        let pending = new RunningQuery(active.source, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then(result => {\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, err => {\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            logException(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every(q => q.done !== undefined))\n            this.accept();\n        else if (this.debounceAccept < 0)\n            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1)\n            clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (query.done === undefined)\n                continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.source, query.context.explicit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span ? ensureAnchor(query.done.span, true) : null);\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)\n                    active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.source);\n            if (current && current.state == 1 /* Pending */) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.source, 0 /* Inactive */, false);\n                    for (let tr of query.updates)\n                        active = active.update(tr, conf);\n                    if (active.state != 1 /* Pending */)\n                        updated.push(active);\n                }\n                else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length)\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\n    }\n}, {\n    eventHandlers: {\n        compositionstart() {\n            this.composing = 1 /* Started */;\n        },\n        compositionend() {\n            if (this.composing == 3 /* ChangedAndMoved */)\n                this.view.dispatch({ effects: startCompletionEffect.of(false) });\n            this.composing = 0 /* None */;\n        }\n    } // See https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/949\n});\n\nclass FieldPos {\n    constructor(field, line, from, to) {\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to) {\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions) {\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [pos];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.slice(0, Math.min(100, lineObj.length)))[0];\n        for (let line of this.lines) {\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for (let i = 0; i < tabs; i++)\n                    indent += state.facet(indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return { text, ranges };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)) {\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3], found = -1;\n                for (let i = 0; i < fields.length; i++) {\n                    if (name ? fields[i].name == name : seq != null && fields[i].seq == seq)\n                        found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\n                        i++;\n                    fields.splice(i, 0, { seq, name: name || null });\n                    found = i;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = Decoration.widget({ widget: new class extends WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = themeClass(\"snippetFieldPosition\");\n            return span;\n        }\n        ignoreEvent() { return false; }\n    } });\nlet fieldRange = Decoration.mark({ class: themeClass(\"snippetField\") });\nclass ActiveSnippet {\n    constructor(ranges, active) {\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = StateEffect.define({\n    map(value, changes) { return value && value.map(changes); }\n});\nconst moveToField = StateEffect.define();\nconst snippetState = StateField.define({\n    create() { return null; },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setActive))\n                return effect.value;\n            if (effect.is(moveToField) && value)\n                return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged)\n            value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\n            value = null;\n        return value;\n    },\n    provide: [EditorView.decorations.from(val => val ? val.deco : Decoration.none)]\n});\nfunction fieldSelection(ranges, field) {\n    return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));\n}\n/// Convert a snippet template to a function that can apply it.\n/// Snippets are written using syntax like this:\n///\n///     \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n///\n/// Each `${}` placeholder (you may also use `#{}`) indicates a field\n/// that the user can fill in. Its name, if any, will be the default\n/// content for the field.\n///\n/// When the snippet is activated by calling the returned function,\n/// the code is inserted at the given position. Newlines in the\n/// template are indented by the indentation of the start line, plus\n/// one [indent unit](#language.indentUnit) per tab character after\n/// the newline.\n///\n/// On activation, (all instances of) the first field are selected.\n/// The user can move between fields with Tab and Shift-Tab as long as\n/// the fields are active. Moving to the last field or moving the\n/// cursor out of the current field deactivates the fields.\n///\n/// The order of fields defaults to textual order, but you can add\n/// numbers to placeholders (`${1}` or `${1:defaultText}`) to provide\n/// a custom order.\nfunction snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, _completion, from, to) => {\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = { changes: { from, to, insert: Text.of(text) } };\n        if (ranges.length)\n            spec.selection = fieldSelection(ranges, 0);\n        if (ranges.length > 1) {\n            spec.effects = setActive.of(new ActiveSnippet(ranges, 0));\n            if (editor.state.field(snippetState, false) === undefined)\n                spec.reconfigure = { append: [snippetState, snippetKeymap, baseTheme] };\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch }) => {\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0)\n            return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n        }));\n        return true;\n    };\n}\nconst clearSnippet = ({ state, dispatch }) => {\n    let active = state.field(snippetState, false);\n    if (!active)\n        return false;\n    dispatch(state.update({ effects: setActive.of(null) }));\n    return true;\n};\nconst snippetKeymap = precedence(keymap([\n    { key: \"Tab\", run: moveField(1), shift: moveField(-1) },\n    { key: \"Escape\", run: clearSnippet }\n]), \"override\");\n\n/// Returns an extension that enables autocompletion.\nfunction autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        baseTheme,\n        tooltips(),\n        precedence(keymap([\n            { key: \"ArrowDown\", run: moveCompletionSelection(true) },\n            { key: \"ArrowUp\", run: moveCompletionSelection(false) },\n            { key: \"PageDown\", run: moveCompletionSelection(true, \"page\") },\n            { key: \"PageUp\", run: moveCompletionSelection(false, \"page\") },\n            { key: \"Enter\", run: acceptCompletion }\n        ]), \"override\")\n    ];\n}\n/// Basic keybindings for autocompletion.\n///\n///  - Ctrl-Space (Cmd-Space on macOS): [`startCompletion`](#autocomplete.startCompletion)\n///  - Escape: [`closeCompletion`](#autocomplete.closeCompletion)\nconst completionKeymap = [\n    { key: \"Mod-Space\", run: startCompletion },\n    { key: \"Escape\", run: closeCompletion }\n];\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words)\n        flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options) {\n        first[label[0]] = true;\n        for (let i = 1; i < label.length; i++)\n            rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/// Given a a fixed array of options, return an autocompleter that\n/// compares those options to the current\n/// [token](#autocomplete.CompletionContext.tokenBefore) and returns\n/// the matching ones.\nfunction completeFromList(list) {\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\n    let [span, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n    return (context) => {\n        let token = context.matchBefore(match);\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, span } : null;\n    };\n}\n/// Wrap the given completion source so that it will not fire when the\n/// cursor is in a syntax node with one of the given names.\nfunction ifNotIn(nodes, source) {\n    return (context) => {\n        for (let pos = syntaxTree(context.state).resolve(context.pos, -1); pos; pos = pos.parent)\n            if (nodes.indexOf(pos.name) > -1)\n                return null;\n        return source(context);\n    };\n}\n/// Create a completion source from an array of snippet specs.\nfunction completeSnippets(snippets) {\n    return completeFromList(snippets.map(s => Object.assign({}, s, { apply: snippet(s.snippet) })));\n}\n/// Get the current completion status. When completions are available,\n/// this will return `\"active\"`. When completions are pending (in the\n/// process of being queried), this returns `\"pending\"`. Otherwise, it\n/// returns `null`.\nfunction completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some(a => a.state == 1 /* Pending */) ? \"pending\"\n        : cState && cState.active.some(a => a.state != 0 /* Inactive */) ? \"active\" : null;\n}\n/// Returns the available completions as an array.\nfunction currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open ? open.options.map(o => o.completion) : [];\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, closeCompletion, completeFromList, completeSnippets, completionKeymap, completionStatus, currentCompletions, ifNotIn, moveCompletionSelection, snippet, startCompletion };\n","import { EditorSelection } from '@codemirror/next/state';\nimport { EditorView } from '@codemirror/next/view';\nimport { findColumn, countColumn } from '@codemirror/next/text';\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            if (line.length <= endOff)\n                ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    }\n    else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i), str = line.length > MaxOff ? line.slice(0, 2 * endCol) : line.slice();\n            let start = findColumn(str, 0, startCol, state.tabSize), end = findColumn(str, 0, endCol, state.tabSize);\n            if (!start.leftOver)\n                ranges.push(EditorSelection.range(line.from + start.offset, line.from + end.offset));\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    if (offset == null)\n        return null;\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1\n        : off == line.length ? absoluteColumn(view, event.clientX)\n            : countColumn(line.slice(0, offset - line.from), 0, view.state.tabSize);\n    return { line: line.number, col, off };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start)\n        return null;\n    return {\n        update(update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.prevState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur)\n                return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length)\n                return startSel;\n            if (multiple)\n                return EditorSelection.create(ranges.concat(startSel.ranges));\n            else\n                return EditorSelection.create(ranges);\n        }\n    };\n}\n/// Create an extension that enables rectangular selections. By\n/// default, it will rect to left mouse drag with the alt key held\n/// down. When such a selection occurs, the text within the rectangle\n/// that was dragged over will be selected, as one selection\n/// [range](#state.SelectionRange) per line. You can pass a custom\n/// predicate function, which takes a `mousedown` event and returns\n/// true if it should be used for rectangular selection.\nfunction rectangularSelection(eventFilter) {\n    let filter = eventFilter || (e => e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\n\nexport { rectangularSelection };\n","import { getPanel, panels, showPanel } from '@codemirror/next/panel';\nimport { EditorSelection } from '@codemirror/next/state';\nimport { EditorView, themeClass } from '@codemirror/next/view';\n\nconst extTag = typeof Symbol == \"undefined\" ? \"__goto-line\" : Symbol(\"goto-line\");\nfunction createLineDialog(view) {\n    let dom = document.createElement(\"form\");\n    dom.innerHTML = `<label>${view.state.phrase(\"Go to line:\")} <input class=${themeClass(\"textfield\")} name=line></label>\n<button class=${themeClass(\"button\")} type=submit>${view.state.phrase(\"go\")}</button>`;\n    let input = dom.querySelector(\"input\");\n    function go() {\n        let n = parseInt(input.value, 10);\n        view.dispatch({\n            reconfigure: { [extTag]: [baseTheme] },\n            selection: !isNaN(n) && n > 0 && n <= view.state.doc.lines ? EditorSelection.cursor(view.state.doc.line(n).from) : undefined,\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    dom.addEventListener(\"keydown\", event => {\n        if (event.keyCode == 27) { // Escape\n            event.preventDefault();\n            view.dispatch({ reconfigure: { append: [baseTheme] } });\n            view.focus();\n        }\n        else if (event.keyCode == 13) { // Enter\n            event.preventDefault();\n            go();\n        }\n    });\n    dom.addEventListener(\"submit\", go);\n    return { dom, style: \"gotoLine\", pos: -10 };\n}\n/// Command that shows a dialog asking the user for a line number, and\n/// when a valid number is provided, moves the cursor to that line.\n///\n/// The dialog can be styled with the `panel.gotoLine` theme\n/// selector.\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        view.dispatch({ reconfigure: { append: [panels(), showPanel.of(createLineDialog), baseTheme] } });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme = EditorView.baseTheme({\n    \"$panel.gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n/// Keymap that binds Alt-g to [`gotoLine`](#goto-line.gotoLine).\nconst gotoLineKeymap = [\n    { key: \"Alt-g\", run: gotoLine }\n];\n\nexport { gotoLine, gotoLineKeymap };\n","import { highlightSpecialChars, drawSelection, keymap } from '@codemirror/next/view';\nexport { EditorView } from '@codemirror/next/view';\nimport { EditorState } from '@codemirror/next/state';\nexport { EditorState } from '@codemirror/next/state';\nimport { history, historyKeymap } from '@codemirror/next/history';\nimport { foldGutter, foldKeymap } from '@codemirror/next/fold';\nimport { indentOnInput } from '@codemirror/next/language';\nimport { lineNumbers } from '@codemirror/next/gutter';\nimport { defaultKeymap } from '@codemirror/next/commands';\nimport { bracketMatching } from '@codemirror/next/matchbrackets';\nimport { closeBrackets, closeBracketsKeymap } from '@codemirror/next/closebrackets';\nimport { searchKeymap } from '@codemirror/next/search';\nimport { autocompletion, completionKeymap } from '@codemirror/next/autocomplete';\nimport { commentKeymap } from '@codemirror/next/comment';\nimport { rectangularSelection } from '@codemirror/next/rectangular-selection';\nimport { gotoLineKeymap } from '@codemirror/next/goto-line';\nimport { highlightActiveLine, highlightSelectionMatches } from '@codemirror/next/highlight-selection';\nimport { defaultHighlightStyle } from '@codemirror/next/highlight';\nimport { lintKeymap } from '@codemirror/next/lint';\n\n/// This is an extension value that just pulls together a whole lot of\n/// extensions that you might want in a basic editor. It is meant as a\n/// convenient helper to quickly set up CodeMirror without installing\n/// and importing a lot of packages.\n///\n/// Specifically, it includes...\n///\n///  - [the default command bindings](#commands.defaultKeymap)\n///  - [line numbers](#gutter.lineNumbers)\n///  - [special character highlighting](#view.highlightSpecialChars)\n///  - [the undo history](#history.history)\n///  - [a fold gutter](#fold.foldGutter)\n///  - [custom selection drawing](#view.drawSelection)\n///  - [multiple selections](#state.EditorState^allowMultipleSelections)\n///  - [reindentation on input](#language.indentOnInput)\n///  - [the default highlight style](#highlight.defaultHighlightStyle)\n///  - [bracket matching](#matchbrackets.bracketMatching)\n///  - [bracket closing](#closebrackets.closeBrackets)\n///  - [autocompletion](#autocomplete.autocompletion)\n///  - [rectangular selection](#rectangular-selection.rectangularSelection)\n///  - [active line highlighting](#highlight-selection.highlightActiveLine)\n///  - [selection match highlighting](#highlight-selection.highlightSelectionMatches)\n///  - [search](#search.searchKeymap)\n///  - [go to line](#goto-line.gotoLineKeymap)\n///  - [commenting](#comment.commentKeymap)\n///  - [linting](#lint.lintKeymap)\n///\n/// (You'll probably want to add some language package to your setup\n/// too.)\n///\n/// This package does not allow customization. The idea is that, once\n/// you decide you want to configure your editor more precisely, you\n/// take this package's source (which is just a bunch of imports and\n/// an array literal), copy it into your own code, and adjust it as\n/// desired.\nconst basicSetup = [\n    lineNumbers(),\n    highlightSpecialChars(),\n    history(),\n    foldGutter(),\n    drawSelection(),\n    EditorState.allowMultipleSelections.of(true),\n    indentOnInput(),\n    defaultHighlightStyle,\n    bracketMatching(),\n    closeBrackets(),\n    autocompletion(),\n    rectangularSelection(),\n    highlightActiveLine(),\n    highlightSelectionMatches(),\n    keymap([\n        ...closeBracketsKeymap,\n        ...defaultKeymap,\n        ...searchKeymap,\n        ...historyKeymap,\n        ...foldKeymap,\n        ...commentKeymap,\n        ...gotoLineKeymap,\n        ...completionKeymap,\n        ...lintKeymap\n    ])\n];\n\nexport { basicSetup };\n","import { Transaction, EditorSelection, CharCategory } from '@codemirror/next/state';\nimport { Text, countColumn, codePointSize, codePointAt } from '@codemirror/next/text';\nimport { Direction } from '@codemirror/next/view';\nimport { matchBrackets } from '@codemirror/next/matchbrackets';\nimport { IndentContext, getIndentation, indentString, indentUnit, getIndentUnit, syntaxTree } from '@codemirror/next/language';\nimport { NodeProp } from 'lezer-tree';\n\nfunction updateSel(sel, by) {\n    return EditorSelection.create(sel.ranges.map(by), sel.primaryIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({ selection, scrollIntoView: true, annotations: Transaction.userEvent.of(\"keyboardselection\") });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\n/// Move the selection one character to the left (which is backward in\n/// left-to-right text, forward in right-to-left text).\nconst cursorCharLeft = view => cursorByChar(view, view.textDirection != Direction.LTR);\n/// Move the selection one character to the right.\nconst cursorCharRight = view => cursorByChar(view, view.textDirection == Direction.LTR);\n/// Move the selection one character forward.\nconst cursorCharForward = view => cursorByChar(view, true);\n/// Move the selection one character backward.\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/// Move the selection across one group of word or non-word (but also\n/// non-space) characters.\nconst cursorGroupLeft = view => cursorByGroup(view, view.textDirection != Direction.LTR);\n/// Move the selection one group to the right.\nconst cursorGroupRight = view => cursorByGroup(view, view.textDirection == Direction.LTR);\n/// Move the selection one group forward.\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/// Move the selection one group backward.\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp))\n        return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = syntaxTree(state).resolve(start.head);\n    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for (let at = start.head;;) {\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next)\n            break;\n        if (interestingNode(state, next, bracketProp))\n            pos = next;\n        else\n            at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)\n        newPos = forward ? match.end.to : match.end.from;\n    else\n        newPos = forward ? pos.to : pos.from;\n    return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/// Move the cursor over the next syntactic element to the left.\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));\n/// Move the cursor over the next syntactic element to the right.\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveVertically(range, forward) : rangeEnd(range, forward));\n}\n/// Move the selection one line up.\nconst cursorLineUp = view => cursorByLine(view, false);\n/// Move the selection one line down.\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction cursorByPage(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward));\n}\n/// Move the selection one page up.\nconst cursorPageUp = view => cursorByPage(view, false);\n/// Move the selection one page down.\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.visualLineAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\n        moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head > line.from + space)\n            moved = EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/// Move the selection to the next line wrap point, or to the end of\n/// the line if there isn't one left on this line.\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/// Move the selection to previous line wrap point, or failing that to\n/// the start of the line.\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/// Move the selection to the start of the line.\nconst cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).from, 1));\n/// Move the selection to the end of the line.\nconst cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, range => {\n        let matching = matchBrackets(state, range.head, -1)\n            || matchBrackets(state, range.head, 1)\n            || (range.head > 0 && matchBrackets(state, range.head - 1, 1))\n            || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));\n        if (!matching || !matching.end)\n            return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n    });\n    if (!found)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/// Move the selection to the bracket matching the one it is currently\n/// on, if any.\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\n/// Extend the selection to the bracket matching the one the selection\n/// head is currently on, if any.\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, range => {\n        let head = how(range);\n        return EditorSelection.range(range.anchor, head.head, head.goalColumn);\n    });\n    if (selection.eq(view.state.selection))\n        return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, range => view.moveByChar(range, forward));\n}\n/// Move the selection head one character to the left, while leaving\n/// the anchor in place.\nconst selectCharLeft = view => selectByChar(view, view.textDirection != Direction.LTR);\n/// Move the selection head one character to the right.\nconst selectCharRight = view => selectByChar(view, view.textDirection == Direction.LTR);\n/// Move the selection head one character forward.\nconst selectCharForward = view => selectByChar(view, true);\n/// Move the selection head one character backward.\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/// Move the selection head one [group](#commands.cursorGroupLeft) to\n/// the left.\nconst selectGroupLeft = view => selectByGroup(view, view.textDirection != Direction.LTR);\n/// Move the selection head one group to the right.\nconst selectGroupRight = view => selectByGroup(view, view.textDirection == Direction.LTR);\n/// Move the selection head one group forward.\nconst selectGroupForward = view => selectByGroup(view, true);\n/// Move the selection head one group backward.\nconst selectGroupBackward = view => selectByGroup(view, false);\n/// Move the selection head over the next syntactic element to the left.\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));\n/// Move the selection head over the next syntactic element to the right.\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));\nfunction selectByLine(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward));\n}\n/// Move the selection head one line up.\nconst selectLineUp = view => selectByLine(view, false);\n/// Move the selection head one line down.\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward, view.dom.clientHeight));\n}\n/// Move the selection head one page up.\nconst selectPageUp = view => selectByPage(view, false);\n/// Move the selection head one page down.\nconst selectPageDown = view => selectByPage(view, true);\n/// Move the selection head to the next line boundary.\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/// Move the selection head to the previous line boundary.\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/// Move the selection head to the start of the line.\nconst selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).from));\n/// Move the selection head to the end of the line.\nconst selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).to));\n/// Move the selection to the start of the document.\nconst cursorDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: 0 }));\n    return true;\n};\n/// Move the selection to the end of the document.\nconst cursorDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.doc.length }));\n    return true;\n};\n/// Move the selection head to the start of the document.\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.primary.anchor, head: 0 }));\n    return true;\n};\n/// Move the selection head to the end of the document.\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.primary.anchor, head: state.doc.length }));\n    return true;\n};\n/// Select the entire document.\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, annotations: Transaction.userEvent.of(\"keyboardselection\") }));\n    return true;\n};\n/// Expand the selection to cover entire lines.\nconst selectLine = ({ state, dispatch }) => {\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({ selection: new EditorSelection(ranges), annotations: Transaction.userEvent.of(\"keyboardselection\") }));\n    return true;\n};\n/// Select the next syntactic construct that is larger than the\n/// selection. Note that this will only work insofar as the language\n/// [provider](#language.language) you use builds up a full\n/// syntax tree.\nconst selectParentSyntax = ({ state, dispatch }) => {\n    let selection = updateSel(state.selection, range => {\n        var _a;\n        let context = syntaxTree(state).resolve(range.head, 1);\n        while (!((context.from < range.from && context.to >= range.to) ||\n            (context.to > range.to && context.from <= range.from) ||\n            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))\n            context = context.parent;\n        return EditorSelection.range(context.to, context.from);\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/// Simplify the current selection. When multiple ranges are selected,\n/// reduce it to its primary range. Otherwise, if the selection is\n/// non-empty, convert it to a cursor selection.\nconst simplifySelection = ({ state, dispatch }) => {\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1)\n        selection = new EditorSelection([cur.primary]);\n    else if (!cur.primary.empty)\n        selection = new EditorSelection([EditorSelection.cursor(cur.primary.head)]);\n    if (!selection)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(view, by) {\n    let { state } = view, changes = state.changeByRange(range => {\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(from);\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        }\n        return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from) };\n    });\n    if (changes.changes.empty)\n        return false;\n    view.dispatch(changes, { scrollIntoView: true, annotations: Transaction.userEvent.of(\"delete\") });\n    return true;\n}\nconst deleteByChar = (view, forward, codePoint) => deleteBy(view, pos => {\n    let { state } = view, line = state.doc.lineAt(pos), before;\n    if (!forward && pos > line.from && pos < line.from + 200 &&\n        !/[^ \\t]/.test(before = line.slice(0, pos - line.from))) {\n        if (before[before.length - 1] == \"\\t\")\n            return pos - 1;\n        let col = countColumn(before, 0, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\n            pos--;\n        return pos;\n    }\n    let target;\n    if (codePoint) {\n        let next = line.slice(pos - line.from + (forward ? 0 : -2), pos - line.from + (forward ? 2 : 0));\n        let size = next ? codePointSize(codePointAt(next, 0)) : 1;\n        target = forward ? Math.min(state.doc.length, pos + size) : Math.max(0, pos - size);\n    }\n    else {\n        target = line.findClusterBreak(pos - line.from, forward) + line.from;\n    }\n    if (target == pos && line.number != (forward ? state.doc.lines : 1))\n        target += forward ? 1 : -1;\n    return target;\n});\n/// Delete the selection, or, for cursor selections, the code point\n/// before the cursor.\nconst deleteCodePointBackward = view => deleteByChar(view, false, true);\n/// Delete the selection, or, for cursor selections, the code point\n/// after the cursor.\nconst deleteCodePointForward = view => deleteByChar(view, true, true);\n/// Delete the selection, or, for cursor selections, the character\n/// before the cursor.\nconst deleteCharBackward = view => deleteByChar(view, false, false);\n/// Delete the selection or the character after the cursor.\nconst deleteCharForward = view => deleteByChar(view, true, false);\nconst deleteByGroup = (view, forward) => deleteBy(view, pos => {\n    let { state } = view, line = state.doc.lineAt(pos), categorize = state.charCategorizer(pos);\n    for (let cat = null;;) {\n        let next, nextChar;\n        if (pos == (forward ? line.to : line.from)) {\n            if (line.number == (forward ? state.doc.lines : 1))\n                break;\n            line = state.doc.line(line.number + (forward ? 1 : -1));\n            next = forward ? line.from : line.to;\n            nextChar = \"\\n\";\n        }\n        else {\n            next = line.findClusterBreak(pos - line.from, forward) + line.from;\n            nextChar = line.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n        }\n        let nextCat = categorize(nextChar);\n        if (cat != null && nextCat != cat)\n            break;\n        if (nextCat != CharCategory.Space)\n            cat = nextCat;\n        pos = next;\n    }\n    return pos;\n});\n/// Delete the selection or backward until the end of the next\n/// [group](#view.EditorView.moveByGroup).\nconst deleteGroupBackward = view => deleteByGroup(view, false);\n/// Delete the selection or forward until the end of the next group.\nconst deleteGroupForward = view => deleteByGroup(view, true);\n/// Delete the selection, or, if it is a cursor selection, delete to\n/// the end of the line. If the cursor is directly at the end of the\n/// line, delete the line break after it.\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n    let lineEnd = view.visualLineAt(pos).to;\n    if (pos < lineEnd)\n        return lineEnd;\n    return Math.max(view.state.doc.length, pos + 1);\n});\n/// Delete all whitespace directly before a line end from the\n/// document.\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\n    let changes = [];\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1)\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\n            if (iter.done)\n                break;\n            prev = \"\";\n        }\n        else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes }));\n    return true;\n};\n/// Replace each selection range with a line break, leaving the cursor\n/// on the line before the break.\nconst splitLine = ({ state, dispatch }) => {\n    let changes = state.changeByRange(range => {\n        return { changes: { from: range.from, to: range.to, insert: Text.of([\"\", \"\"]) },\n            range: EditorSelection.cursor(range.from) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true, annotations: Transaction.userEvent.of(\"input\") }));\n    return true;\n};\n/// Flip the characters before and after the cursor(s).\nconst transposeChars = ({ state, dispatch }) => {\n    let changes = state.changeByRange(range => {\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\n            return { range };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : line.findClusterBreak(pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : line.findClusterBreak(pos - line.from, true) + line.from;\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\n            range: EditorSelection.cursor(to) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges) {\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (upto == startLine.number)\n            blocks[blocks.length - 1].to = endLine.to;\n        else\n            blocks.push({ from: startLine.from, to: endLine.to });\n        upto = endLine.number;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward ? block.to == state.doc.length : block.from == 0)\n            continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        if (forward)\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.slice() + state.lineBreak });\n        else\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.slice() });\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes, scrollIntoView: true }));\n    return true;\n}\n/// Move the selected lines up one line.\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\n/// Move the selected lines down one line.\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward)\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\n        else\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\n    }\n    dispatch(state.update({ changes, scrollIntoView: true }));\n    return true;\n}\n/// Create a copy of the selected lines. Keep the selection in the top copy.\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\n/// Create a copy of the selected lines. Keep the selection in the bottom copy.\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\n/// Delete selected lines.\nconst deleteLine = view => {\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\n        if (from > 0)\n            from--;\n        else if (to < state.doc.length)\n            to++;\n        return { from, to };\n    }));\n    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n    view.dispatch({ changes, selection, scrollIntoView: true });\n    return true;\n};\n/// Replace the selection with a newline.\nconst insertNewline = ({ state, dispatch }) => {\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\n        return { from: pos, to: pos };\n    let context = syntaxTree(state).resolve(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos &&\n        (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1)\n        return { from: before.to, to: after.from };\n    return null;\n}\n/// Replace the selection with a newline and indent the newly created\n/// line(s). If the current line consists only of whitespace, this\n/// will also delete that whitespace. When the cursor is between\n/// matching brackets, an additional newline will be inserted after\n/// the cursor.\nconst insertNewlineAndIndent = ({ state, dispatch }) => {\n    let changes = state.changeByRange(({ from, to }) => {\n        let explode = from == to && isBetweenBrackets(state, from);\n        let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\n        let indent = getIndentation(cx, from);\n        if (indent == null)\n            indent = /^\\s*/.exec(state.doc.lineAt(from).slice(0, 50))[0].length;\n        let line = state.doc.lineAt(from);\n        while (to < line.to && /\\s/.test(line.slice(to - line.from, to + 1 - line.from)))\n            to++;\n        if (explode)\n            ({ from, to } = explode);\n        else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.slice(0, from)))\n            from = line.from;\n        let insert = [\"\", indentString(state, indent)];\n        if (explode)\n            insert.push(indentString(state, cx.lineIndent(line)));\n        return { changes: { from, to, insert: Text.of(insert) },\n            range: EditorSelection.cursor(from + 1 + indent) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true }));\n    return true;\n};\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange(range => {\n        let changes = [];\n        for (let line = state.doc.lineAt(range.from);;) {\n            if (line.number > atLine) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            if (range.to <= line.to)\n                break;\n            line = state.doc.lineAt(line.to + 1);\n        }\n        let changeSet = state.changes(changes);\n        return { changes,\n            range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\n    });\n}\n/// Auto-indent the selected lines. This uses the [indentation service\n/// facet](#language.indentService) as source for auto-indent\n/// information.\nconst indentSelection = ({ state, dispatch }) => {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, { overrideIndentation: start => {\n            let found = updated[start];\n            return found == null ? -1 : found;\n        } });\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\n        let indent = getIndentation(context, line.from);\n        if (indent == null)\n            return;\n        let cur = /^\\s*/.exec(line.slice(0, Math.min(line.length, 200)))[0];\n        let norm = indentString(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    });\n    if (!changes.changes.empty)\n        dispatch(state.update(changes));\n    return true;\n};\n/// Add a [unit](#language.indentUnit) of indentation to all selected\n/// lines.\nconst indentMore = ({ state, dispatch }) => {\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        changes.push({ from: line.from, insert: state.facet(indentUnit) });\n    })));\n    return true;\n};\n/// Remove a [unit](#language.indentUnit) of indentation from all\n/// selected lines.\nconst indentLess = ({ state, dispatch }) => {\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        let lineStart = line.slice(0, Math.min(line.length, 200));\n        let space = /^\\s*/.exec(lineStart)[0];\n        if (!space)\n            return;\n        let col = countColumn(space, 0, state.tabSize), keep = 0;\n        let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\n            keep++;\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\n    })));\n    return true;\n};\n/// Array of key bindings containing the Emacs-style bindings that are\n/// available on macOS by default.\n///\n///  - Ctrl-b: [`cursorCharLeft`](#commands.cursorCharLeft) ([`selectCharLeft`](#commands.selectCharLeft) with Shift)\n///  - Ctrl-f: [`cursorCharRight`](#commands.cursorCharRight) ([`selectCharRight`](#commands.selectCharRight) with Shift)\n///  - Ctrl-p: [`cursorLineUp`](#commands.cursorLineUp) ([`selectLineUp`](#commands.selectLineUp) with Shift)\n///  - Ctrl-n: [`cursorLineDown`](#commands.cursorLineDown) ([`selectLineDown`](#commands.selectLineDown) with Shift)\n///  - Ctrl-a: [`cursorLineStart`](#commands.cursorLineStart) ([`selectLineStart`](#commands.selectLineStart) with Shift)\n///  - Ctrl-e: [`cursorLineEnd`](#commands.cursorLineEnd) ([`selectLineEnd`](#commands.selectLineEnd) with Shift)\n///  - Ctrl-d: [`deleteCharForward`](#commands.deleteCharForward)\n///  - Ctrl-h: [`deleteCharBackward`](#commands.deleteCharBackward)\n///  - Ctrl-k: [`deleteToLineEnd`](#commands.deleteToLineEnd)\n///  - Alt-d: [`deleteGroupForward`](#commands.deleteGroupForward)\n///  - Ctrl-Alt-h: [`deleteGroupBackward`](#commands.deleteGroupBackward)\n///  - Ctrl-o: [`splitLine`](#commands.splitLine)\n///  - Ctrl-t: [`transposeChars`](#commands.transposeChars)\n///  - Alt-f: [`cursorGroupForward`](#commands.cursorGroupForward) ([`selectGroupForward`](#commands.selectGroupForward) with Shift)\n///  - Alt-b: [`cursorGroupBackward`](#commands.cursorGroupBackward) ([`selectGroupBackward`](#commands.selectGroupBackward) with Shift)\n///  - Alt-<: [`cursorDocStart`](#commands.cursorDocStart)\n///  - Alt->: [`cursorDocEnd`](#commands.cursorDocEnd)\n///  - Ctrl-v: [`cursorPageDown`](#commands.cursorPageDown)\n///  - Alt-v: [`cursorPageUp`](#commands.cursorPageUp)\nconst emacsStyleKeymap = [\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft },\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"Ctrl-d\", run: deleteCharForward },\n    { key: \"Ctrl-h\", run: deleteCharBackward },\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\n    { key: \"Alt-d\", run: deleteGroupForward },\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\n    { key: \"Ctrl-o\", run: splitLine },\n    { key: \"Ctrl-t\", run: transposeChars },\n    { key: \"Alt-f\", run: cursorGroupForward, shift: selectGroupForward },\n    { key: \"Alt-b\", run: cursorGroupBackward, shift: selectGroupBackward },\n    { key: \"Alt-<\", run: cursorDocStart },\n    { key: \"Alt->\", run: cursorDocEnd },\n    { key: \"Ctrl-v\", run: cursorPageDown },\n    { key: \"Alt-v\", run: cursorPageUp },\n];\n/// An array of key bindings closely sticking to platform-standard or\n/// widely used bindings. (This includes the bindings from\n/// [`emacsStyleKeymap`](#commands.emacsStyleKeymap), with their `key`\n/// property changed to `mac`.)\n///\n///  - ArrowLeft: [`cursorCharLeft`](#commands.cursorCharLeft) ([`selectCharLeft`](#commands.selectCharLeft) with Shift)\n///  - ArrowRight: [`cursorCharRight`](#commands.cursorCharRight) ([`selectCharRight`](#commands.selectCharRight) with Shift)\n///  - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](#commands.cursorGroupLeft) ([`selectGroupLeft`](#commands.selectGroupLeft) with Shift)\n///  - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](#commands.cursorGroupRight) ([`selectGroupRight`](#commands.selectGroupRight) with Shift)\n///  - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](#commands.cursorLineStart) ([`selectLineStart`](#commands.selectLineStart) with Shift)\n///  - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](#commands.cursorLineEnd) ([`selectLineEnd`](#commands.selectLineEnd) with Shift)\n///  - ArrowUp: [`cursorLineUp`](#commands.cursorLineUp) ([`selectLineUp`](#commands.selectLineUp) with Shift)\n///  - ArrowDown: [`cursorLineDown`](#commands.cursorLineDown) ([`selectLineDown`](#commands.selectLineDown) with Shift)\n///  - Cmd-ArrowUp (on macOS): [`cursorDocStart`](#commands.cursorDocStart) ([`selectDocStart`](#commands.selectDocStart) with Shift)\n///  - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](#commands.cursorDocEnd) ([`selectDocEnd`](#commands.selectDocEnd) with Shift)\n///  - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](#commands.cursorPageUp) ([`selectPageUp`](#commands.selectPageUp) with Shift)\n///  - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](#commands.cursorPageDown) ([`selectPageDown`](#commands.selectPageDown) with Shift)\n///  - PageUp: [`cursorPageUp`](#commands.cursorPageUp) ([`selectPageUp`](#commands.selectPageUp) with Shift)\n///  - PageDown: [`cursorPageDown`](#commands.cursorPageDown) ([`selectPageDown`](#commands.selectPageDown) with Shift)\n///  - Home: [`cursorLineBoundaryBackward`](#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](#commands.selectLineBoundaryBackward) with Shift)\n///  - End: [`cursorLineBoundaryForward`](#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](#commands.selectLineBoundaryForward) with Shift)\n///  - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](#commands.cursorDocStart) ([`selectDocStart`](#commands.selectDocStart) with Shift)\n///  - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](#commands.cursorDocEnd) ([`selectDocEnd`](#commands.selectDocEnd) with Shift)\n///  - Enter: [`insertNewlineAndIndent`](#commands.insertNewlineAndIndent)\n///  - Ctrl-a (Cmd-a on macOS): [`selectAll`](#commands.selectAll)\n///  - Backspace: [`deleteCodePointBackward`](#commands.deleteCodePointBackward)\n///  - Delete: [`deleteCharForward`](#commands.deleteCharForward)\n///  - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](#commands.deleteGroupBackward)\n///  - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](#commands.deleteGroupForward)\nconst standardKeymap = [\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft },\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft },\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight },\n    { mac: \"Cmd-ArrowRight\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp },\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown },\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\n    { key: \"Enter\", run: insertNewlineAndIndent },\n    { key: \"Mod-a\", run: selectAll },\n    { key: \"Backspace\", run: deleteCodePointBackward },\n    { key: \"Delete\", run: deleteCharForward },\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\n].concat(emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\n/// The default keymap. Includes all bindings from\n/// [`standardKeymap`](#commands.standardKeymap) plus the following:\n///\n/// - Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](#commands.selectSyntaxLeft) with Shift)\n/// - Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](#commands.cursorSyntaxRight) ([`selectSyntaxRight`](#commands.selectSyntaxRight) with Shift)\n/// - Alt-ArrowUp: [`moveLineUp`](#commands.moveLineUp)\n/// - Alt-ArrowDown: [`moveLineDown`](#commands.moveLineDown)\n/// - Shift-Alt-ArrowUp: [`copyLineUp`](#commands.copyLineUp)\n/// - Shift-Alt-ArrowDown: [`copyLineDown`](#commands.copyLineDown)\n/// - Escape: [`simplifySelection`](#commands.simplifySelection)\n/// - Ctrl-l (Cmd-l on macOS): [`selectLine`](#commands.selectLine)\n/// - Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](#commands.selectParentSyntax)\n/// - Ctrl-[ (Cmd-[ on macOS): [`indentLess`](#commands.indentLess)\n/// - Ctrl-] (Cmd-] on macOS): [`indentMore`](#commands.indentMore)\n/// - Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](#commands.indentSelection)\n/// - Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](#commands.deleteLine)\n/// - Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](#commands.cursorMatchingBracket)\nconst defaultKeymap = [\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\n    { key: \"Escape\", run: simplifySelection },\n    { key: \"Mod-l\", run: selectLine },\n    { key: \"Mod-i\", run: selectParentSyntax },\n    { key: \"Mod-[\", run: indentLess },\n    { key: \"Mod-]\", run: indentMore },\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\n    { key: \"Shift-Mod-k\", run: deleteLine },\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket }\n].concat(standardKeymap);\n\nexport { copyLineDown, copyLineUp, cursorCharBackward, cursorCharForward, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharForward, deleteCodePointBackward, deleteCodePointForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteToLineEnd, deleteTrailingWhitespace, emacsStyleKeymap, indentLess, indentMore, indentSelection, insertNewline, insertNewlineAndIndent, moveLineDown, moveLineUp, selectAll, selectCharBackward, selectCharForward, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, transposeChars };\n","import { EditorSelection } from '@codemirror/next/state';\n\n/// Comments or uncomments the current `SelectionRange` using line-comments.\n/// The line-comment token is defined on a language basis.\nconst toggleLineComment = target => {\n    return dispatch(toggleLineCommentWithOption(CommentOption.Toggle), target);\n};\n/// Comments the current `SelectionRange` using line-comments.\n/// The line-comment token is defined on a language basis.\nconst lineComment = target => {\n    return dispatch(toggleLineCommentWithOption(CommentOption.OnlyComment), target);\n};\n/// Uncomments the current `SelectionRange` using line-comments.\n/// The line-comment token is defined on a language basis.\nconst lineUncomment = target => {\n    return dispatch(toggleLineCommentWithOption(CommentOption.OnlyUncomment), target);\n};\n/// Comments or uncomments the current `SelectionRange` using block-comments.\n/// The block-comment tokens are defined on a language basis.\nconst toggleBlockComment = target => {\n    return dispatch(toggleBlockCommentWithOption(CommentOption.Toggle), target);\n};\n/// Comments the current `SelectionRange` using block-comments.\n/// The block-comment tokens are defined on a language basis.\nconst blockComment = target => {\n    return dispatch(toggleBlockCommentWithOption(CommentOption.OnlyComment), target);\n};\n/// Uncomments the current `SelectionRange` using block-comments.\n/// The block-comment tokens are defined on a language basis.\nconst blockUncomment = target => {\n    return dispatch(toggleBlockCommentWithOption(CommentOption.OnlyUncomment), target);\n};\n/// Default key bindings for this package.\n///\n///  - Ctrl-/ (Cmd-/ on macOS): [\\`toggleLineComment\\`](#comment.toggleLineComment).\n///  - Shift-Alt-a: [\\`toggleBlockComment\\`](#comment.toggleBlockComment).\nconst commentKeymap = [\n    { key: \"Mod-/\", run: toggleLineComment },\n    { key: \"Alt-A\", run: toggleBlockComment }\n];\nfunction dispatch(cmd, target) {\n    const tr = cmd(target.state);\n    if (!tr)\n        return false;\n    target.dispatch(tr);\n    return true;\n}\nvar CommentOption;\n(function (CommentOption) {\n    CommentOption[CommentOption[\"Toggle\"] = 0] = \"Toggle\";\n    CommentOption[CommentOption[\"OnlyComment\"] = 1] = \"OnlyComment\";\n    CommentOption[CommentOption[\"OnlyUncomment\"] = 2] = \"OnlyUncomment\";\n})(CommentOption || (CommentOption = {}));\nfunction getConfig(state, pos = state.selection.primary.head) {\n    return state.languageDataAt(\"commentTokens\", pos)[0] || {};\n}\nconst toggleBlockCommentWithOption = (option) => (state) => {\n    const config = getConfig(state);\n    return config.block ? new BlockCommenter(config.block.open, config.block.close).toggle(option, state) : null;\n};\nconst toggleLineCommentWithOption = (option) => (state) => {\n    const config = getConfig(state);\n    return config.line ? new LineCommenter(config.line).toggle(option, state) : null;\n};\n// This class performs toggle, comment and uncomment\n// of block comments in languages that support them.\n// The `open` and `close` arguments refer to the open and close\n// tokens of which this `BlockCommenter` is made up.\nclass BlockCommenter {\n    constructor(open, close, margin = \" \") {\n        this.open = open;\n        this.close = close;\n        this.margin = margin;\n    }\n    toggle(option, state) {\n        const selectionCommented = this.isSelectionCommented(state);\n        if (selectionCommented !== null) {\n            if (option !== CommentOption.OnlyComment) {\n                return state.update({\n                    changes: selectionCommented.map(({ open, close }) => [\n                        { from: open.pos - this.open.length, to: open.pos + open.margin },\n                        { from: close.pos - close.margin, to: close.pos + this.close.length }\n                    ])\n                });\n            }\n        }\n        else {\n            if (option !== CommentOption.OnlyUncomment) {\n                return state.update(state.changeByRange(range => {\n                    const shift = (this.open + this.margin).length;\n                    return {\n                        changes: [{ from: range.from, insert: this.open + this.margin },\n                            { from: range.to, insert: this.margin + this.close }],\n                        range: EditorSelection.range(range.anchor + shift, range.head + shift)\n                    };\n                }));\n            }\n        }\n        return null;\n    }\n    /// Determines whether all selection ranges in `state` are block-commented.\n    isSelectionCommented(state) {\n        let result = [];\n        for (const range of state.selection.ranges) {\n            const x = this.isRangeCommented(state, range);\n            if (x === null)\n                return null;\n            result.push(x);\n        }\n        return result;\n    }\n    /// Determines if the `range` is block-commented in the given `state`.\n    /// The `range` must be a valid range in `state`.\n    isRangeCommented(state, range) {\n        let textBefore = state.sliceDoc(range.from - SearchMargin, range.from);\n        let textAfter = state.sliceDoc(range.to, range.to + SearchMargin);\n        let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n        let beforeOff = textBefore.length - spaceBefore;\n        if (textBefore.slice(beforeOff - this.open.length, beforeOff) == this.open &&\n            textAfter.slice(spaceAfter, spaceAfter + this.close.length) == this.close) {\n            return { open: { pos: range.from - spaceBefore, margin: spaceBefore && 1 },\n                close: { pos: range.to + spaceAfter, margin: spaceAfter && 1 } };\n        }\n        let startText, endText;\n        if (range.to - range.from <= 2 * SearchMargin) {\n            startText = endText = state.sliceDoc(range.from, range.to);\n        }\n        else {\n            startText = state.sliceDoc(range.from, range.from + SearchMargin);\n            endText = state.sliceDoc(range.to - SearchMargin, range.to);\n        }\n        let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n        let endOff = endText.length - endSpace - this.close.length;\n        if (startText.slice(startSpace, startSpace + this.open.length) == this.open &&\n            endText.slice(endOff, endOff + this.close.length) == this.close) {\n            return { open: { pos: range.from + startSpace + this.open.length,\n                    margin: /\\s/.test(startText.charAt(startSpace + this.open.length)) ? 1 : 0 },\n                close: { pos: range.to - endSpace - this.close.length,\n                    margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n        }\n        return null;\n    }\n}\nconst SearchMargin = 50;\n// This class performs toggle, comment and uncomment\n// of line comments in languages that support them.\n// The `lineCommentToken` argument refer to the token of\n// which this `LineCommenter` is made up.\nclass LineCommenter {\n    constructor(lineCommentToken, margin = \" \") {\n        this.lineCommentToken = lineCommentToken;\n        this.margin = margin;\n    }\n    toggle(option, state) {\n        const linesAcrossSelection = [];\n        const linesAcrossRange = {};\n        for (let i = 0; i < state.selection.ranges.length; i++) {\n            const lines = getLinesInRange(state.doc, state.selection.ranges[i]);\n            linesAcrossSelection.push(...lines);\n            linesAcrossRange[i] = lines;\n        }\n        const column = this.isRangeCommented(state, linesAcrossSelection);\n        if (column.isRangeLineSkipped) {\n            if (option != CommentOption.OnlyComment) {\n                let changes = [];\n                for (let i = 0; i < state.selection.ranges.length; i++) {\n                    const lines = linesAcrossRange[i];\n                    for (const line of lines) {\n                        if (lines.length > 1 && column.isLineSkipped[line.number])\n                            continue;\n                        const pos = line.from + column.minCol;\n                        const posAfter = column.minCol + this.lineCommentToken.length;\n                        const marginLen = line.slice(posAfter, posAfter + 1) == \" \" ? 1 : 0;\n                        changes.push({ from: pos, to: pos + this.lineCommentToken.length + marginLen });\n                    }\n                }\n                return state.update({ changes });\n            }\n        }\n        else {\n            if (option != CommentOption.OnlyUncomment) {\n                let changes = [];\n                for (let i = 0; i < state.selection.ranges.length; i++) {\n                    const lines = linesAcrossRange[i];\n                    for (const line of lines) {\n                        if (lines.length <= 1 || !column.isLineSkipped[line.number])\n                            changes.push({ from: line.from + column.minCol, insert: this.lineCommentToken + this.margin });\n                    }\n                }\n                return state.update({ changes });\n            }\n        }\n        return null;\n    }\n    isRangeCommented(_state, lines) {\n        let minCol = Infinity;\n        let isRangeLineDiscarded = true;\n        const isLineSkipped = [];\n        for (const line of lines) {\n            const str = line.slice(0, Math.min(line.length, SearchMargin));\n            const col = /^\\s*/.exec(str)[0].length;\n            if ((lines.length == 1 || col < str.length) && col < minCol) {\n                minCol = col;\n            }\n            if (isRangeLineDiscarded && (lines.length == 1 || col < str.length) &&\n                str.slice(col, col + this.lineCommentToken.length) != this.lineCommentToken) {\n                isRangeLineDiscarded = false;\n            }\n            isLineSkipped[line.number] = col == str.length;\n        }\n        return { minCol: minCol, isRangeLineSkipped: isRangeLineDiscarded, isLineSkipped: isLineSkipped };\n    }\n}\n// Computes the lines spanned by `range`.\n/// @internal\nfunction getLinesInRange(doc, range) {\n    let line = doc.lineAt(range.from);\n    const lines = [];\n    while (line.from + line.length < range.to ||\n        (line.from <= range.to && range.to <= line.to)) {\n        lines.push(line);\n        if (line.number + 1 <= doc.lines) {\n            line = doc.line(line.number + 1);\n        }\n        else {\n            break;\n        }\n    }\n    return lines;\n}\n\nexport { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleLineComment };\n","import { EditorView, ViewPlugin, themeClass, BlockType, PluginField, Direction } from '@codemirror/next/view';\nimport { RangeValue, Range, RangeSet } from '@codemirror/next/rangeset';\nimport { MapMode, Facet, combineConfig } from '@codemirror/next/state';\n\n/// A gutter marker represents a bit of information attached to a line\n/// in a specific gutter. Your own custom markers have to extend this\n/// class.\nclass GutterMarker extends RangeValue {\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /// Render the DOM node for this marker, if any.\n    toDOM(_view) { return null; }\n    /// Create a range that places this marker at the given position.\n    at(pos) { return new Range(pos, pos, this); }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.mapMode = MapMode.TrackBefore;\nconst defaults = {\n    style: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: () => RangeSet.empty,\n    lineMarker: () => null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = Facet.define();\n/// Define an editor gutter.\nfunction gutter(config) {\n    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst baseTheme = EditorView.baseTheme({\n    $gutters: {\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        left: 0\n    },\n    \"$$light $gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#999\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"$$dark $gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    $gutter: {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        overflow: \"hidden\"\n    },\n    $gutterElement: {\n        boxSizing: \"border-box\"\n    },\n    \"$gutterElement.lineNumber\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    }\n});\nconst unfixGutters = Facet.define({\n    combine: values => values.some(x => x)\n});\n/// The gutter-drawing plugin is automatically enabled when you add a\n/// gutter, but you can use this function to explicitly configure it.\n///\n/// Unless `fixed` is explicitly set to `false`, the gutters are\n/// fixed, meaning they don't scroll along with the content\n/// horizontally.\nfunction gutters(config) {\n    let result = [\n        gutterView,\n        baseTheme\n    ];\n    if (config && config.fixed === false)\n        result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutters\");\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)\n            this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (!this.updateGutters(update))\n            return;\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));\n        this.view.viewportLines(line => {\n            let text;\n            if (Array.isArray(line.type)) {\n                for (let b of line.type)\n                    if (b.type == BlockType.Text) {\n                        text = b;\n                        break;\n                    }\n            }\n            else {\n                text = line.type == BlockType.Text ? line : undefined;\n            }\n            if (!text)\n                return;\n            for (let cx of contexts)\n                cx.line(this.view, text);\n        }, 0);\n        for (let cx of contexts)\n            cx.finish();\n        this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (update.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n    }\n    updateGutters(update) {\n        let prev = update.prevState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged;\n        if (prev == cur) {\n            for (let gutter of this.gutters)\n                if (gutter.update(update))\n                    change = true;\n        }\n        else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur) {\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                }\n                else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters)\n                g.dom.remove();\n            for (let g of gutters)\n                this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        this.dom.remove();\n    }\n}, {\n    provide: PluginField.scrollMargins.from(value => {\n        if (value.gutters.length == 0 || !value.fixed)\n            return null;\n        return value.view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };\n    })\n});\nclass UpdateContext {\n    constructor(gutter, viewport) {\n        this.gutter = gutter;\n        this.localMarkers = [];\n        this.i = 0;\n        this.height = 0;\n        this.cursor = RangeSet.iter(Array.isArray(gutter.markers) ? gutter.markers : [gutter.markers], viewport.from);\n    }\n    line(view, line) {\n        if (this.localMarkers.length)\n            this.localMarkers = [];\n        while (this.cursor.value && this.cursor.from <= line.from) {\n            if (this.cursor.from == line.from)\n                this.localMarkers.push(this.cursor.value);\n            this.cursor.next();\n        }\n        let forLine = this.gutter.config.lineMarker(view, line, this.localMarkers);\n        if (forLine)\n            this.localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (this.localMarkers.length == 0 && !gutter.config.renderEmptyElements)\n            return;\n        let above = line.top - this.height;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, line.height, above, this.localMarkers, gutter.elementClass);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        }\n        else {\n            let markers = this.localMarkers, elt = gutter.elements[this.i];\n            if (sameMarkers(markers, elt.markers)) {\n                markers = elt.markers;\n                this.localMarkers.length = 0;\n            }\n            elt.update(view, line.height, above, markers, gutter.elementClass);\n        }\n        this.height = line.bottom;\n        this.i++;\n    }\n    finish() {\n        let gutter = this.gutter;\n        while (gutter.elements.length > this.i)\n            gutter.dom.removeChild(gutter.elements.pop().dom);\n    }\n}\nclass SingleGutterView {\n    constructor(view, config) {\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutter\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        this.elementClass = themeClass(\"gutterElement\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        for (let prop in config.domEventHandlers) {\n            this.dom.addEventListener(prop, (event) => {\n                let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);\n                if (config.domEventHandlers[prop](view, line, event))\n                    event.preventDefault();\n            });\n        }\n        this.markers = config.markers(view.state);\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)], this.elementClass);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = this.config.markers(update.state);\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0])\n                this.spacer.update(update.view, 0, 0, [updated], this.elementClass);\n        }\n        return this.markers != prevMarkers;\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers, eltClass) {\n        this.height = -1;\n        this.above = 0;\n        this.dom = document.createElement(\"div\");\n        this.update(view, height, above, markers, eltClass);\n    }\n    update(view, height, above, markers, cssClass) {\n        if (this.height != height)\n            this.dom.style.height = (this.height = height) + \"px\";\n        if (this.above != above)\n            this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (this.markers != markers) {\n            this.markers = markers;\n            for (let ch; ch = this.dom.lastChild;)\n                ch.remove();\n            let cls = cssClass;\n            for (let m of markers) {\n                let dom = m.toDOM(view);\n                if (dom)\n                    this.dom.appendChild(dom);\n                let c = m.elementClass;\n                if (c)\n                    cls += \" \" + c;\n            }\n            this.dom.className = cls;\n        }\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].compare(b[i]))\n            return false;\n    return true;\n}\n/// Facet used to provide markers to the line number gutter.\nconst lineNumberMarkers = Facet.define();\nconst lineNumberConfig = Facet.define({\n    combine(values) {\n        return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {\n            domEventHandlers(a, b) {\n                let result = Object.assign({}, a);\n                for (let event in b) {\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n    eq(other) { return this.number == other.number; }\n    toDOM(view) {\n        let config = view.state.facet(lineNumberConfig);\n        return document.createTextNode(config.formatNumber(this.number));\n    }\n}\nconst lineNumberGutter = gutter({\n    style: \"lineNumber\",\n    markers(state) { return state.facet(lineNumberMarkers); },\n    lineMarker(view, line, others) {\n        if (others.length)\n            return null;\n        // FIXME try to make the line number queries cheaper?\n        return new NumberMarker(view.state.doc.lineAt(line.from).number);\n    },\n    initialSpacer(view) {\n        return new NumberMarker(maxLineNumber(view.state.doc.lines));\n    },\n    updateSpacer(spacer, update) {\n        let max = maxLineNumber(update.view.state.doc.lines);\n        return max == spacer.number ? spacer : new NumberMarker(max);\n    }\n});\n/// Create a line number gutter extension. The order in which the\n/// gutters appear is determined by their extension priority.\nfunction lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while (last < lines)\n        last = last * 10 + 9;\n    return last;\n}\n\nexport { GutterMarker, gutter, gutters, lineNumberMarkers, lineNumbers };\n","import { Decoration, themeClass, ViewPlugin, EditorView } from '@codemirror/next/view';\nimport { Facet, combineConfig, CharCategory } from '@codemirror/next/state';\nimport { SearchCursor } from '@codemirror/next/search';\n\n/// Mark lines that have a cursor on them with the \\`$activeLine\\`\n/// theme class.\nfunction highlightActiveLine() {\n    return [defaultTheme, activeLineHighlighter];\n}\nconst lineDeco = Decoration.line({ attributes: { class: themeClass(\"activeLine\") } });\nconst activeLineHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges) {\n            if (!r.empty)\n                continue;\n            let line = view.visualLineAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100\n};\nconst highlightConfig = Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/// This extension highlights text that matches the selection. It uses\n/// the `$selectionMatch` theme class for the highlighting. When\n/// `highlightWordAroundCursor` is enabled, the word at the cursor\n/// itself will be highlighted with `selectionMatch.main`.\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nfunction wordAt(doc, pos, check) {\n    let line = doc.lineAt(pos);\n    let from = pos - line.from, to = pos - line.from;\n    while (from > 0) {\n        let prev = line.findClusterBreak(from, false);\n        if (check(line.slice(prev, from)) != CharCategory.Word)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = line.findClusterBreak(to, true);\n        if (check(line.slice(to, next)) != CharCategory.Word)\n            break;\n        to = next;\n    }\n    return from == to ? null : line.slice(from, to);\n}\nconst matchDeco = Decoration.mark({ class: themeClass(\"selectionMatch\") });\nconst mainMatchDeco = Decoration.mark({ class: themeClass(\"selectionMatch.main\") });\nconst matchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.primary, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = wordAt(state.doc, range.head, check);\n            if (!query)\n                return Decoration.none;\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            query = state.sliceDoc(range.from, range.to).trim();\n            if (!query)\n                return Decoration.none;\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || ((from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n                    (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word))) {\n                    if (check && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = EditorView.baseTheme({\n    \"$$light $activeLine\": { backgroundColor: \"#f3f9ff\" },\n    \"$$dark $activeLine\": { backgroundColor: \"#223039\" },\n    \"$selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \"$searchMatch $selectionMatch\": { backgroundColor: \"transparent\" }\n});\n\nexport { highlightActiveLine, highlightSelectionMatches };\n","import { NodeProp } from 'lezer-tree';\nimport { StyleModule } from 'style-mod';\nimport { EditorView, ViewPlugin, Decoration } from '@codemirror/next/view';\nimport { Facet, precedence } from '@codemirror/next/state';\nimport { RangeSetBuilder } from '@codemirror/next/rangeset';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlight style](#highlight.highlightStyle).\n///\n/// CodeMirror uses a mostly-closed set of tags for generic\n/// highlighters, so that the list of things that a theme must style\n/// is clear and bounded (as opposed to traditional open string-based\n/// systems, which make it hard for highlighting themes to cover all\n/// the tokens produced by the various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by other highlighters (though you can derive them\n/// from standard tags to allow the highlighters to fall back to\n/// those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of tags that match this tag, starting with this one\n    /// itself, sorted in order of decreasing specificity. @internal\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and [highlight\n    /// styles](#highlight.highlightStyle) that don't mention this tag\n    /// will try to fall back to the parent tag (or grandparent tag,\n    /// etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = permute(mods);\n        for (let parent of base.set)\n            for (let config of configs)\n                set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n    let result = [array];\n    for (let i = 0; i < array.length; i++) {\n        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))\n            result.push(a);\n    }\n    return result;\n}\n/// This function is used to add a set of tags to a language syntax\n/// via\n/// [`Parser.configure`](https://lezer.codemirror.net/docs/ref#lezer.Parser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node\n/// name](https://lezer.codemirror.net/docs/ref#tree.NodeType.name),\n/// or multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single level—wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all parent nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": tags.string + tags.invalid,\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nconst highlightStyleProp = Facet.define({\n    combine(stylings) { return stylings.length ? stylings[0] : null; }\n});\n/// Create a highlighter style that associates the given styles to the\n/// given tags. The spec's property names must be\n/// [tags](#highlight.Tag) or lists of tags (which can be concatenated\n/// with `+`). The values should be\n/// [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n/// style objects that define the CSS for that tag.\n///\n/// The CSS rules created for a highlighter will be emitted in the\n/// order of the spec's properties. That means that for elements that\n/// have multiple tags associated with them, styles defined further\n/// down in the list will have a higher CSS precedence than styles\n/// defined earlier.\nfunction highlightStyle(...specs) {\n    let styling = new Styling(specs);\n    return [\n        highlightStyleProp.of(styling),\n        EditorView.styleModule.of(styling.module)\n    ];\n}\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nclass Styling {\n    constructor(spec) {\n        this.map = Object.create(null);\n        let modSpec = Object.create(null);\n        for (let style of spec) {\n            let cls = StyleModule.newName();\n            modSpec[\".\" + cls] = Object.assign({}, style, { tag: null });\n            let tags = style.tag;\n            if (!Array.isArray(tags))\n                tags = [tags];\n            for (let tag of tags)\n                this.map[tag.id] = cls;\n        }\n        this.module = new StyleModule(modSpec);\n    }\n    match(tag) {\n        for (let t of tag.set) {\n            let match = this.map[t.id];\n            if (match) {\n                if (t != tag)\n                    this.map[tag.id] = match;\n                return match;\n            }\n        }\n        return this.map[tag.id] = null;\n    }\n}\n/// Returns an extension that installs a highlighter that uses the\n/// tree produced by the given language, along with the current\n/// [highlight style](#highlight.highlightStyle), to style the\n/// document. If no highlight style is active, this plugin won't do\n/// any highlighting.\nfunction treeHighlighter(language) {\n    return precedence(ViewPlugin.define(view => new TreeHighlighter(view, language), {\n        decorations: v => v.decorations\n    }), \"fallback\");\n}\nclass TreeHighlighter {\n    constructor(view, language) {\n        this.language = language;\n        // Reused stacks for buildDeco\n        this.nodeStack = [\"\"];\n        this.classStack = [\"\"];\n        this.inheritStack = [\"\"];\n        this.markCache = Object.create(null);\n        this.tree = language.getTree(view.state);\n        this.decorations = this.buildDeco(view);\n    }\n    update(update) {\n        if (this.language.getTree(update.state).length < update.view.viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n        }\n        else {\n            let tree = this.language.getTree(update.state);\n            if (tree != this.tree || update.viewportChanged) {\n                this.tree = tree;\n                this.decorations = this.buildDeco(update.view);\n            }\n        }\n    }\n    buildDeco(view) {\n        const style = view.state.facet(highlightStyleProp);\n        if (!style)\n            return Decoration.none;\n        let builder = new RangeSetBuilder();\n        let start, curClass, depth;\n        let flush = (pos, style) => {\n            if (pos > start && style) {\n                let mark = this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style }));\n                builder.add(start, pos, mark);\n            }\n            start = pos;\n        };\n        let { nodeStack, classStack, inheritStack } = this;\n        for (let { from, to } of view.visibleRanges) {\n            curClass = \"\";\n            depth = 0;\n            start = from;\n            this.tree.iterate({\n                from, to,\n                enter: (type, start) => {\n                    depth++;\n                    let inheritedClass = inheritStack[depth - 1];\n                    let cls = inheritedClass;\n                    let rule = type.prop(ruleNodeProp), opaque = false;\n                    while (rule) {\n                        if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n                            for (let tag of rule.tags) {\n                                let st = style.match(tag);\n                                if (st) {\n                                    if (cls)\n                                        cls += \" \";\n                                    cls += st;\n                                    if (rule.mode == 1 /* Inherit */)\n                                        inheritedClass = cls;\n                                    else if (rule.mode == 0 /* Opaque */)\n                                        opaque = true;\n                                }\n                            }\n                            break;\n                        }\n                        rule = rule.next;\n                    }\n                    if (cls != curClass) {\n                        flush(start, curClass);\n                        curClass = cls;\n                    }\n                    if (opaque) {\n                        depth--;\n                        return false;\n                    }\n                    classStack[depth] = cls;\n                    inheritStack[depth] = inheritedClass;\n                    nodeStack[depth] = type.name;\n                    return undefined;\n                },\n                leave: (_t, _s, end) => {\n                    depth--;\n                    let backTo = classStack[depth];\n                    if (backTo != curClass) {\n                        flush(Math.min(to, end), curClass);\n                        curClass = backTo;\n                    }\n                }\n            });\n        }\n        return builder.finish();\n    }\n}\nfunction matchContext(context, stack, depth) {\n    if (context.length > depth - 1)\n        return false;\n    for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {\n        let check = context[i];\n        if (check && check != stack[d])\n            return false;\n    }\n    return true;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag^define) used\n/// by regular language packages and themes.\n///\n/// This collection is heavily biasted towards programming language,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set, possibly\n/// encoding more information with flags. If all else fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new type, or [define](#highlight.Tag^define) a custom tag for your\n/// use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an element—if your grammar can't easily\n/// distinguish a certain type of element, it is okay to style it as\n/// its more general variant.\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type or tag [name](#highlight.tags.name).\n    typeName: t(name),\n    /// A property, field, or attribute [name](#highlight.tags.name).\n    propertyName: t(name),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that defines something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket)).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket)).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// [Content](#highlight.tags.content) that represents a list or\n    /// list marker.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// Inserted content in a change-tracking format.\n    inserted: t(),\n    /// Deleted content.\n    deleted: t(),\n    /// Changed content.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta)).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that a\n    /// [variable name](#highlight.tags.variableName) is being called or\n    /// being defined as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// A default highlight style (works well with light themes).\nconst defaultHighlightStyle = precedence(highlightStyle({ tag: tags.deleted,\n    textDecoration: \"line-through\" }, { tag: [tags.inserted, tags.link],\n    textDecoration: \"underline\" }, { tag: tags.heading,\n    textDecoration: \"underline\",\n    fontWeight: \"bold\" }, { tag: tags.emphasis,\n    fontStyle: \"italic\" }, { tag: tags.strong,\n    fontWeight: \"bold\" }, { tag: tags.keyword,\n    color: \"#708\" }, { tag: [tags.atom, tags.bool, tags.url],\n    color: \"#219\" }, { tag: tags.number,\n    color: \"#164\" }, { tag: tags.string,\n    color: \"#a11\" }, { tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n    color: \"#e40\" }, { tag: tags.definition(tags.variableName),\n    color: \"#00f\" }, { tag: tags.typeName,\n    color: \"#085\" }, { tag: tags.className,\n    color: \"#167\" }, { tag: tags.special(tags.variableName),\n    color: \"#256\" }, { tag: tags.definition(tags.propertyName),\n    color: \"#00c\" }, { tag: tags.comment,\n    color: \"#940\" }, { tag: tags.meta,\n    color: \"#555\" }, { tag: tags.invalid,\n    color: \"#f00\" }), \"fallback\");\n\nexport { Tag, defaultHighlightStyle, highlightStyle, styleTags, tags, treeHighlighter };\n","import { NodeProp, Tree, TreeFragment } from 'lezer-tree';\nimport { Facet, EditorState, StateEffect, StateField, Transaction } from '@codemirror/next/state';\nimport { ViewPlugin } from '@codemirror/next/view';\nimport { treeHighlighter } from '@codemirror/next/highlight';\nimport { countColumn } from '@codemirror/next/text';\n\n/// The facet used to associate a language with an editor state.\nconst language = Facet.define();\n/// Node prop stored on a grammar's top node to indicate the facet used\n/// to store language data related to that language.\nconst languageDataProp = new NodeProp();\n/// Helper function to define a facet (to be added to the top syntax\n/// node(s) for a language via\n/// [`languageDataProp`](#language.languageDataProp)), that will be\n/// used to associate language data with the language. You\n/// probably only need this when subclassing\n/// [`Language`](#language.Language).\nfunction defineLanguageFacet(baseData) {\n    return Facet.define({\n        combine: baseData ? values => values.concat(baseData) : undefined\n    });\n}\n/// A language object manages parsing and per-language\n/// [metadata](#state.EditorState.languageDataAt). Parse data is\n/// managed as a [Lezer](https://lezer.codemirror.net) tree. You'll\n/// want to subclass this class for custom parsers, or use the\n/// [`LezerLanguage`](#language.LezerLanguage) or\n/// [`StreamLanguage`](#stream-parser.StreamLanguage) abstractions for\n/// [Lezer](https://lezer.codemirror.net/) or stream parsers.\nclass Language {\n    constructor(\n    /// The [language data](#state.EditorState.languageDataAt) data\n    /// facet used for this language.\n    data, parser, extraExtensions = []) {\n        this.data = data;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!EditorState.prototype.hasOwnProperty(\"tree\"))\n            Object.defineProperty(EditorState.prototype, \"tree\", { get() { return syntaxTree(this); } });\n        let setState = StateEffect.define();\n        this.parser = parser;\n        this.field = StateField.define({\n            create(state) {\n                let parseState = new EditorParseContext(parser, state, [], Tree.empty, { from: 0, to: state.doc.length }, []);\n                if (!parseState.work(25 /* Apply */))\n                    parseState.takeTree();\n                return new LanguageState(parseState);\n            },\n            update(value, tr) {\n                for (let e of tr.effects)\n                    if (e.is(setState))\n                        return e.value;\n                return value.apply(tr);\n            }\n        });\n        this.extension = [\n            language.of(this),\n            this.field,\n            ViewPlugin.define(view => new ParseWorker(view, this.field, setState)),\n            treeHighlighter(this),\n            EditorState.languageData.of((state, pos) => state.facet(this.languageDataFacetAt(state, pos)))\n        ].concat(extraExtensions);\n    }\n    /// Retrieve the parser tree for a given state.\n    getTree(state) {\n        return state.field(this.field).tree;\n    }\n    /// Try to get a parse tree that spans at least up to `upto`. The\n    /// method will do at most `timeout` milliseconds of work to parse\n    /// up to that point if the tree isn't already available.\n    ensureTree(state, upto, timeout = 100) {\n        let parse = state.field(this.field).context;\n        return parse.tree.length >= upto || parse.work(timeout, upto) ? parse.tree : null;\n    }\n    /// @internal\n    languageDataFacetAt(state, pos) {\n        let tree = this.getTree(state);\n        let target = tree.resolve(pos, -1);\n        while (target) {\n            let facet = target.type.prop(languageDataProp);\n            if (facet)\n                return facet;\n            target = target.parent;\n        }\n        return this.data;\n    }\n}\n/// A subclass of `Language` for use with\n/// [Lezer](https://lezer.codemirror.net/docs/ref#lezer.Parser)\n/// parsers.\nclass LezerLanguage extends Language {\n    constructor(data, parser) {\n        super(data, parser);\n        this.parser = parser;\n    }\n    /// Define a language from a parser.\n    static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LezerLanguage(data, spec.parser.configure({\n            props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n        }));\n    }\n    /// Create a new instance of this language with a reconfigured\n    /// version of its parser.\n    configure(options) {\n        return new LezerLanguage(this.data, this.parser.configure(options));\n    }\n    languageDataFacetAt(state, pos) {\n        return this.parser.hasNested ? super.languageDataFacetAt(state, pos) : this.data;\n    }\n}\n/// Get the syntax tree for a state, which is the current (possibly\n/// incomplete) parse tree of the [language](#language.Language) with\n/// the highest precedence, or the empty tree if there is no language\n/// available.\nfunction syntaxTree(state) {\n    let lang = state.facet(language);\n    return lang.length ? lang[0].getTree(state) : Tree.empty;\n}\n// Lezer-style Input object for a Text document.\nclass DocInput {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.prevString = \"\";\n        this.cursor = doc.iter();\n    }\n    syncTo(pos) {\n        if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n            this.cursor = this.doc.iter();\n            this.cursorPos = 0;\n        }\n        this.prevString = pos == this.cursorPos ? this.string : \"\";\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    get(pos) {\n        if (pos >= this.length)\n            return -1;\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos) {\n            if (pos < stringStart && pos >= stringStart - this.prevString.length)\n                return this.prevString.charCodeAt(pos - (stringStart - this.prevString.length));\n            stringStart = this.syncTo(pos);\n        }\n        return this.string.charCodeAt(pos - stringStart);\n    }\n    lineAfter(pos) {\n        if (pos >= this.length || pos < 0)\n            return \"\";\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos)\n            stringStart = this.syncTo(pos);\n        let off = pos - stringStart, result = \"\";\n        while (!this.cursor.lineBreak) {\n            result += off ? this.string.slice(off) : this.string;\n            if (this.cursorPos >= this.length) {\n                if (this.cursorPos > this.length)\n                    result = result.slice(0, result.length - (this.cursorPos - this.length));\n                break;\n            }\n            this.syncTo(this.cursorPos);\n            off = 0;\n        }\n        return result;\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.sliceString(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n    clip(at) {\n        return new DocInput(this.doc, at);\n    }\n}\n/// A parse context provided to parsers working on the editor content.\nclass EditorParseContext {\n    /// @internal\n    constructor(parser, \n    /// The current editor state.\n    state, \n    /// Tree fragments that can be reused by new parses.\n    fragments = [], \n    /// @internal\n    tree, \n    /// The current editor viewport, or some approximation thereof.\n    /// Intended to be used for opportunistically avoiding work (in\n    /// which case\n    /// [`skipUntilInView`](#language.EditorParseContext.skipUntilInView)\n    /// should be called to make sure the parser is restarted when the\n    /// skipped region becomes visible).\n    viewport, \n    /// @internal\n    skipped) {\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.parse = null;\n        /// @internal\n        this.skippedUntil = [];\n    }\n    /// @internal\n    // FIXME do something with badness again\n    work(time, upto) {\n        if (this.tree != Tree.empty && (upto == null ? this.tree.length == this.state.doc.length : this.tree.length >= upto))\n            return true;\n        if (!this.parse)\n            this.parse = this.parser.startParse(new DocInput(this.state.doc), 0, this);\n        let endTime = Date.now() + time;\n        for (;;) {\n            let done = this.parse.advance();\n            if (done) {\n                this.fragments = TreeFragment.addTree(done);\n                this.parse = null;\n                this.tree = done;\n                return true;\n            }\n            else if (upto != null && this.parse.pos >= upto) {\n                this.takeTree();\n                return true;\n            }\n            if (Date.now() > endTime)\n                return false;\n        }\n    }\n    /// @internal\n    takeTree() {\n        if (this.parse && this.parse.pos > this.tree.length) {\n            this.tree = this.parse.forceFinish();\n            this.fragments = TreeFragment.addTree(this.tree, this.fragments, true);\n        }\n    }\n    /// @internal\n    changes(changes, newState) {\n        let { fragments, tree, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));\n            fragments = TreeFragment.applyChanges(fragments, ranges);\n            tree = Tree.empty;\n            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped) {\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to)\n                        skipped.push({ from, to });\n                }\n            }\n        }\n        return new EditorParseContext(this.parser, newState, fragments, tree, viewport, skipped);\n    }\n    /// @internal\n    updateViewport(viewport) {\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for (let i = 0; i < this.skipped.length; i++) {\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.cutFragments(from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        return this.skipped.length < startLen;\n    }\n    /// @internal\n    cutFragments(from, to) {\n        this.fragments = TreeFragment.applyChanges(this.fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);\n    }\n    /// @internal\n    reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    skipUntilInView(from, to) {\n        this.skipped.push({ from, to });\n    }\n    skipUntil(from, to, until) {\n        this.skippedUntil.push({ from, to, until });\n    }\n}\nclass LanguageState {\n    constructor(\n    // A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context) {\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged)\n            return this;\n        let newState = this.context.changes(tr.changes, tr.state);\n        newState.work(25 /* Apply */);\n        return new LanguageState(newState);\n    }\n}\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback ||\n    ((callback, { timeout }) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\n// FIXME figure out some way to back off from full re-parses when the\n// document is large—you could waste a lot of battery re-parsing a\n// multi-megabyte document every time you insert a backtick, even if\n// it happens in the background.\nclass ParseWorker {\n    constructor(view, field, setState) {\n        this.view = view;\n        this.field = field;\n        this.setState = setState;\n        this.working = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        if (update.docChanged)\n            this.scheduleWork();\n        let cx = this.view.state.field(this.field).context;\n        if (update.viewportChanged && cx.updateViewport(update.view.viewport)) {\n            cx.reset();\n            this.scheduleWork();\n        }\n        this.takeSkipped(cx);\n    }\n    scheduleWork() {\n        if (this.working > -1)\n            return;\n        let { state } = this.view, field = state.field(this.field);\n        if (field.tree.length >= state.doc.length)\n            return;\n        this.working = requestIdle(this.work, { timeout: 200 /* Pause */ });\n    }\n    work(deadline) {\n        this.working = -1;\n        let { state } = this.view, field = state.field(this.field);\n        if (field.tree.length >= state.doc.length)\n            return;\n        field.context.work(deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);\n        if (field.context.tree.length >= state.doc.length) {\n            this.view.dispatch({ effects: this.setState.of(new LanguageState(field.context)) });\n            this.takeSkipped(field.context);\n        }\n        else {\n            this.scheduleWork();\n        }\n    }\n    takeSkipped(context) {\n        while (context.skippedUntil.length) {\n            let { from, to, until } = context.skippedUntil.pop();\n            until.then(() => {\n                let field = this.view.state.field(this.field, false);\n                if (field && field.context == context) {\n                    context.cutFragments(from, to);\n                    context.reset();\n                    this.scheduleWork();\n                }\n            });\n        }\n    }\n    destroy() {\n        if (this.working >= 0)\n            cancelIdle(this.working);\n    }\n}\n\n/// Facet that defines a way to provide a function that computes the\n/// appropriate indentation depth at the start of a given line, or\n/// `null` to indicate no appropriate indentation could be determined.\nconst indentService = Facet.define();\n/// Facet for overriding the unit by which indentation happens.\n/// Should be a string consisting either entirely of spaces or\n/// entirely of tabs. When not set, this defaults to 2 spaces.\nconst indentUnit = Facet.define({\n    combine: values => {\n        if (!values.length)\n            return \"  \";\n        if (!/^(?: +|\\t+)$/.test(values[0]))\n            throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return values[0];\n    }\n});\n/// Return the _column width_ of an indent unit in the state.\n/// Determined by the [`indentUnit`](#language.indentUnit)\n/// facet, and [`tabSize`](#state.EditorState^tabSize) when that\n/// contains tabs.\nfunction getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/// Create an indentation string that covers columns 0 to `cols`.\n/// Will use tabs for as much of the columns as possible when the\n/// [`indentUnit`](#language.indentUnit) facet contains\n/// tabs.\nfunction indentString(state, cols) {\n    let result = \"\", ts = state.tabSize;\n    if (state.facet(indentUnit).charCodeAt(0) == 9)\n        while (cols >= ts) {\n            result += \"\\t\";\n            cols -= ts;\n        }\n    for (let i = 0; i < cols; i++)\n        result += \" \";\n    return result;\n}\n/// Get the indentation at the given position. Will first consult any\n/// [indent services](#language.indentService) that are registered,\n/// and if none of those return an indentation, this will check the\n/// syntax tree for the [indent node prop](#language.indentNodeProp)\n/// and use that if found. Returns a number when an indentation could\n/// be determined, and null otherwise.\nfunction getIndentation(context, pos) {\n    if (context instanceof EditorState)\n        context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)) {\n        let result = service(context, pos);\n        if (result != null)\n            return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree ? syntaxIndentation(context, tree, pos) : null;\n}\n/// Indentation contexts are used when calling [indentation\n/// services](#language.indentService). They provide helper utilities\n/// useful in indentation logic, and can selectively override the\n/// indentation reported for some lines.\nclass IndentContext {\n    /// Create an indent context.\n    constructor(\n    /// The editor state.\n    state, \n    /// @internal\n    options = {}) {\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /// Get the text directly after `pos`, either the entire line\n    /// or the next 100 characters, whichever is shorter.\n    textAfterPos(pos) {\n        var _a, _b;\n        let sim = (_a = this.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n        if (pos == sim && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak))\n            return \"\";\n        return this.state.sliceDoc(pos, Math.min(pos + 100, sim != null && sim > pos ? sim : 1e9, this.state.doc.lineAt(pos).to));\n    }\n    /// find the column position (taking tabs into account) of the given\n    /// position in the given string.\n    countColumn(line, pos) {\n        return countColumn(pos < 0 ? line : line.slice(0, pos), 0, this.state.tabSize);\n    }\n    /// Find the indentation column of the given document line.\n    lineIndent(line) {\n        var _a;\n        let override = (_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation;\n        if (override) {\n            let overriden = override(line.from);\n            if (overriden > -1)\n                return overriden;\n        }\n        let text = line.slice(0, Math.min(100, line.length));\n        return this.countColumn(text, text.search(/\\S/));\n    }\n    /// Find the column for the given position.\n    column(pos) {\n        var _a;\n        let line = this.state.doc.lineAt(pos), text = line.slice(0, pos - line.from);\n        let result = this.countColumn(text, pos - line.from);\n        let override = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation) ? this.options.overrideIndentation(line.from) : -1;\n        if (override > -1)\n            result += override - this.countColumn(text, text.search(/\\S/));\n        return result;\n    }\n}\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a column number or null, where null indicates that no\n/// definitive indentation can be determined.\nconst indentNodeProp = new NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let tree = ast.resolve(pos);\n    // Enter previous nodes that end in empty error terms, which means\n    // they were broken off by error recovery, so that indentation\n    // works even if the constructs haven't been finished.\n    for (let scan = tree, scanPos = pos;;) {\n        let last = scan.childBefore(scanPos);\n        if (!last)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            tree = scan;\n            scanPos = last.from;\n        }\n        else {\n            scan = last;\n            scanPos = scan.to + 1;\n        }\n    }\n    for (; tree; tree = tree.parent) {\n        let strategy = indentStrategy(tree);\n        if (strategy)\n            return strategy(new TreeIndentContext(cx, pos, tree));\n    }\n    return null;\n}\nfunction ignoreClosed(cx) {\n    var _a, _b;\n    return cx.pos == ((_a = cx.options) === null || _a === void 0 ? void 0 : _a.simulateBreak) && ((_b = cx.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak);\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy)\n        return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() { return 0; }\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nclass TreeIndentContext extends IndentContext {\n    /// @internal\n    constructor(base, \n    /// The position at which indentation is being computed.\n    pos, \n    /// The syntax tree node for which the indentation strategy is\n    /// registered.\n    node) {\n        super(base.state, base.options);\n        this.pos = pos;\n        this.node = node;\n    }\n    /// Get the text directly after `this.pos`, either the entire line\n    /// or the next 100 characters, whichever is shorter.\n    get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /// Get the indentation at the reference line for `this.node`, which\n    /// is the line on which it starts, unless there is a node that is\n    /// _not_ a parent of this node covering the start of that line. If\n    /// so, the line at the start of that node is tried, again skipping\n    /// on if it is covered by another such node.\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.from);\n            while (atBreak.parent && atBreak.parent.from == atBreak.from)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line);\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    var _a;\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken)\n        return null;\n    let sim = (_a = context.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for (let pos = openToken.to;;) {\n        let next = tree.childAfter(pos);\n        if (!next || next == last)\n            return null;\n        if (!next.type.isSkipped)\n            return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned)\n        return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/// An indentation strategy that aligns a node content to its base\n/// indentation.\nconst flatIndent = (context) => context.baseIndent;\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nfunction continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/// Enables reindentation on input. When a language defines an\n/// `indentOnInput` field in its [language\n/// data](#state.EditorState.languageDataAt), which must hold a regular\n/// expression, the line at the cursor will be reindented whenever new\n/// text is typed and the input from the start of the line up to the\n/// cursor matches that regexp.\n///\n/// To avoid unneccesary reindents, it is recommended to start the\n/// regexp with `^` (usually followed by `\\s*`), and end it with `$`.\n/// For example, `/^\\s*\\}$` will reindent when a closing brace is\n/// added at the start of a line.\nfunction indentOnInput() {\n    return EditorState.transactionFilter.of(tr => {\n        if (!tr.docChanged || tr.annotation(Transaction.userEvent) != \"input\")\n            return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.primary.head);\n        if (!rules.length)\n            return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.primary, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond)\n            return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some(r => r.test(lineStart)))\n            return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges) {\n            let line = state.doc.lineAt(head);\n            if (line.from == last)\n                continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null)\n                continue;\n            let cur = /^\\s*/.exec(line.slice(0, Math.min(line.length, DontIndentBeyond)))[0];\n            let norm = indentString(state, indent);\n            if (cur != norm)\n                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n        return changes.length ? [tr, { changes }] : tr;\n    });\n}\n\n/// A facet that registers a code folding service. When called with\n/// the extent of a line, such a function should return a range\n/// object when a foldable that starts on that line (but continues\n/// beyond it), if one can be found.\nconst foldService = Facet.define();\n/// This node prop is used to associate folding information with node\n/// types. Given a syntax node, it should check whether that tree is\n/// foldable and return the range that can be collapsed when it is.\nconst foldNodeProp = new NodeProp();\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length == 0)\n        return null;\n    let inner = tree.resolve(end);\n    let found = null;\n    for (let cur = inner; cur; cur = cur.parent) {\n        if (cur.to <= end || cur.from > end)\n            continue;\n        if (found && cur.from < start)\n            break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end)\n                found = value;\n        }\n    }\n    return found;\n}\n/// Check whether the given line is foldable. First asks any fold\n/// services registered through\n/// [`foldService`](#language.foldService), and if none of them return\n/// a result, tries to query the [fold node\n/// prop](#language.foldNodeProp) of syntax nodes that cover the end\n/// of the line.\nfunction foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)) {\n        let result = service(state, lineStart, lineEnd);\n        if (result)\n            return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\n\nexport { EditorParseContext, IndentContext, Language, LezerLanguage, TreeIndentContext, continuedIndent, defineLanguageFacet, delimitedIndent, flatIndent, foldNodeProp, foldService, foldable, getIndentUnit, getIndentation, indentNodeProp, indentOnInput, indentService, indentString, indentUnit, language, languageDataProp, syntaxTree };\n","import { EditorView, Decoration, themeClass, ViewPlugin, logException, WidgetType } from '@codemirror/next/view';\nimport { StateEffect, StateField } from '@codemirror/next/state';\nimport { hoverTooltip } from '@codemirror/next/tooltip';\nimport { panels, showPanel, getPanel } from '@codemirror/next/panel';\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic) {\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected) {\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, diagnostics.length, (from, to, { spec }) => {\n        if (diagnostic && spec.diagnostic != diagnostic)\n            return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction maybeEnableLint(state) {\n    return state.field(lintState, false) ? undefined : { append: [\n            lintState,\n            EditorView.decorations.compute([lintState], state => {\n                let { selected, panel } = state.field(lintState);\n                return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([\n                    activeMark.range(selected.from, selected.to)\n                ]);\n            }),\n            panels(),\n            hoverTooltip(lintTooltip),\n            baseTheme\n        ] };\n}\n/// State effect that is used to update the current set of\n/// diagnostics.\nfunction setDiagnostics(state, diagnostics) {\n    return {\n        effects: setDiagnosticsEffect.of(diagnostics),\n        reconfigure: maybeEnableLint(state)\n    };\n}\nconst setDiagnosticsEffect = StateEffect.define();\nconst togglePanel = StateEffect.define();\nconst movePanelSelection = StateEffect.define();\nconst lintState = StateField.define({\n    create() {\n        return new LintState(Decoration.none, null, null);\n    },\n    update(value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                let ranges = Decoration.set(effect.value.map((d) => {\n                    return d.from < d.to\n                        ? Decoration.mark({\n                            attributes: { class: themeClass(\"lintRange.\" + d.severity) },\n                            diagnostic: d\n                        }).range(d.from, d.to)\n                        : Decoration.widget({\n                            widget: new DiagnosticWidget(d),\n                            diagnostic: d\n                        }).range(d.from);\n                }));\n                value = new LintState(ranges, value.panel, findDiagnostic(ranges));\n            }\n            else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            }\n            else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: [showPanel.nFrom(s => s.panel ? [s.panel] : []),\n        EditorView.decorations.from(s => s.diagnostics)]\n});\nconst activeMark = Decoration.mark({ class: themeClass(\"lintRange.active\") });\nfunction lintTooltip(view, check) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(0, view.state.doc.length, (start, end, { spec }) => {\n        if (check(start, end)) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(start, stackStart);\n            stackEnd = Math.max(end, stackEnd);\n        }\n    });\n    if (!found.length)\n        return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        style: \"lint\",\n        create() {\n            let dom = document.createElement(\"ul\");\n            for (let d of found)\n                dom.appendChild(renderDiagnostic(view, d));\n            return { dom };\n        }\n    };\n}\n/// Command to open and focus the lint panel.\nconst openLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        view.dispatch({ effects: togglePanel.of(true),\n            reconfigure: maybeEnableLint(view.state) });\n    let panel = getPanel(view, LintPanel.open);\n    if (panel)\n        panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/// Command to close the lint panel, when open.\nconst closeLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        return false;\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/// Move the selection to the next diagnostic.\nconst nextDiagnostic = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = view.state.selection.primary, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to)\n            return false;\n    }\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    return true;\n};\n/// A set of default key bindings for the lint functionality.\n///\n/// - Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](#lint.openLintPanel)\n/// - F8: [\\`nextDiagnostic\\`](#lint.nextDiagnostic)\nconst lintKeymap = [\n    { key: \"Mod-Shift-m\", run: openLintPanel },\n    { key: \"F8\", run: nextDiagnostic }\n];\nconst LintDelay = 500;\n/// Given a diagnostic source, this function returns an extension that\n/// enables linting with that source. It will be called whenever the\n/// editor is idle (after its content changed).\nfunction linter(source) {\n    return ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.lintTime = Date.now() + LintDelay;\n            this.set = true;\n            this.run = this.run.bind(this);\n            setTimeout(this.run, LintDelay);\n        }\n        run() {\n            let now = Date.now();\n            if (now < this.lintTime - 10) {\n                setTimeout(this.run, this.lintTime - now);\n            }\n            else {\n                this.set = false;\n                let { state } = this.view;\n                Promise.resolve(source(this.view)).then(annotations => {\n                    var _a, _b;\n                    if (this.view.state.doc == state.doc &&\n                        (annotations.length || ((_b = (_a = this.view.state.field(lintState, false)) === null || _a === void 0 ? void 0 : _a.diagnostics) === null || _b === void 0 ? void 0 : _b.size)))\n                        this.view.dispatch(setDiagnostics(this.view.state, annotations));\n                }, error => { logException(this.view.state, error); });\n            }\n        }\n        update(update) {\n            if (update.docChanged) {\n                this.lintTime = Date.now() + LintDelay;\n                if (!this.set) {\n                    this.set = true;\n                    setTimeout(this.run, LintDelay);\n                }\n            }\n        }\n    });\n}\nfunction renderDiagnostic(view, diagnostic) {\n    let dom = document.createElement(\"li\");\n    dom.textContent = diagnostic.message;\n    dom.className = themeClass(\"diagnostic.\" + diagnostic.severity);\n    if (diagnostic.actions)\n        for (let action of diagnostic.actions) {\n            let button = dom.appendChild(document.createElement(\"button\"));\n            button.className = themeClass(\"diagnosticAction\");\n            button.textContent = action.name;\n            button.onclick = button.onmousedown = e => {\n                e.preventDefault();\n                let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n                if (found)\n                    action.apply(view, found.from, found.to);\n            };\n        }\n    // FIXME render source?\n    return dom;\n}\nclass DiagnosticWidget extends WidgetType {\n    constructor(diagnostic) {\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) { return other.diagnostic == this.diagnostic; }\n    toDOM() {\n        let elt = document.createElement(\"span\");\n        elt.className = themeClass(\"lintPoint.\" + this.diagnostic.severity);\n        return elt;\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic) {\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic);\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view) {\n        this.view = view;\n        this.items = [];\n        this.dom = document.createElement(\"div\");\n        this.list = this.dom.appendChild(document.createElement(\"ul\"));\n        this.list.tabIndex = 0;\n        this.list.setAttribute(\"role\", \"listbox\");\n        this.list.setAttribute(\"aria-label\", this.view.state.phrase(\"Diagnostics\"));\n        this.list.addEventListener(\"keydown\", event => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                closeLintPanel(this.view);\n                this.view.focus();\n            }\n            else if (event.keyCode == 38) { // ArrowUp\n                event.preventDefault();\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            }\n            else if (event.keyCode == 40) { // ArrowDown\n                event.preventDefault();\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            }\n            else if (event.keyCode == 36) { // Home\n                event.preventDefault();\n                this.moveSelection(0);\n            }\n            else if (event.keyCode == 35) { // End\n                event.preventDefault();\n                this.moveSelection(this.items.length - 1);\n            }\n            else if (event.keyCode == 13) {\n                event.preventDefault();\n                this.view.focus();\n            } // FIXME PageDown/PageUp\n        });\n        this.list.addEventListener(\"click\", event => {\n            for (let i = 0; i < this.items.length; i++) {\n                if (this.items[i].dom.contains(event.target))\n                    this.moveSelection(i);\n            }\n        });\n        let close = this.dom.appendChild(document.createElement(\"button\"));\n        close.setAttribute(\"name\", \"close\");\n        close.setAttribute(\"aria-label\", this.view.state.phrase(\"close\"));\n        close.textContent = \"×\";\n        close.addEventListener(\"click\", () => closeLintPanel(this.view));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected)\n            return -1;\n        for (let i = 0; i < this.items.length; i++)\n            if (this.items[i].diagnostic == selected.diagnostic)\n                return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {\n            let found = -1, item;\n            for (let j = i; j < this.items.length; j++)\n                if (this.items[j].diagnostic == spec.diagnostic) {\n                    found = j;\n                    break;\n                }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            }\n            else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            }\n            else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1, to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),\n                write: ({ sel, panel }) => {\n                    if (sel.top < panel.top)\n                        this.list.scrollTop -= panel.top - sel.top;\n                    else if (sel.bottom > panel.bottom)\n                        this.list.scrollTop += sel.bottom - panel.bottom;\n                }\n            });\n        }\n        else if (!this.items.length) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync)\n            this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items) {\n            if (item.dom.parentNode == this.list) {\n                while (domPos != item.dom)\n                    rm();\n                domPos = item.dom.nextSibling;\n            }\n            else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while (domPos)\n            rm();\n        if (!this.list.firstChild)\n            this.list.appendChild(renderDiagnostic(this.view, {\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n    }\n    moveSelection(selectedIndex) {\n        // FIXME make actions accessible\n        if (this.items.length == 0)\n            return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection)\n            return;\n        this.view.dispatch({\n            selection: { anchor: selection.from, head: selection.to },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    get style() { return \"lint\"; }\n    static open(view) { return new LintPanel(view); }\n}\nfunction underline(color) {\n    if (typeof btoa != \"function\")\n        return \"none\";\n    let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"6\" height=\"3\">\n    <path d=\"m0 3 l2 -2 l1 0 l2 2 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>\n  </svg>`;\n    return `url('data:image/svg+xml;base64,${btoa(svg)}')`;\n}\nconst baseTheme = EditorView.baseTheme({\n    $diagnostic: {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\"\n    },\n    \"$diagnostic.error\": { borderLeft: \"5px solid #d11\" },\n    \"$diagnostic.warning\": { borderLeft: \"5px solid orange\" },\n    \"$diagnostic.info\": { borderLeft: \"5px solid #999\" },\n    $diagnosticAction: {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\"\n    },\n    $lintRange: {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\"\n    },\n    \"$lintRange.error\": { backgroundImage: underline(\"#d11\") },\n    \"$lintRange.warning\": { backgroundImage: underline(\"orange\") },\n    \"$lintRange.info\": { backgroundImage: underline(\"#999\") },\n    \"$lintRange.active\": { backgroundColor: \"#ffdd9980\" },\n    $lintPoint: {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \"$lintPoint.warning\": {\n        \"&:after\": { borderBottomColor: \"orange\" }\n    },\n    \"$lintPoint.info\": {\n        \"&:after\": { borderBottomColor: \"#999\" }\n    },\n    \"$panel.lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\"\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    },\n    \"$tooltip.lint\": {\n        padding: 0,\n        margin: 0\n    }\n});\n\nexport { closeLintPanel, lintKeymap, linter, nextDiagnostic, openLintPanel, setDiagnostics };\n","import { Facet, combineConfig, StateField } from '@codemirror/next/state';\nimport { syntaxTree } from '@codemirror/next/language';\nimport { EditorView, Decoration, themeClass } from '@codemirror/next/view';\nimport { NodeProp } from 'lezer-tree';\n\nconst baseTheme = EditorView.baseTheme({\n    $matchingBracket: { color: \"#0b0\" },\n    $nonmatchingBracket: { color: \"#a22\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = Decoration.mark({ class: themeClass(\"matchingBracket\") }), nonmatchingMark = Decoration.mark({ class: themeClass(\"nonmatchingBracket\") });\nconst bracketMatchingState = StateField.define({\n    create() { return Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return Decoration.set(decorations, true);\n    },\n    provide: [EditorView.decorations]\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), sub = tree.resolve(pos, dir), matches;\n    if (matches = matchingNodes(sub.type, dir, brackets))\n        return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);\n    else\n        return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: false };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexport { bracketMatching, matchBrackets };\n","import { ViewPlugin, themeClass, PluginField, EditorView } from '@codemirror/next/view';\nimport { Facet } from '@codemirror/next/state';\n\nconst panelConfig = Facet.define({\n    combine(configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs) {\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return { topContainer, bottomContainer };\n    }\n});\n/// Enables the panel-managing extension.\nfunction panels(config) {\n    let ext = [panelPlugin, baseTheme];\n    if (config)\n        ext.push(panelConfig.of(config));\n    return ext;\n}\n/// Opening a panel is done by providing an object describing the\n/// panel through this facet.\nconst showPanel = Facet.define();\n/// Get the active panel created by the given constructor, if any.\n/// This can be useful when you need access to your panels' DOM\n/// structure.\nfunction getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = view.state.facet(showPanel).indexOf(panel);\n    return plugin && index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.specs = view.state.facet(showPanel);\n        this.panels = this.specs.map(spec => spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter(p => p.top));\n        this.bottom.sync(this.panels.filter(p => !p.top));\n        for (let p of this.panels) {\n            p.dom.className += \" \" + panelClass(p);\n            if (p.mount)\n                p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let specs = update.state.facet(showPanel);\n        if (specs != this.specs) {\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs) {\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                }\n                else {\n                    panel = this.panels[known];\n                    if (panel.update)\n                        panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount) {\n                p.dom.className += \" \" + panelClass(p);\n                if (p.mount)\n                    p.mount();\n            }\n        }\n        else {\n            for (let p of this.panels)\n                if (p.update)\n                    p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: PluginField.scrollMargins.from(value => ({ top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() }))\n});\nfunction panelClass(panel) {\n    return themeClass(panel.style ? `panel.${panel.style}` : \"panel\");\n}\nclass PanelGroup {\n    constructor(view, top, container) {\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = themeClass(this.top ? \"panels.top\" : \"panels.bottom\");\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels) {\n            if (panel.dom.parentNode == this.dom) {\n                while (curDOM != panel.dom)\n                    curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            }\n            else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while (curDOM)\n            curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0\n            : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - this.view.scrollDOM.getBoundingClientRect().top\n                : this.view.scrollDOM.getBoundingClientRect().bottom - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses)\n            return;\n        for (let cls of this.classes.split(\" \"))\n            if (cls)\n                this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))\n            if (cls)\n                this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\nconst baseTheme = EditorView.baseTheme({\n    $panels: {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0\n    },\n    \"$$light $panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"$$light $panels.top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"$$light $panels.bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"$$dark $panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    }\n});\n\nexport { getPanel, panels, showPanel };\n","import { MapMode } from '@codemirror/next/state';\n\n/// Each range is associated with a value, which must inherit from\n/// this class.\nclass RangeValue {\n    /// Compare this value with another value. The default\n    /// implementation compares by identity.\n    eq(other) { return this == other; }\n    /// Create a [range](#rangeset.Range) with this value.\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/// A range associates a value with a range of positions.\nclass Range {\n    /// @internal\n    constructor(\n    /// The range's start position.\n    from, \n    /// Its end position.\n    to, \n    /// The value associated with this range.\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\n// The maximum amount of ranges to store in a single chunk\nconst ChunkSize = 250, \n// Chunks with points of this size are never skipped during\n// compare, since moving past those points is likely to speed\n// up, rather than slow down, the comparison.\nBigPointSize = 500, \n// A large (fixnum) value to use for max/min values.\nFar = 1e9;\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * Far, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/// A range set stores a collection of [ranges](#rangeset.Range) in a\n/// way that makes them efficient to [map](#rangeset.RangeSet.map) and\n/// [update](#rangeset.RangeSet.update). This is an immutable data\n/// structure.\nclass RangeSet {\n    /// @internal\n    constructor(\n    /// @internal\n    chunkPos, \n    /// @internal\n    chunk, \n    /// @internal\n    nextLayer = RangeSet.empty, \n    /// @internal\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /// @internal\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /// @internal\n    get size() {\n        if (this == RangeSet.empty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /// @internal\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /// Update the range set, optionally adding new ranges or filtering\n    /// out existing ones.\n    update(updateSpec) {\n        let { add = [], sort = false, filter, filterFrom = 0, filterTo = this.length } = updateSpec;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this == RangeSet.empty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /// Map this range set through a set of changes, return the new set.\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /// Iterate over the ranges that touch the region `from` to `to`,\n    /// calling `f` for each. There is no guarantee that the ranges will\n    /// be reported in any order. When the callback returns `false`,\n    /// iteration stops.\n    between(from, to, f) {\n        if (this == RangeSet.empty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /// Iterate over the ranges in this set, in order, including all\n    /// ranges that end at or after `from`.\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /// Iterate over the given sets, starting from `from`.\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /// Iterate over two groups of sets, calling methods on `comparator`\n    /// to notify it of possible differences. `textDiff` indicates how\n    /// the underlying data changed between these ranges, and is needed\n    /// to synchronize the iteration. `from` and `to` are coordinates in\n    /// the _new_ space, after these changes.\n    static compare(oldSets, newSets, textDiff, comparator) {\n        var _a;\n        let minPoint = (_a = comparator.minPointSize) !== null && _a !== void 0 ? _a : -1;\n        let a = oldSets.filter(set => set.maxPoint >= BigPointSize ||\n            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPoint);\n        let b = newSets.filter(set => set.maxPoint >= BigPointSize ||\n            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPoint);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPoint);\n        let sideB = new SpanCursor(b, sharedChunks, minPoint);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /// Iterate over a group of range sets at the same time, notifying\n    /// the iterator about the ranges covering every given piece of\n    /// content. Returns the open count (see\n    /// [`SpanIterator.span`](#rangeset.SpanIterator.span)) at the end\n    /// of the iteration.\n    static spans(sets, from, to, iterator) {\n        var _a;\n        let cursor = new SpanCursor(sets, null, (_a = iterator.minPointSize) !== null && _a !== void 0 ? _a : -1).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /// Create a range set for the given range or array of ranges. By\n    /// default, this expects the ranges to be _sorted_ (by start\n    /// position and, if two start at the same position,\n    /// `value.startSide`). You can pass `true` as second argument to\n    /// cause the method to sort them.\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/// The empty set of ranges.\nRangeSet.empty = new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/// A range set builder is a data structure that helps build up a\n/// [range set](#rangeset.RangeSet) directly, without first allocating\n/// an array of [`Range`](#rangeset.Range) objects.\nclass RangeSetBuilder {\n    /// Create an empty builder.\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -Far;\n        this.lastTo = -Far;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /// Add a range. Ranges should be added in sorted (by `from` and\n    /// `value.startSide`) order.\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /// @internal\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == ChunkSize)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /// @internal\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /// Finish the range set. Returns the new set. The builder can't be\n    /// used anymore after this has been called.\n    finish() { return this.finishInner(RangeSet.empty); }\n    /// @internal\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < BigPointSize)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -Far) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = Far;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -Far) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = Far;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -Far;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -Far) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = Far;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = 0; i < this.active.length; i++) {\n            if (this.activeRank[i] > this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active;\n    }\n    openEnd(to) {\n        let open = 0;\n        while (open < this.activeTo.length && this.activeTo[open] > to)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = Far;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n","import { Decoration, themeClass, ViewPlugin, EditorView, runScopeHandlers } from '@codemirror/next/view';\nimport { StateEffect, StateField, EditorSelection, precedence } from '@codemirror/next/state';\nimport { showPanel, getPanel, panels } from '@codemirror/next/panel';\nimport { RangeSetBuilder } from '@codemirror/next/rangeset';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? x => x.normalize(\"NFKD\") : x => x;\n/// A search cursor provides an iterator over text matches in a\n/// document.\nclass SearchCursor {\n    /// Create a text cursor. The query is the search string, `from` to\n    /// `to` provides the region to search.\n    ///\n    /// When `normalize` is given, it will be called, on both the query\n    /// string and the content it is matched against, before comparing.\n    /// You can, for example, create a case-insensitive search by\n    /// passing `s => s.toLowerCase()`.\n    ///\n    /// Text is always normalized with\n    /// [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    /// (when supported).\n    constructor(text, query, from = 0, to = text.length, normalize) {\n        /// The current match (only holds a meaningful value after\n        /// [`next`](#search.SearchCursor.next) has been called and when\n        /// `done` is false).\n        this.value = { from: 0, to: 0 };\n        /// Whether the end of the iterated region has been reached.\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return this.buffer.charCodeAt(this.bufferPos);\n    }\n    /// Look for the next match. Updates the iterator's\n    /// [`value`](#search.SearchCursor.value) and\n    /// [`done`](#search.SearchCursor.done) properties. Should be called\n    /// at least once before using the cursor.\n    next() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = String.fromCharCode(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos++;\n            for (;;) {\n                let peek = this.peek();\n                if (peek < 0xDC00 || peek >= 0xE000)\n                    break;\n                this.bufferPos++;\n                str += String.fromCharCode(peek);\n            }\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        return match;\n    }\n}\n\nclass Query {\n    constructor(search, replace, caseInsensitive) {\n        this.search = search;\n        this.replace = replace;\n        this.caseInsensitive = caseInsensitive;\n    }\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive;\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new SearchCursor(doc, this.search, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n    }\n    get valid() { return !!this.search; }\n}\nconst setQuery = StateEffect.define();\nconst togglePanel = StateEffect.define();\nconst searchState = StateField.define({\n    create() {\n        return new SearchState(new Query(\"\", \"\", false), []);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setQuery))\n                value = new SearchState(effect.value, value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? [createSearchPanel] : []);\n        }\n        return value;\n    },\n    provide: [showPanel.nFrom(s => s.panel)]\n});\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = Decoration.mark({ class: themeClass(\"searchMatch\") }), selectedMatchMark = Decoration.mark({ class: themeClass(\"searchMatch.selected\") });\nconst searchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.prevState.field(searchState) || update.docChanged || update.selectionSet)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel.length || !query.valid)\n            return Decoration.none;\n        let state = this.view.state, viewport = this.view.viewport;\n        let cursor = query.cursor(state.doc, Math.max(0, viewport.from - query.search.length), Math.min(viewport.to + query.search.length, state.doc.length));\n        let builder = new RangeSetBuilder();\n        while (!cursor.next().done) {\n            let { from, to } = cursor.value;\n            let selected = state.selection.ranges.some(r => r.from == from && r.to == to);\n            builder.add(from, to, selected ? selectedMatchMark : matchMark);\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\nfunction findNextMatch(doc, from, query) {\n    let cursor = query.cursor(doc, from).next();\n    if (cursor.done) {\n        cursor = query.cursor(doc, 0, from + query.search.length - 1).next();\n        if (cursor.done)\n            return null;\n    }\n    return cursor.value;\n}\n/// Open the search panel if it isn't already open, and move the\n/// selection to the first match after the current primary selection.\n/// Will wrap around to the start of the document when it reaches the\n/// end.\nconst findNext = searchCommand((view, state) => {\n    let { from, to } = view.state.selection.primary;\n    let next = findNextMatch(view.state.doc, view.state.selection.primary.from + 1, state.query);\n    if (!next || next.from == from && next.to == to)\n        return false;\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    maybeAnnounceMatch(view);\n    return true;\n});\nconst FindPrevChunkSize = 10000;\n// Searching in reverse is, rather than implementing inverted search\n// cursor, done by scanning chunk after chunk forward.\nfunction findPrevInRange(query, doc, from, to) {\n    for (let pos = to;;) {\n        let start = Math.max(from, pos - FindPrevChunkSize - query.search.length);\n        let cursor = query.cursor(doc, start, pos), range = null;\n        while (!cursor.next().done)\n            range = cursor.value;\n        if (range)\n            return range;\n        if (start == from)\n            return null;\n        pos -= FindPrevChunkSize;\n    }\n}\n/// Move the selection to the previous instance of the search query,\n/// before the current primary selection. Will wrap past the start\n/// of the document to start searching at the end again.\nconst findPrevious = searchCommand((view, { query }) => {\n    let { state } = view;\n    let range = findPrevInRange(query, state.doc, 0, state.selection.primary.to - 1) ||\n        findPrevInRange(query, state.doc, state.selection.primary.from + 1, state.doc.length);\n    if (!range)\n        return false;\n    view.dispatch({ selection: { anchor: range.from, head: range.to }, scrollIntoView: true });\n    maybeAnnounceMatch(view);\n    return true;\n});\n/// Select all instances of the search query.\nconst selectMatches = searchCommand((view, { query }) => {\n    let cursor = query.cursor(view.state.doc), ranges = [];\n    while (!cursor.next().done)\n        ranges.push(EditorSelection.range(cursor.value.from, cursor.value.to));\n    if (!ranges.length)\n        return false;\n    view.dispatch({ selection: EditorSelection.create(ranges) });\n    return true;\n});\n/// Select all instances of the currently selected text.\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.primary.empty)\n        return false;\n    let { from, to } = sel.primary;\n    let ranges = [], primary = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            primary = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({ selection: new EditorSelection(ranges, primary) }));\n    return true;\n};\n/// Replace the current match of the search query.\nconst replaceNext = searchCommand((view, { query }) => {\n    let { state } = view, next = findNextMatch(state.doc, state.selection.primary.from, query);\n    if (!next)\n        return false;\n    let { from, to } = state.selection.primary, changes = [], selection;\n    if (next.from == from && next.to == to) {\n        changes.push({ from: next.from, to: next.to, insert: query.replace });\n        next = findNextMatch(state.doc, next.to, query);\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - query.replace.length;\n        selection = { anchor: next.from - off, head: next.to - off };\n    }\n    view.dispatch({ changes, selection, scrollIntoView: !!selection });\n    if (next)\n        maybeAnnounceMatch(view);\n    return true;\n});\n/// Replace all instances of the search query with the given\n/// replacement.\nconst replaceAll = searchCommand((view, { query }) => {\n    let cursor = query.cursor(view.state.doc), changes = [];\n    while (!cursor.next().done) {\n        let { from, to } = cursor.value;\n        changes.push({ from, to, insert: query.replace });\n    }\n    if (!changes.length)\n        return false;\n    view.dispatch({ changes });\n    return true;\n});\nfunction createSearchPanel(view) {\n    let { query } = view.state.field(searchState);\n    return {\n        dom: buildPanel({\n            view,\n            query,\n            updateQuery(q) {\n                if (!query.eq(q)) {\n                    query = q;\n                    view.dispatch({ effects: setQuery.of(query) });\n                }\n            }\n        }),\n        mount() {\n            this.dom.querySelector(\"[name=search]\").select();\n        },\n        pos: 80,\n        style: \"search\"\n    };\n}\n/// Make sure the search panel is open and focused.\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel.length) {\n        let panel = getPanel(view, createSearchPanel);\n        if (!panel)\n            return false;\n        panel.dom.querySelector(\"[name=search]\").focus();\n    }\n    else {\n        view.dispatch({ effects: togglePanel.of(true),\n            reconfigure: state ? undefined : { append: searchExtensions } });\n    }\n    return true;\n};\n/// Close the search panel.\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel.length)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/// Default search-related key bindings.\n///\n///  * Mod-f: [`openSearchPanel`](#search.openSearchPanel)\n///  * F3, Mod-g: [`findNext`](#search.findNext)\n///  * Shift-F3, Shift-Mod-g: [`findPrevious`](#search.findPrevious)\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches }\n];\nfunction elt(name, props = null, children = []) {\n    let e = document.createElement(name);\n    if (props)\n        for (let prop in props) {\n            let value = props[prop];\n            if (typeof value == \"string\")\n                e.setAttribute(prop, value);\n            else\n                e[prop] = value;\n        }\n    for (let child of children)\n        e.appendChild(typeof child == \"string\" ? document.createTextNode(child) : child);\n    return e;\n}\n// FIXME sync when search state changes independently\nfunction buildPanel(conf) {\n    function p(phrase) { return conf.view.state.phrase(phrase); }\n    let searchField = elt(\"input\", {\n        value: conf.query.search,\n        placeholder: p(\"Find\"),\n        \"aria-label\": p(\"Find\"),\n        class: themeClass(\"textfield\"),\n        name: \"search\",\n        onchange: update,\n        onkeyup: update\n    });\n    let replaceField = elt(\"input\", {\n        value: conf.query.replace,\n        placeholder: p(\"Replace\"),\n        \"aria-label\": p(\"Replace\"),\n        class: themeClass(\"textfield\"),\n        name: \"replace\",\n        onchange: update,\n        onkeyup: update\n    });\n    let caseField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"case\",\n        checked: !conf.query.caseInsensitive,\n        onchange: update\n    });\n    function update() {\n        conf.updateQuery(new Query(searchField.value, replaceField.value, !caseField.checked));\n    }\n    function keydown(e) {\n        if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(conf.view);\n        }\n        else if (e.keyCode == 13 && e.target == replaceField) {\n            e.preventDefault();\n            replaceNext(conf.view);\n        }\n    }\n    function button(name, onclick, content) {\n        return elt(\"button\", { class: themeClass(\"button\"), name, onclick }, content);\n    }\n    let panel = elt(\"div\", { onkeydown: keydown }, [\n        searchField,\n        button(\"next\", () => findNext(conf.view), [p(\"next\")]),\n        button(\"prev\", () => findPrevious(conf.view), [p(\"previous\")]),\n        button(\"select\", () => selectMatches(conf.view), [p(\"all\")]),\n        elt(\"label\", null, [caseField, \"match case\"]),\n        elt(\"br\"),\n        replaceField,\n        button(\"replace\", () => replaceNext(conf.view), [p(\"replace\")]),\n        button(\"replaceAll\", () => replaceAll(conf.view), [p(\"replace all\")]),\n        elt(\"button\", { name: \"close\", onclick: () => closeSearchPanel(conf.view), \"aria-label\": p(\"close\") }, [\"×\"]),\n        elt(\"div\", { style: \"position: absolute; top: -10000px\", \"aria-live\": \"polite\" })\n    ]);\n    return panel;\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\n// FIXME this is a kludge\nfunction maybeAnnounceMatch(view) {\n    let { from, to } = view.state.selection.primary;\n    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != lineStart) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    let panel = getPanel(view, createSearchPanel);\n    if (!panel || !panel.dom.contains(view.root.activeElement))\n        return;\n    let live = panel.dom.querySelector(\"div[aria-live]\");\n    live.textContent = view.state.phrase(\"current match\") + \". \" + text;\n}\nconst baseTheme = EditorView.baseTheme({\n    \"$panel.search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button\": {\n            margin: \".2em .5em .2em 0\"\n        },\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    },\n    \"$$light $searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"$$dark $searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"$$light $searchMatch.selected\": { backgroundColor: \"#ff6a0054\" },\n    \"$$dark $searchMatch.selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    precedence(searchHighlighter, \"override\"),\n    panels(),\n    baseTheme\n];\n\nexport { SearchCursor, closeSearchPanel, findNext, findPrevious, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectSelectionMatches };\n","import { Text } from '@codemirror/next/text';\nexport { Text } from '@codemirror/next/text';\n\nconst DefaultSplit = /\\r\\n?|\\n/;\n/// Distinguishes different ways in which positions can be mapped.\nvar MapMode;\n(function (MapMode) {\n    /// Map a position to a valid new position, even when its context\n    /// was deleted.\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /// Return null if deletion happens across the position.\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /// Return null if the character _before_ the position is deleted.\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /// Return null if the character _after_ the position is deleted.\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n})(MapMode || (MapMode = {}));\n/// A change description is a variant of [change set](#state.ChangeSet)\n/// that doesn't store the inserted text. As such, it can't be\n/// applied, but is cheaper to store and manipulate.\nclass ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /// @internal\n    constructor(\n    /// @internal\n    sections) {\n        this.sections = sections;\n    }\n    /// The length of the document before the change.\n    get length() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2)\n            result += this.sections[i];\n        return result;\n    }\n    /// The length of the document after the change.\n    get newLength() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /// False when there are actual changes in this set.\n    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }\n    /// Iterate over the unchanged parts left by these changes.\n    iterGaps(f) {\n        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            }\n            else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /// Iterate over the ranges changed by these changes. (See\n    /// [`ChangeSet.iterChanges`](#state.ChangeSet.iterChanges) for a\n    /// variant that also provides you with the inserted text.)\n    ///\n    /// When `individual` is true, adjacent changes (which are kept\n    /// separate for [position mapping](#state.ChangeDesc.mapPos)) are\n    /// reported separately.\n    iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /// Get a description of the inverted form of these changes.\n    get invertedDesc() {\n        let sections = [];\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0)\n                sections.push(len, ins);\n            else\n                sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /// Compute the combined effect of applying another set of changes\n    /// after this one. The length of the document after this set should\n    /// match the length before `other`.\n    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }\n    /// Map this description, which should start with the same document\n    /// as `other`, over another set of changes, so that it can be\n    /// applied after it.\n    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos)\n                    return posB + (pos - posA);\n                posB += len;\n            }\n            else {\n                if (mode != MapMode.Simple && endA >= pos &&\n                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||\n                        mode == MapMode.TrackBefore && posA < pos ||\n                        mode == MapMode.TrackAfter && endA > pos))\n                    return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len)\n                    return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA)\n            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /// Check whether these changes touch a given range. When one of the\n    /// changes entirely covers the range, the string `\"cover\"` is\n    /// returned.\n    touchesRange(from, to = from) {\n        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from)\n                return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /// @internal\n    toString() {\n        let result = \"\";\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n}\n/// A change set represents a group of modifications to a document. It\n/// stores the document length, and can only be applied to documents\n/// with exactly that length.\nclass ChangeSet extends ChangeDesc {\n    /// @internal\n    constructor(sections, \n    /// @internal\n    inserted) {\n        super(sections);\n        this.inserted = inserted;\n    }\n    /// Apply the changes to a document, returning the modified\n    /// document.\n    apply(doc) {\n        if (this.length != doc.length)\n            throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    /// Map this set, which should start with the same document as\n    /// `other`, over another set of changes, so that it can be applied\n    /// after it. When `before` is true, map as if the changes in\n    /// `other` happened before the ones in `this`.\n    mapDesc(other, before = false) { return mapSet(this, other, before, true); }\n    /// Given the document as it existed _before_ the changes, return a\n    /// change set that represents the inverse of this set, which could\n    /// be used to go from the document created by the changes back to\n    /// the document as it existed before the changes.\n    invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for (let i = 0, pos = 0; i < sections.length; i += 2) {\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while (inserted.length < index)\n                    inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /// Combine two subsequent change sets into a single set. `other`\n    /// must start in the document produced by `this`. If `this` goes\n    /// `docA` → `docB` and `other` represents `docB` → `docC`, the\n    /// returned value will represent the change `docA` → `docC`.\n    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }\n    /// Given another change set starting in the same document, maps this\n    /// change set over the other, producing a new change set that can be\n    /// applied to the document produced by applying `other`. When\n    /// `before` is `true`, order changes as if `this` comes before\n    /// `other`, otherwise (the default) treat `other` as coming first.\n    ///\n    /// Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    /// `B.compose(A.map(B, true))` will produce the same document. This\n    /// provides a basic form of [operational\n    /// transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    /// and can be used for collaborative editing.\n    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }\n    /// Iterate over the changed ranges in the document, calling `f` for\n    /// each.\n    iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /// Get a [change description](#state.ChangeDesc) for this change\n    /// set.\n    get desc() { return new ChangeDesc(this.sections); }\n    /// @internal\n    filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for (let i = 0, pos = 0;;) {\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while (pos < next || pos == next && iter.len == 0) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0)\n                    addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while (pos < end) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return { changes: new ChangeSet(resultSections, resultInserted),\n            filtered: new ChangeDesc(filteredSections) };\n    }\n    /// Serialize this change set to a JSON-representable value.\n    toJSON() {\n        let parts = [];\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0)\n                parts.push(len);\n            else if (ins == 0)\n                parts.push([len]);\n            else\n                parts.push([len, this.inserted[i >> 1].toJSON()]);\n        }\n        return parts;\n    }\n    /// Create a change set for the given changes, for a document of the\n    /// given length, using `lineSep` as line separator.\n    static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length)\n                return;\n            if (pos < length)\n                addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)\n                    process(sub);\n            }\n            else if (spec instanceof ChangeSet) {\n                if (spec.length != length)\n                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            }\n            else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length)\n                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0)\n                    return;\n                if (from < pos)\n                    flush();\n                if (from > pos)\n                    addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /// Create an empty changeset of the given length.\n    static empty(length) {\n        return new ChangeSet(length ? [length, -1] : [], []);\n    }\n    /// Create a changeset from its JSON representation (as produced by\n    /// [`toJSON`](#state.ChangeSet.toJSON).\n    static fromJSON(json) {\n        let sections = [], inserted = [];\n        for (let i = 0; i < json.length; i++) {\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            }\n            else if (part.length == 1) {\n                sections.push(part[0], 0);\n            }\n            else {\n                while (inserted.length < i)\n                    inserted.push(Text.empty);\n                inserted[i] = Text.of(part[1]);\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0)\n        return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1])\n        sections[last] += len;\n    else if (len == 0 && sections[last] == 0)\n        sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    }\n    else\n        sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0)\n        return;\n    let index = (sections.length - 2) >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    }\n    else {\n        while (values.length < index)\n            values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        }\n        else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for (;;) {\n                endA += len;\n                endB += ins;\n                if (ins && inserted)\n                    text = text.append(inserted[(i - 2) >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)\n                    break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let posA = 0, posB = 0;;) {\n        if (a.ins == -1) {\n            posA += a.len;\n            a.next();\n        }\n        else if (b.ins == -1 && posB < posA) {\n            let skip = Math.min(b.len, posA - posB);\n            b.forward(skip);\n            addSection(sections, skip, -1);\n            posB += skip;\n        }\n        else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {\n            addSection(sections, b.ins, -1);\n            while (posA > posB && !a.done && posA + a.len < posB + b.len) {\n                posA += a.len;\n                a.next();\n            }\n            posB += b.len;\n            b.next();\n        }\n        else if (a.ins >= 0) {\n            let len = 0, end = posA + a.len;\n            for (;;) {\n                if (b.ins >= 0 && posB > posA && posB + b.len < end) {\n                    len += b.ins;\n                    posB += b.len;\n                    b.next();\n                }\n                else if (b.ins == -1 && posB < end) {\n                    let skip = Math.min(b.len, end - posB);\n                    len += skip;\n                    b.forward(skip);\n                    posB += skip;\n                }\n                else {\n                    break;\n                }\n            }\n            addSection(sections, len, a.ins);\n            if (insert)\n                addInsert(insert, sections, a.text);\n            posA = end;\n            a.next();\n        }\n        else if (a.done && b.done) {\n            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n        }\n        else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let open = false;;) {\n        if (a.done && b.done) {\n            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n        }\n        else if (a.ins == 0) { // Deletion in A\n            addSection(sections, a.len, 0, open);\n            a.next();\n        }\n        else if (b.len == 0 && !b.done) { // Insertion in B\n            addSection(sections, 0, b.ins, open);\n            if (insert)\n                addInsert(insert, sections, b.text);\n            b.next();\n        }\n        else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB)\n                    addInsert(insert, sections, b.text);\n            }\n            else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert)\n                    addInsert(insert, sections, a.textBit(len));\n            }\n            else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off)\n                    addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set) {\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        }\n        else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() { return this.ins == -2; }\n    get len2() { return this.ins < 0 ? this.len : this.ins; }\n    get text() {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length && !len ? Text.empty\n            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len)\n            this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1)\n            this.forward(len);\n        else if (len == this.ins)\n            this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n\n/// A single selection range. When\n/// [`allowMultipleSelections`](#state.EditorState^allowMultipleSelections)\n/// is enabled, a [selection](#state.EditorSelection) may hold\n/// multiple ranges. By default, selections hold exactly one range.\nclass SelectionRange {\n    // @internal\n    constructor(\n    /// The lower side of the range.\n    from, \n    /// The upper side of the range.\n    to, flags) {\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /// The anchor of the range—the side that doesn't move when you\n    /// extend it.\n    get anchor() { return this.flags & 16 /* Inverted */ ? this.to : this.from; }\n    /// The head of the range, which is moved when the range is\n    /// [extended](#state.SelectionRange.extend).\n    get head() { return this.flags & 16 /* Inverted */ ? this.from : this.to; }\n    /// True when `anchor` and `head` are at the same position.\n    get empty() { return this.from == this.to; }\n    /// If this is a cursor that is explicitly associated with the\n    /// character on one of its sides, this returns the side. -1 means\n    /// the character before its position, 1 the character after, and 0\n    /// means no association.\n    get assoc() { return this.flags & 4 /* AssocBefore */ ? -1 : this.flags & 8 /* AssocAfter */ ? 1 : 0; }\n    /// The bidirectional text level associated with this cursor.\n    get bidiLevel() {\n        let level = this.flags & 3 /* BidiLevelMask */;\n        return level == 3 ? null : level;\n    }\n    get goalColumn() {\n        let value = this.flags >> 5 /* GoalColumnOffset */;\n        return value == 33554431 /* NoGoalColumn */ ? undefined : value;\n    }\n    /// Map this range through a mapping.\n    map(mapping) {\n        let from = mapping.mapPos(this.from), to = mapping.mapPos(this.to);\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /// Extend this range to cover at least `from` to `to`.\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /// Compare this range to another range.\n    eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /// Return a JSON-serializable object representing the range.\n    toJSON() { return { anchor: this.anchor, head: this.head }; }\n    /// Convert a JSON representation of a range to a `SelectionRange`\n    /// instance.\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n}\n/// An editor selection holds one or more selection ranges.\nclass EditorSelection {\n    /// @internal\n    constructor(\n    /// The ranges in the selection, sorted by position. Ranges cannot\n    /// overlap (but they may touch, if they aren't empty).\n    ranges, \n    /// The index of the _primary_ range in the selection (which is\n    /// usually the range that was added last).\n    primaryIndex = 0) {\n        this.ranges = ranges;\n        this.primaryIndex = primaryIndex;\n    }\n    /// Map a selection through a mapping. Mostly used to adjust the\n    /// selection position for changes.\n    map(mapping) {\n        if (mapping.empty)\n            return this;\n        return EditorSelection.create(this.ranges.map(r => r.map(mapping)), this.primaryIndex);\n    }\n    /// Compare this selection to another selection.\n    eq(other) {\n        if (this.ranges.length != other.ranges.length ||\n            this.primaryIndex != other.primaryIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i]))\n                return false;\n        return true;\n    }\n    /// Get the primary selection range. Usually, you should make sure\n    /// your code applies to _all_ ranges, by using methods like\n    /// [`changeByRange`](#state.EditorState.changeByRange).\n    get primary() { return this.ranges[this.primaryIndex]; }\n    /// Make sure the selection only has one range. Returns a selection\n    /// holding only the primary range from this selection.\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.primary]);\n    }\n    /// Extend this selection with an extra range.\n    addRange(range, primary = true) {\n        return EditorSelection.create([range].concat(this.ranges), primary ? 0 : this.primaryIndex + 1);\n    }\n    /// Replace a given range with another range, and then normalize the\n    /// selection to merge and sort ranges if necessary.\n    replaceRange(range, which = this.primaryIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.primaryIndex);\n    }\n    /// Convert this selection to an object that can be serialized to\n    /// JSON.\n    toJSON() {\n        return { ranges: this.ranges.map(r => r.toJSON()), primaryIndex: this.primaryIndex };\n    }\n    /// Create a selection from a JSON representation.\n    static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.primaryIndex != \"number\" || json.primaryIndex >= json.ranges.length)\n            throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.primaryIndex);\n    }\n    /// Create a selection holding a single range.\n    static single(anchor, head = anchor) {\n        return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n    }\n    /// Sort and merge the given set of ranges, creating a valid\n    /// selection.\n    static create(ranges, primaryIndex = 0) {\n        if (ranges.length == 0)\n            throw new RangeError(\"A selection needs at least one range\");\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return normalized(ranges.slice(), primaryIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, primaryIndex);\n    }\n    /// Create a cursor selection range at the given position. You can\n    /// probably ignore [association](#state.SelectionRange.assoc) and\n    /// [bidi level](#state.SelectionRange.bidiLevel) in most\n    /// situations.\n    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* AssocBefore */ : 8 /* AssocAfter */) |\n            (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |\n            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */));\n    }\n    /// Create a selection range.\n    static range(anchor, head, goalColumn) {\n        let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */;\n        return head < anchor ? new SelectionRange(head, anchor, 16 /* Inverted */ | goal) : new SelectionRange(anchor, head, goal);\n    }\n}\nfunction normalized(ranges, primaryIndex = 0) {\n    let primary = ranges[primaryIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    primaryIndex = ranges.indexOf(primary);\n    for (let i = 1; i < ranges.length; i++) {\n        let range = ranges[i], prev = ranges[i - 1];\n        if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n            let from = prev.from, to = Math.max(range.to, prev.to);\n            if (i <= primaryIndex)\n                primaryIndex--;\n            ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n        }\n    }\n    return new EditorSelection(ranges, primaryIndex);\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)\n        if (range.to > docLength)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/// A facet is a value that is assicated with a state and can be\n/// influenced by any number of extensions. Extensions can provide\n/// input values for the facet, and the facet combines those into an\n/// output value.\n///\n/// Examples of facets are the theme styles associated with an editor\n/// (which are all stored) or the tab size (which is reduced to a\n/// single value, using the input with the hightest precedence).\nclass Facet {\n    constructor(\n    /// @internal\n    combine, \n    /// @internal\n    compareInput, \n    /// @internal\n    compare, isStatic) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /// @internal\n        this.id = nextID++;\n        this.default = combine([]);\n    }\n    /// Define a new facet.\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static);\n    }\n    /// Returns an extension that adds the given value for this facet.\n    of(value) {\n        return new FacetProvider([], this, 0 /* Static */, value);\n    }\n    /// Create an extension that computes a value for the facet from a\n    /// state. You must take care to declare the parts of the state that\n    /// this value depends on, since your function is only called again\n    /// for a new state when one of those parts changed.\n    ///\n    /// In most cases, you'll want to use the\n    /// [`provide`](#state.StateField^define^config.provide) option when\n    /// defining a field instead.\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Single */, get);\n    }\n    /// Create an extension that computes zero or more values for this\n    /// facet from a state.\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Multi */, get);\n    }\n    /// Helper method for registering a facet source with a state field\n    /// via its [`provide`](#state.StateField^define^config.provide) option.\n    /// Returns a value that can be passed to that option to make the\n    /// field automatically provide a value for this facet.\n    from(get, prec) {\n        return field => maybePrec(prec, this.compute([field], state => get(state.field(field))));\n    }\n    /// Helper for [providing](#state.StateField^define^config.provide)\n    /// a dynamic number of values for this facet from a state field.\n    nFrom(get, prec) {\n        return field => maybePrec(prec, this.computeN([field], state => get(state.field(field))));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let idx = addresses[this.id] >> 1, multi = this.type == 2 /* Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return (state, tr) => {\n            if (!tr || tr.reconfigure) {\n                state.values[idx] = getter(state);\n                return 1 /* Changed */;\n            }\n            else {\n                let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) ||\n                    depAddrs.some(addr => (ensureAddr(state, addr) & 1 /* Changed */) > 0);\n                if (!depChanged)\n                    return 0;\n                let newVal = getter(state), oldVal = tr.startState.values[idx];\n                if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))\n                    return 0;\n                state.values[idx] = newVal;\n                return 1 /* Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    return (state, tr) => {\n        let oldAddr = !tr ? null : tr.reconfigure ? tr.startState.config.address[facet.id] : idx << 1;\n        let changed = oldAddr == null;\n        for (let dynAddr of dynamic) {\n            if (ensureAddr(state, dynAddr) & 1 /* Changed */)\n                changed = true;\n        }\n        if (!changed)\n            return 0;\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        let newVal = facet.combine(values);\n        if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))\n            return 0;\n        state.values[idx] = newVal;\n        return 1 /* Changed */;\n    };\n}\nfunction maybeIndex(state, id) {\n    let found = state.config.address[id];\n    return found == null ? null : found >> 1;\n}\n/// Fields can store additional information in an editor state, and\n/// keep it in sync with the rest of the state.\nclass StateField {\n    constructor(\n    /// @internal\n    id, createF, updateF, compareF, \n    /// @internal\n    facets) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.facets = facets;\n    }\n    /// Define a state field.\n    static define(config) {\n        let facets = [];\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), facets);\n        if (config.provide)\n            for (let p of config.provide) {\n                if (p instanceof Facet)\n                    facets.push(p.compute([field], state => state.field(field)));\n                else\n                    facets.push(p(field));\n            }\n        return field;\n    }\n    /// @internal\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return (state, tr) => {\n            if (!tr) {\n                state.values[idx] = this.createF(state);\n                return 1 /* Changed */;\n            }\n            let oldVal, changed = 0;\n            if (tr.reconfigure) {\n                let oldIdx = maybeIndex(tr.startState, this.id);\n                oldVal = oldIdx == null ? this.createF(tr.startState) : tr.startState.values[oldIdx];\n                changed = 1 /* Changed */;\n            }\n            else {\n                oldVal = tr.startState.values[idx];\n            }\n            let value = this.updateF(oldVal, tr);\n            if (!changed && !this.compareF(oldVal, value))\n                changed = 1 /* Changed */;\n            if (changed)\n                state.values[idx] = value;\n            return changed;\n        };\n    }\n}\nconst Prec = { fallback: 3, default: 2, extend: 1, override: 0 };\n/// By default extensions are registered in the order they are found\n/// the flattened form of nested array that was provided. Individual\n/// extension values can be assigned a precedence to override this.\n/// Extensions that do not have a precedence set get the precedence of\n/// the nearest parent with a precedence, or\n/// [`\"default\"`](#state.Precedence) if there is no such parent. The\n/// final ordering of extensions is determined by first sorting by\n/// precedence and then by order within each precedence.\nfunction precedence(extension, value) {\n    if (!Prec.hasOwnProperty(value))\n        throw new RangeError(`Invalid precedence: ${value}`);\n    return new PrecExtension(extension, Prec[value]);\n}\nfunction maybePrec(prec, ext) {\n    return prec ? precedence(ext, prec) : ext;\n}\nclass PrecExtension {\n    constructor(e, prec) {\n        this.e = e;\n        this.prec = prec;\n    }\n}\nclass TaggedExtension {\n    constructor(tag, extension) {\n        this.tag = tag;\n        this.extension = extension;\n    }\n}\n/// Tagged extensions can be used to make a configuration dynamic.\n/// Tagging an extension allows you to later\n/// [replace](#state.TransactionSpec.reconfigure) it with\n/// another extension. A given tag may only occur once within a given\n/// configuration.\nfunction tagExtension(tag, extension) {\n    return new TaggedExtension(tag, extension);\n}\nclass Configuration {\n    constructor(source, replacements, dynamicSlots, address, staticValues) {\n        this.source = source;\n        this.replacements = replacements;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < dynamicSlots.length)\n            this.statusTemplate.push(0 /* Uninitialized */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(extension, replacements = Object.create(null), oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        for (let ext of flatten(extension, replacements)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            if (providers.every(p => p.type == 0 /* Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                let value = facet.combine(providers.map(p => p.value));\n                let oldAddr = oldState ? oldState.config.address[facet.id] : null;\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (facet.compare(value, oldVal))\n                        value = oldVal;\n                }\n                staticValues.push(value);\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        return new Configuration(extension, replacements, dynamicSlots.map(f => f(address)), address, staticValues);\n    }\n}\nfunction allKeys(obj) {\n    return (Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(obj) : []).concat(Object.keys(obj));\n}\nfunction flatten(extension, replacements) {\n    let result = [[], [], [], []];\n    let seen = new Map();\n    let tagsSeen = Object.create(null);\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known >= prec)\n                return;\n            let found = result[known].indexOf(ext);\n            if (found > -1)\n                result[known].splice(found, 1);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof TaggedExtension) {\n            if (ext.tag in tagsSeen)\n                throw new RangeError(`Duplicate use of tag '${String(ext.tag)}' in extensions`);\n            tagsSeen[ext.tag] = true;\n            inner(replacements[ext.tag] || ext.extension, prec);\n        }\n        else if (ext.extension) {\n            inner(ext.extension, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.e, ext.prec);\n        }\n        else {\n            result[prec].push(ext);\n            if (ext instanceof StateField)\n                inner(ext.facets, prec);\n        }\n    }\n    inner(extension, Prec.default);\n    for (let key of allKeys(replacements))\n        if (!(key in tagsSeen) && key != \"full\" && replacements[key]) {\n            tagsSeen[key] = true;\n            inner(replacements[key], Prec.default);\n        }\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* Computed */)\n        return status;\n    state.status[idx] = 4 /* Computing */;\n    let changed = state.config.dynamicSlots[idx](state, state.applying);\n    return state.status[idx] = 2 /* Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst languageData = Facet.define();\nconst allowMultipleSelections = Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nconst lineSeparator = Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = Facet.define();\nconst transactionFilter = Facet.define();\nconst transactionExtender = Facet.define();\n\n/// Annotations are tagged values that are used to add metadata to\n/// transactions in an extensible way. They should be used to model\n/// things that effect the entire transaction (such as its [time\n/// stamp](#state.Transaction^time) or information about its\n/// [origin](#state.Transaction^userEvent)). For effects that happen\n/// _alongside_ the other changes made by the transaction, [state\n/// effects](#state.StateEffect) are more appropriate.\nclass Annotation {\n    /// @internal\n    constructor(type, value) {\n        this.type = type;\n        this.value = value;\n    }\n    /// Define a new type of annotation.\n    static define() { return new AnnotationType(); }\n}\n/// Marker that identifies a type of [annotation](#state.Annotation).\nclass AnnotationType {\n    of(value) { return new Annotation(this, value); }\n}\n/// State effects can be used to represent additional effects\n/// associated with a [transaction](#state.Transaction.effects). They\n/// are often useful to model changes to custom [state\n/// fields](#state.StateField), when those changes aren't implicit in\n/// document or selection changes.\nclass StateEffect {\n    /// @internal\n    constructor(\n    /// @internal\n    type, \n    /// The value of this effect.\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /// Map this effect through a position mapping. Will return\n    /// `undefined` when that ends up deleting the effect.\n    map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /// Tells you whether this effect object is of a given\n    /// [type](#state.StateEffectType).\n    is(type) { return this.type == type; }\n    /// Define a new effect type. The type parameter indicates the type\n    /// of values that his effect holds.\n    static define(spec = {}) {\n        return new StateEffectType(spec.map || (v => v));\n    }\n    /// Map an array of effects through a change set.\n    static mapEffects(effects, mapping) {\n        if (!effects.length)\n            return effects;\n        let result = [];\n        for (let effect of effects) {\n            let mapped = effect.map(mapping);\n            if (mapped)\n                result.push(mapped);\n        }\n        return result;\n    }\n}\n/// Representation of a type of state effect. Defined with\n/// [`StateEffect.define`](#state.StateEffect^define).\nclass StateEffectType {\n    /// @internal\n    constructor(\n    // The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /// @internal\n    map) {\n        this.map = map;\n    }\n    /// Create a [state effect](#state.StateEffect) instance of this\n    /// type.\n    of(value) { return new StateEffect(this, value); }\n}\n/// Changes to the editor state are grouped into transactions.\n/// Typically, a user action creates a single transaction, which may\n/// contain any number of document changes, may change the selection,\n/// or have other effects. Create a transaction by calling\n/// [`EditorState.update`](#state.EditorState.update).\nclass Transaction {\n    /// @internal\n    constructor(\n    /// The state from which the transaction starts.\n    startState, \n    /// The document changes made by this transaction.\n    changes, \n    /// The selection set by this transaction, or undefined if it\n    /// doesn't explicitly set a selection.\n    selection, \n    /// The effects added to the transaction.\n    effects, \n    /// @internal\n    annotations, \n    /// Holds an object when this transaction\n    /// [reconfigures](#state.ReconfigurationSpec) the state.\n    reconfigure, \n    /// Whether the selection should be scrolled into view after this\n    /// transaction is dispatched.\n    scrollIntoView) {\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.reconfigure = reconfigure;\n        this.scrollIntoView = scrollIntoView;\n        /// @internal\n        this._doc = null;\n        /// @internal\n        this._state = null;\n        if (selection)\n            checkSelection(selection, changes.newLength);\n        if (!annotations.some((a) => a.type == Transaction.time))\n            this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /// The new document produced by the transaction. (Mostly exposed so\n    /// that [transaction filters](#state.EditorState^transactionFilter)\n    /// can look at the new document without forcing an entire new state\n    /// to be computed by accessing\n    /// [`.state`](#state.Transaction.state).\n    get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /// The new selection produced by the transaction. If\n    /// [`this.selection`](#state.Transaction.selection) is undefined,\n    /// this will [map](#state.EditorSelection.map) the start state's\n    /// current selection through the changes made by the transaction.\n    get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /// The new state created by the transaction.\n    get state() {\n        if (!this._state)\n            this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /// Get the value of the given annotation type, if any.\n    annotation(type) {\n        for (let ann of this.annotations)\n            if (ann.type == type)\n                return ann.value;\n        return undefined;\n    }\n    /// Indicates whether the transaction changed the document.\n    get docChanged() { return !this.changes.empty; }\n}\n/// Annotation used to store transaction timestamps.\nTransaction.time = Annotation.define();\n/// Annotation used to associate a transaction with a user interface\n/// event. The view will set this to...\n///\n///  - `\"input\"` when the user types text\n///  - `\"delete\"` when the user deletes the selection or text near the selection\n///  - `\"keyboardselection\"` when moving the selection via the keyboard\n///  - `\"pointerselection\"` when moving the selection through the pointing device\n///  - `\"paste\"` when pasting content\n///  - `\"cut\"` when cutting\n///  - `\"drop\"` when content is inserted via drag-and-drop\nTransaction.userEvent = Annotation.define();\n/// Annotation indicating whether a transaction should be added to\n/// the undo history or not.\nTransaction.addToHistory = Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for (let iA = 0, iB = 0;;) {\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        }\n        else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        }\n        else\n            return result;\n        if (!result.length || result[result.length - 1] < from)\n            result.push(from, to);\n        else if (result[result.length - 1] < to)\n            result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    }\n    else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView,\n        reconfigure: !b.reconfigure ? a.reconfigure : b.reconfigure.full || !a.reconfigure ? b.reconfigure\n            : Object.assign({}, a.reconfigure, b.reconfigure)\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let reconf = spec.reconfigure;\n    if (reconf && reconf.append) {\n        reconf = Object.assign({}, reconf);\n        let tag = typeof Symbol == \"undefined\" ? \"__append\" + Math.floor(Math.random() * 0xffffffff) : Symbol(\"appendConf\");\n        reconf[tag] = reconf.append;\n        reconf.append = undefined;\n    }\n    let sel = spec.selection;\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes\n            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations: asArray(spec.annotations),\n        scrollIntoView: !!spec.scrollIntoView,\n        reconfigure: reconf\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false)\n        filter = false;\n    for (let i = 1; i < specs.length; i++) {\n        if (specs[i].filter === false)\n            filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.reconfigure, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)) {\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value))\n            result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        }\n        else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.invertedDesc;\n        }\n        tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.reconfigure, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for (let i = filters.length - 1; i >= 0; i--) {\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction)\n            tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)\n            tr = filtered[0];\n        else\n            tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for (let i = extenders.length - 1; i >= 0; i--) {\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length)\n            spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.reconfigure, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/// This is used to [categorize](#state.EditorState.charCategorizer)\n/// characters into three categories—word characters, whitespace, and\n/// anything else. It is used do things like selecting by word.\nvar CharCategory;\n(function (CharCategory) {\n    CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n})(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) { }\nfunction hasWordChar(str) {\n    if (wordChar)\n        return wordChar.test(str);\n    for (let i = 0; i < str.length; i++) {\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))\n            return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char) => {\n        if (!/\\S/.test(char))\n            return CharCategory.Space;\n        if (hasWordChar(char))\n            return CharCategory.Word;\n        for (let i = 0; i < wordChars.length; i++)\n            if (char.indexOf(wordChars[i]) > -1)\n                return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n\n/// The editor state class is a persistent (immutable) data structure.\n/// To update a state, you [create](#state.EditorState.update) a\n/// [transaction](#state.Transaction), which produces a _new_ state\n/// instance, without modifying the original object.\n///\n/// As such, _never_ mutate properties of a state directly. That'll\n/// just break things.\nclass EditorState {\n    /// @internal\n    constructor(\n    /// @internal\n    config, \n    /// The current document.\n    doc, \n    /// The current selection.\n    selection, tr = null) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        /// @internal\n        this.applying = null;\n        this.status = config.statusTemplate.slice();\n        if (tr && !tr.reconfigure) {\n            this.values = tr.startState.values.slice();\n        }\n        else {\n            this.values = config.dynamicSlots.map(_ => null);\n            // Copy over old values for shared facets/fields if this is a reconfigure\n            if (tr)\n                for (let id in config.address) {\n                    let cur = config.address[id], prev = tr.startState.config.address[id];\n                    if (prev != null && (cur & 1) == 0)\n                        this.values[cur >> 1] = getAddr(tr.startState, prev);\n                }\n        }\n        this.applying = tr;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr)\n            tr._state = this;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.applying = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Create a [transaction](#state.Transaction) that updates this\n    /// state. Any number of [transaction specs](#state.TransactionSpec)\n    /// can be passed. The [changes](#state.TransactionSpec.changes) (if\n    /// any) of each spec are assumed to start in the _current_ document\n    /// (not the document produced by previous specs), and its\n    /// [selection](#state.TransactionSpec.selection) and\n    /// [effects](#state.TransactionSpec.effects) are assumed to refer\n    /// to the document created by its _own_ changes. The resulting\n    /// transaction contains the combined effect of all the different\n    /// specs. For things like\n    /// [selection](#state.TransactionSpec.selection) or\n    /// [reconfiguration](#state.TransactionSpec.reconfigure), later\n    /// specs take precedence over earlier ones.\n    update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /// @internal\n    applyTransaction(tr) {\n        let conf = this.config;\n        if (tr.reconfigure)\n            conf = Configuration.resolve(tr.reconfigure.full || conf.source, Object.assign(conf.replacements, tr.reconfigure, { full: undefined }), this);\n        new EditorState(conf, tr.newDoc, tr.newSelection, tr);\n    }\n    /// Create a [transaction spec](#state.TransactionSpec) that\n    /// replaces every selection range with the given content.\n    replaceSelection(text) {\n        if (typeof text == \"string\")\n            text = this.toText(text);\n        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },\n            range: EditorSelection.cursor(range.from + text.length) }));\n    }\n    /// Create a set of changes and a new selection by running the given\n    /// function for each range in the active selection. The function\n    /// can return an optional set of changes (in the coordinate space\n    /// of the start document), plus an updated range (in the coordinate\n    /// space of the document produced by the call's own changes). This\n    /// method will merge all the changes and ranges into a single\n    /// changeset and selection, and return it as a [transaction\n    /// spec](#state.TransactionSpec), which can be passed to\n    /// [`update`](#state.EditorState.update).\n    changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [result1.range];\n        let effects = asArray(result1.effects);\n        for (let i = 1; i < sel.ranges.length; i++) {\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for (let j = 0; j < i; j++)\n                ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.primaryIndex),\n            effects\n        };\n    }\n    /// Create a [change set](#state.ChangeSet) from the given change\n    /// description, taking the state's document length and line\n    /// separator into account.\n    changes(spec = []) {\n        if (spec instanceof ChangeSet)\n            return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /// Using the state's [line\n    /// separator](#state.EditorState^lineSeparator), create a\n    /// [`Text`](#text.Text) instance from the given string.\n    toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /// Return the given range of the document as a string.\n    sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /// Get the value of a state [facet](#state.Facet).\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Convert this state to a JSON-serializable object.\n    toJSON() {\n        // FIXME plugin state serialization\n        return {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n    }\n    /// Deserialize a state from its JSON representation.\n    static fromJSON(json, config = {}) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions\n        });\n    }\n    /// Create a new state. You'll usually only need this when\n    /// initializing an editor—updated states are created by applying\n    /// transactions.\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || []);\n        let doc = config.doc instanceof Text ? config.doc\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0)\n            : config.selection instanceof EditorSelection ? config.selection\n                : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection);\n    }\n    /// The size (in columns) of a tab in the document, determined by\n    /// the [`tabSize`](#state.EditorState^tabSize) facet.\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /// Get the proper [line-break](#state.EditorState^lineSeparator)\n    /// string for this state.\n    get lineBreak() { return this.facet(EditorState.lineSeparator) || \"\\n\"; }\n    /// Look up a translation for the given phrase (via the\n    /// [`phrases`](#state.EditorState^phrases) facet), or return the\n    /// original string if no translation is found.\n    phrase(phrase) {\n        for (let map of this.facet(EditorState.phrases))\n            if (Object.prototype.hasOwnProperty.call(map, phrase))\n                return map[phrase];\n        return phrase;\n    }\n    /// Find the values for a given language data field, provided by the\n    /// the [`languageData`](#state.EditorState^languageData) facet.\n    languageDataAt(name, pos) {\n        let values = [];\n        for (let provider of this.facet(languageData)) {\n            for (let result of provider(this, pos)) {\n                if (Object.prototype.hasOwnProperty.call(result, name))\n                    values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /// Return a function that can categorize strings (expected to\n    /// represent a single [grapheme cluster](#text.nextClusterBreak))\n    /// into one of:\n    ///\n    ///  - Word (contains an alphanumeric character or a character\n    ///    explicitly listed in the local language's `\"wordChars\"`\n    ///    language data, which should be a string)\n    ///  - Space (contains only whitespace)\n    ///  - Other (anything else)\n    charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n}\n/// A facet that, when enabled, causes the editor to allow multiple\n/// ranges to be selected. Be careful though, because by default the\n/// editor relies on the native DOM selection, which cannot handle\n/// multiple selections. An extension like\n/// [`drawSelection`](#view.drawSelection) can be used to make\n/// secondary selections visible to the user.\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/// Configures the tab size to use in this state. The first\n/// (highest-precedence) value of the facet is used. If no value is\n/// given, this defaults to 4.\nEditorState.tabSize = Facet.define({\n    combine: values => values.length ? values[0] : 4\n});\n/// The line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\n/// and `\"\\r\"` is treated as a separator when splitting lines, and\n/// lines are joined with `\"\\n\"`.\n///\n/// When you configure a value here, only that precise separator\n/// will be used, allowing you to round-trip documents through the\n/// editor without normalizing line separators.\nEditorState.lineSeparator = lineSeparator;\n/// Registers translation phrases. The\n/// [`phrase`](#state.EditorState.phrase) method will look through\n/// all objects registered with this facet to find translations for\n/// its argument.\nEditorState.phrases = Facet.define();\n/// A facet used to register [language\n/// data](#state.EditorState.languageDataAt) providers.\nEditorState.languageData = languageData;\n/// Facet used to register change filters, which are called for each\n/// transaction (unless explicitly\n/// [disabled](#state.TransactionSpec.filter)), and can suppress\n/// part of the transaction's changes.\n///\n/// Such a function can return `true` to indicate that it doesn't\n/// want to do anything, `false` to completely stop the changes in\n/// the transaction, or a set of ranges in which changes should be\n/// suppressed. Such ranges are represented as an array of numbers,\n/// with each pair of two number indicating the start and end of a\n/// range. So for example `[10, 20, 100, 110]` suppresses changes\n/// between 10 and 20, and between 100 and 110.\nEditorState.changeFilter = changeFilter;\n/// Facet used to register a hook that gets a chance to update or\n/// replace transaction specs before they are applied. This will\n/// only be applied for transactions that don't have\n/// [`filter`](#state.TransactionSpec.filter) set to `false`. You\n/// can either return a single (possibly the input transaction), or\n/// an array of specs (which will be combined in the same way as the\n/// arguments to [`EditorState.update`](#state.EditorState.update)).\n///\n/// When possible, it is recommended to avoid accessing\n/// [`Transaction.state`](#state.Transaction.state) in a filter,\n/// since it will force creation of a state that will then be\n/// discarded again, if the transaction is actually filtered.\n///\n/// (This functionality should be used with care. Indiscriminately\n/// modifying transaction is likely to break something or degrade\n/// the user experience.)\nEditorState.transactionFilter = transactionFilter;\n/// This is a more limited form of\n/// [`transactionFilter`](#state.EditorState^transactionFilter),\n/// which can only add\n/// [annotations](#state.TransactionSpec.annotations),\n/// [effects](#state.TransactionSpec.effects), and\n/// [configuration](#state.TransactionSpec.reconfigure) info. _But_,\n/// this type of filter runs even the transaction has disabled\n/// regular [filtering](#state.TransactionSpec.filter), making it\n/// suitable for effects that don't need to touch the changes or\n/// selection, but do want to process every transaction.\n///\n/// Extenders run _after_ filters, when both are applied.\nEditorState.transactionExtender = transactionExtender;\n\n/// Utility function for combining behaviors to fill in a config\n/// object from an array of provided configs. Will, by default, error\n/// when a field gets two values that aren't ===-equal, but you can\n/// provide combine functions per field to do something else.\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\nexport { Annotation, AnnotationType, ChangeDesc, ChangeSet, CharCategory, EditorSelection, EditorState, Facet, MapMode, SelectionRange, StateEffect, StateEffectType, StateField, Transaction, combineConfig, precedence, tagExtension };\n","// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++)\n    extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for (let i = 1; i < extend.length; i += 2)\n        if (extend[i] > code)\n            return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/// Returns a grapheme cluster end _after_ (not equal to) `pos`, if\n/// possible. Moves across surrogate pairs, extending characters,\n/// characters joined with zero-width joiners, and flag emoji.\nfunction nextClusterBreak(str, pos) {\n    if (pos == str.length)\n        return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))\n        pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while (pos < str.length) {\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        }\n        else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0)\n                break;\n            else\n                pos += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return pos;\n}\n/// Returns a grapheme cluster end _before_ `pos`, if possible.\nfunction prevClusterBreak(str, pos) {\n    while (pos > 0) {\n        let found = nextClusterBreak(str, pos - 2);\n        if (found < pos)\n            return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/// Find the code point at the given position in a string (as in the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (as in\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint).\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nfunction countColumn(string, n, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = nextClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nfunction findColumn(string, n, col, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (n >= col)\n            return { offset: i, leftOver: 0 };\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = nextClusterBreak(string, i);\n    }\n    return { offset: string.length, leftOver: col - n };\n}\n\n/// The document tree type.\nclass Text {\n    /// @internal\n    constructor() { }\n    /// Get the line description around the given position.\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        for (let line of lineCache) {\n            if (line.doc == this && line.from <= pos && line.to >= pos)\n                return line;\n        }\n        return cacheLine(this.lineInner(pos, false, 1, 0).finish(this));\n    }\n    /// Get the description for the given (1-based) line number.\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        for (let line of lineCache) {\n            if (line.doc == this && line.number == n)\n                return line;\n        }\n        return cacheLine(this.lineInner(n, true, 1, 0).finish(this));\n    }\n    /// Replace a range of the text with the given lines. `text` should\n    /// have a length of at least one.\n    replace(from, to, text) {\n        let parts = [];\n        this.decompose(0, from, parts);\n        parts.push(text);\n        this.decompose(to, this.length, parts);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /// Append another document to this one.\n    append(text) {\n        return this.length == 0 ? text : text.length == 0 ? this : TextNode.from([this, text], this.length + text.length);\n    }\n    /// Retrieve the text between the given points.\n    slice(from, to = this.length) {\n        let parts = [];\n        this.decompose(from, to, parts);\n        return TextNode.from(parts, to - from);\n    }\n    /// Test whether this text is equal to another instance.\n    eq(other) { return this == other || eqContent(this, other); }\n    /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /// Iterate over lines in the text, starting at position (_not_ line\n    /// number) `from`. An iterator returned by this combines all text\n    /// on a line into a single string (which may be expensive for very\n    /// long lines), and skips line breaks (its\n    /// [`lineBreak`](#text.TextIterator.lineBreak) property is always\n    /// false).\n    iterLines(from = 0) { return new LineCursor(this, from); }\n    /// @internal\n    toString() { return this.sliceString(0); }\n    /// Convert the document to an array of lines (which can be\n    /// deserialized again via [`Text.of`](#text.Text^of).\n    toJSON() {\n        let lines = [];\n        for (let iter = this.iterLines(); !iter.next().done;)\n            lines.push(iter.value);\n        return lines;\n    }\n    /// Create a `Text` instance for the given array of lines.\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0] && Text.empty)\n            return Text.empty;\n        let length = textLength(text);\n        return length < 1024 /* MaxLeaf */ ? new TextLeaf(text, length) : TextNode.from(TextLeaf.split(text, []), length);\n    }\n}\nif (typeof Symbol != \"undefined\")\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\nlet lineCache = [], lineCachePos = -1, lineCacheSize = 10;\nfunction cacheLine(line) {\n    return lineCache[lineCachePos = (lineCachePos + 1) % lineCacheSize] = line;\n}\n// Leaves store an array of strings. There are always line breaks\n// between these strings (though not between adjacent Text nodes).\n// These are limited in length, so that bigger documents are\n// constructed as a tree structure. Long lines will be broken into a\n// number of single-line leaves.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target) {\n        target.push(new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from)));\n    }\n    lastLineLength() { return this.text[this.text.length - 1].length; }\n    firstLineLength() { return this.text[0].length; }\n    replace(from, to, text) {\n        let newLen = this.length + text.length - (to - from);\n        if (newLen >= 1024 /* MaxLeaf */ || !(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        return new TextLeaf(appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        target[target.length - 1] += this.text[0];\n        for (let i = 1; i < this.text.length; i++)\n            target.push(this.text[i]);\n    }\n    static split(text, target) {\n        let part = [], length = -1;\n        for (let line of text) {\n            for (;;) {\n                let newLength = length + line.length + 1;\n                if (newLength < 512 /* BaseLeaf */) {\n                    length = newLength;\n                    part.push(line);\n                    break;\n                }\n                let cut = 512 /* BaseLeaf */ - length - 1, after = line.charCodeAt(cut);\n                if (after >= 0xdc00 && after < 0xe000)\n                    cut++;\n                part.push(line.slice(0, cut));\n                target.push(new TextLeaf(part, 512 /* BaseLeaf */));\n                line = line.slice(cut);\n                length = -1;\n                part = [];\n            }\n        }\n        if (length != -1)\n            target.push(new TextLeaf(part, length));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance itself on\n// changes.\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 1;\n        for (let child of children)\n            this.lines += child.lines - 1;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) {\n                let inner = child.lineInner(target, isLine, line, offset), add;\n                if (inner.from == offset && (add = this.lineLengthTo(i))) {\n                    inner.from -= add;\n                    inner.content = null;\n                }\n                if (inner.to == end && (add = this.lineLengthFrom(i + 1))) {\n                    inner.to += add;\n                    inner.content = null;\n                }\n                return inner;\n            }\n            offset = end;\n            line = endLine;\n        }\n    }\n    decompose(from, to, target) {\n        for (let i = 0, pos = 0; pos < to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from < end && to > pos) {\n                if (pos >= from && end <= to)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target);\n            }\n            pos = end;\n        }\n    }\n    lineLengthTo(to) {\n        let length = 0;\n        for (let i = to - 1; i >= 0; i--) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.lastLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    lastLineLength() { return this.lineLengthTo(this.children.length); }\n    lineLengthFrom(from) {\n        let length = 0;\n        for (let i = from; i < this.children.length; i++) {\n            let child = this.children[i];\n            if (child.lines > 1)\n                return length + child.firstLineLength();\n            length += child.length;\n        }\n        return length;\n    }\n    firstLineLength() { return this.lineLengthFrom(0); }\n    replace(from, to, text) {\n        // Looks like a small change, try to optimize\n        if (text.length < 512 /* BaseLeaf */ && to - from < 512 /* BaseLeaf */) {\n            let lengthDiff = text.length - (to - from);\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end &&\n                    child.length + lengthDiff < (this.length + lengthDiff) >> (3 /* BranchShift */ - 1) &&\n                    child.length + lengthDiff > 0) {\n                    let copy = this.children.slice();\n                    copy[i] = child.replace(from - pos, to - pos, text);\n                    return new TextNode(copy, this.length + lengthDiff);\n                }\n                pos = end;\n            }\n        }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let i = 0, pos = 0; pos < to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from < end && to > pos) {\n                let part = child.sliceString(from - pos, to - pos, lineSep);\n                if (from >= pos && to <= end)\n                    return part;\n                result += part;\n            }\n            pos = end;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    static from(children, length) {\n        if (!children.every(ch => ch instanceof Text))\n            throw new Error(\"NOP\");\n        if (length < 1024 /* MaxLeaf */) {\n            let text = [\"\"];\n            for (let child of children)\n                child.flatten(text);\n            return new TextLeaf(text, length);\n        }\n        let chunkLength = Math.max(512 /* BaseLeaf */, length >> 3 /* BranchShift */), maxLength = chunkLength << 1, minLength = chunkLength >> 1;\n        let chunked = [], currentLength = 0, currentChunk = [];\n        function add(child) {\n            let childLength = child.length, last;\n            if (!childLength)\n                return;\n            if (childLength > maxLength && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (childLength > minLength && (currentLength > minLength || currentLength == 0)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLength > 0 &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.length + last.length <= 512 /* BaseLeaf */) {\n                currentLength += childLength;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(appendText(child.text, last.text.slice()), child.length + last.length);\n            }\n            else {\n                if (currentLength + childLength > chunkLength)\n                    flush();\n                currentLength += childLength;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLength == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLength));\n            currentLength = 0;\n            currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = Text.of([\"\"]);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nfunction eqContent(a, b) {\n    if (a.length != b.length || a.lines != b.lines)\n        return false;\n    let iterA = new RawTextCursor(a), iterB = new RawTextCursor(b);\n    for (let offA = 0, offB = 0;;) {\n        if (iterA.lineBreak != iterB.lineBreak || iterA.done != iterB.done) {\n            return false;\n        }\n        else if (iterA.done) {\n            return true;\n        }\n        else if (iterA.lineBreak) {\n            iterA.next();\n            iterB.next();\n            offA = offB = 0;\n        }\n        else {\n            let strA = iterA.value.slice(offA), strB = iterB.value.slice(offB);\n            if (strA.length == strB.length) {\n                if (strA != strB)\n                    return false;\n                iterA.next();\n                iterB.next();\n                offA = offB = 0;\n            }\n            else if (strA.length > strB.length) {\n                if (strA.slice(0, strB.length) != strB)\n                    return false;\n                offA += strB.length;\n                iterB.next();\n                offB = 0;\n            }\n            else {\n                if (strB.slice(0, strA.length) != strA)\n                    return false;\n                offB += strA.length;\n                iterA.next();\n                offA = 0;\n            }\n        }\n    }\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n    }\n    next(skip = 0) {\n        for (;;) {\n            let last = this.nodes.length - 1;\n            if (last < 0) {\n                this.done = true;\n                this.value = \"\";\n                this.lineBreak = false;\n                return this;\n            }\n            let top = this.nodes[last];\n            let offset = this.offsets[last];\n            if (top instanceof TextLeaf) {\n                // Internal offset with lineBreak == false means we have to\n                // count the line break at this position\n                if (offset != (this.dir > 0 ? 0 : top.text.length) && !this.lineBreak) {\n                    this.lineBreak = true;\n                    if (skip == 0) {\n                        this.value = \"\\n\";\n                        return this;\n                    }\n                    skip--;\n                    continue;\n                }\n                // Otherwise, move to the next string\n                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n                this.offsets[last] = (offset += this.dir);\n                if (offset == (this.dir > 0 ? top.text.length : 0)) {\n                    this.nodes.pop();\n                    this.offsets.pop();\n                }\n                this.lineBreak = false;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else if (offset == (this.dir > 0 ? top.children.length : 0)) {\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else {\n                let next = top.children[this.dir > 0 ? offset : offset - 1], len = next.length;\n                this.offsets[last] = offset + this.dir;\n                if (skip > len) {\n                    skip -= len;\n                }\n                else {\n                    this.nodes.push(next);\n                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n                }\n            }\n        }\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        if (start > end) {\n            this.skip = text.length - start;\n            this.limit = start - end;\n        }\n        else {\n            this.skip = start;\n            this.limit = end - start;\n        }\n    }\n    next() {\n        if (this.limit <= 0) {\n            this.limit = -1;\n        }\n        else {\n            let { value, lineBreak, done } = this.cursor.next(this.skip);\n            this.skip = 0;\n            this.value = value;\n            let len = lineBreak ? 1 : value.length;\n            if (len > this.limit)\n                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n            if (done || this.value.length == 0)\n                this.limit = -1;\n            else\n                this.limit -= this.value.length;\n        }\n        return this;\n    }\n    get lineBreak() { return this.cursor.lineBreak; }\n    get done() { return this.limit < 0; }\n}\nclass LineCursor {\n    constructor(text, from = 0) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = text.iter();\n        this.skip = from;\n    }\n    next(skip = 0) {\n        if (this.cursor.done) {\n            this.done = true;\n            this.value = \"\";\n            return this;\n        }\n        skip += this.skip;\n        this.skip = 0;\n        for (this.value = \"\";;) {\n            let { value, lineBreak, done } = this.cursor.next(skip);\n            skip = 0;\n            if (done || lineBreak)\n                return this;\n            this.value += value;\n        }\n    }\n    get lineBreak() { return false; }\n}\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nclass Line {\n    /// @internal\n    constructor(\n    /// The position of the start of the line.\n    from, \n    /// The position at the end of the line (_before_ the line break,\n    /// if this isn't the last line).\n    to, \n    /// This line's line number (1-based).\n    number, \n    /// @internal\n    content) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.content = content;\n    }\n    /// The length of the line (not including any line break after it).\n    get length() { return this.to - this.from; }\n    /// Retrieve a part of the content of this line. This is a method,\n    /// rather than, say, a string property, to avoid concatenating long\n    /// lines whenever they are accessed. Try to write your code, if it\n    /// is going to be doing a lot of line-reading, to read only the\n    /// parts it needs.\n    slice(from = 0, to = this.length) {\n        if (from == to)\n            return \"\";\n        if (typeof this.content == \"string\")\n            return this.content.slice(from, to);\n        if (!this.content)\n            this.content = new LineContent(this.doc, this.from);\n        let result = this.content.slice(from, to);\n        if (from == 0 && to == this.length)\n            this.content = result;\n        return result;\n    }\n    /// @internal\n    finish(text) {\n        this.doc = text;\n        return this;\n    }\n    /// Find the next (or previous if `forward` is false) grapheme\n    /// cluster break from the given start position (as an offset inside\n    /// the line, not the document). Will return a position greater than\n    /// (or less than if `forward` is false) `start` unless there is no\n    /// such index in the string.\n    findClusterBreak(start, forward) {\n        if (start < 0 || start > this.length)\n            throw new RangeError(\"Invalid position given to Line.findClusterBreak\");\n        let contextStart, context;\n        if (this.content == \"string\") {\n            contextStart = this.from;\n            context = this.content;\n        }\n        else {\n            contextStart = Math.max(0, start - 256);\n            context = this.slice(contextStart, Math.min(this.length, contextStart + 512));\n        }\n        return (forward ? nextClusterBreak : prevClusterBreak)(context, start - contextStart) + contextStart;\n    }\n}\nclass LineContent {\n    constructor(doc, start) {\n        this.doc = doc;\n        this.start = start;\n        this.cursor = null;\n        this.strings = null;\n    }\n    // FIXME quadratic complexity (somewhat) when iterating long lines in small pieces\n    slice(from, to) {\n        if (!this.cursor) {\n            this.cursor = this.doc.iter();\n            this.strings = [this.cursor.next(this.start).value];\n        }\n        for (let result = \"\", pos = 0, i = 0;; i++) {\n            if (i == this.strings.length) {\n                let next = this.cursor.next().value;\n                if (!next)\n                    return result;\n                this.strings.push(next);\n            }\n            let string = this.strings[i], start = pos;\n            pos += string.length;\n            if (pos <= from)\n                continue;\n            result += string.slice(Math.max(0, from - start), Math.min(string.length, to - start));\n            if (pos >= to)\n                return result;\n        }\n    }\n}\n\nexport { Line, Text, codePointAt, codePointSize, countColumn, findColumn, fromCodePoint, nextClusterBreak, prevClusterBreak };\n","import { ViewPlugin, themeClass, Direction, EditorView } from '@codemirror/next/view';\nimport { Facet, StateEffect, StateField, MapMode } from '@codemirror/next/state';\n\nconst Outside = \"-10000px\";\nconst tooltipPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.inView = true;\n        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };\n        this.tooltips = view.state.facet(showTooltip);\n        this.tooltipViews = this.tooltips.map(tp => this.createTooltip(tp));\n    }\n    update(update) {\n        let tooltips = update.state.facet(showTooltip);\n        if (tooltips == this.tooltips) {\n            for (let t of this.tooltipViews)\n                if (t.update)\n                    t.update(update);\n        }\n        else {\n            let views = [];\n            for (let i = 0; i < tooltips.length; i++) {\n                let tip = tooltips[i], known = -1;\n                for (let i = 0; i < this.tooltips.length; i++)\n                    if (this.tooltips[i].create == tip.create)\n                        known = i;\n                if (known < 0) {\n                    views[i] = this.createTooltip(tip);\n                }\n                else {\n                    let tooltipView = views[i] = this.tooltipViews[known];\n                    if (tooltipView.update)\n                        tooltipView.update(update);\n                }\n            }\n            for (let t of this.tooltipViews)\n                if (views.indexOf(t) < 0)\n                    t.dom.remove();\n            this.tooltips = tooltips;\n            this.tooltipViews = views;\n            this.maybeMeasure();\n        }\n    }\n    createTooltip(tooltip) {\n        let tooltipView = tooltip.create(this.view);\n        tooltipView.dom.className = themeClass(\"tooltip\" + (tooltip.style ? \".\" + tooltip.style : \"\"));\n        this.view.dom.appendChild(tooltipView.dom);\n        if (tooltipView.mount)\n            tooltipView.mount(this.view);\n        return tooltipView;\n    }\n    destroy() {\n        for (let { dom } of this.tooltipViews)\n            dom.remove();\n    }\n    readMeasure() {\n        return {\n            editor: this.view.dom.getBoundingClientRect(),\n            pos: this.tooltips.map(t => this.view.coordsAtPos(t.pos)),\n            size: this.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),\n            innerWidth: window.innerWidth,\n            innerHeight: window.innerHeight\n        };\n    }\n    writeMeasure(measured) {\n        let { editor } = measured;\n        for (let i = 0; i < this.tooltipViews.length; i++) {\n            let tooltip = this.tooltips[i], tView = this.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let width = size.right - size.left, height = size.bottom - size.top;\n            let left = this.view.textDirection == Direction.LTR ? Math.min(pos.left, measured.innerWidth - width)\n                : Math.max(0, pos.left - width);\n            let above = !!tooltip.above;\n            if (!tooltip.strictSide &&\n                (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))\n                above = !above;\n            dom.style.top = (above ? pos.top - height : pos.bottom) + \"px\";\n            dom.style.left = left + \"px\";\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned)\n                tView.positioned();\n        }\n    }\n    maybeMeasure() {\n        if (this.tooltips.length) {\n            if (this.view.inView || this.inView)\n                this.view.requestMeasure(this.measureReq);\n            this.inView = this.view.inView;\n        }\n    }\n}, {\n    eventHandlers: {\n        scroll() { this.maybeMeasure(); }\n    }\n});\nconst baseTheme = EditorView.baseTheme({\n    $tooltip: {\n        position: \"fixed\",\n        border: \"1px solid #ddd\",\n        backgroundColor: \"#f5f5f5\",\n        zIndex: 100\n    }\n});\n/// Supporting extension for displaying tooltips. Allows\n/// [`showTooltip`](#tooltip.showTooltip) to be used to define\n/// tooltips.\nfunction tooltips() {\n    return [tooltipPlugin, baseTheme];\n}\n/// Behavior by which an extension can provide a tooltip to be shown.\nconst showTooltip = Facet.define();\nconst HoverTime = 750, HoverMaxDist = 10;\nclass HoverPlugin {\n    constructor(view, source, field, setHover) {\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.lastMouseMove = null;\n        this.hoverTimeout = -1;\n        this.mouseInside = false;\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseenter\", this.mouseenter = this.mouseenter.bind(this));\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (!this.mouseInside || this.active)\n            return;\n        let now = Date.now(), lastMove = this.lastMouseMove;\n        if (now - lastMove.timeStamp < HoverTime) {\n            this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));\n            return;\n        }\n        let pos = this.view.contentDOM.contains(lastMove.target)\n            ? this.view.posAtCoords({ x: lastMove.clientX, y: lastMove.clientY }) : -1;\n        let open = pos == null ? null : this.source(this.view, (from, to) => {\n            return from <= pos && to >= pos && (from == to || isOverRange(this.view, from, to, lastMove.clientX, lastMove.clientY));\n        });\n        if (open)\n            this.view.dispatch({ effects: this.setHover.of(open) });\n    }\n    mousemove(event) {\n        var _a;\n        this.lastMouseMove = event;\n        if (this.hoverTimeout < 0)\n            this.hoverTimeout = setTimeout(this.checkHover, HoverTime);\n        let tooltip = this.active;\n        if (tooltip && !isInTooltip(event.target)) {\n            let { pos } = tooltip, end = (_a = tooltip.end) !== null && _a !== void 0 ? _a : pos;\n            if ((pos == end ? this.view.posAtCoords({ x: event.clientX, y: event.clientY }) != pos\n                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist)))\n                this.view.dispatch({ effects: this.setHover.of(null) });\n        }\n    }\n    mouseenter() {\n        this.mouseInside = true;\n    }\n    mouseleave() {\n        this.mouseInside = false;\n        if (this.active)\n            this.view.dispatch({ effects: this.setHover.of(null) });\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseenter\", this.mouseenter);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nfunction isInTooltip(elt) {\n    for (let cur = elt; cur; cur = cur.parentNode)\n        if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\"))\n            return true;\n    return false;\n}\nfunction isOverRange(view, from, to, x, y, margin = 0) {\n    let range = document.createRange();\n    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);\n    range.setEnd(toDOM.node, toDOM.offset);\n    range.setStart(fromDOM.node, fromDOM.offset);\n    let rects = range.getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n        if (dist <= margin)\n            return true;\n    }\n    return false;\n}\n/// Enable a hover tooltip, which shows up when the pointer hovers\n/// over ranges of text. The callback should, for each hoverable\n/// range, call its `check` argument to see if that range is being\n/// hovered over, and return a tooltip description when it is.\nfunction hoverTooltip(source, options = {}) {\n    const setHover = StateEffect.define();\n    const hoverState = StateField.define({\n        create() { return null; },\n        update(value, tr) {\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))\n                return null;\n            for (let effect of tr.effects)\n                if (effect.is(setHover))\n                    return effect.value;\n            if (value && tr.docChanged) {\n                let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);\n                if (newPos == null)\n                    return null;\n                let copy = Object.assign(Object.create(null), value);\n                copy.pos = newPos;\n                if (value.end != null)\n                    copy.end = tr.changes.mapPos(value.end);\n                return copy;\n            }\n            return value;\n        },\n        provide: [showTooltip.nFrom(v => v ? [v] : [])]\n    });\n    return [\n        hoverState,\n        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover)),\n        tooltips()\n    ];\n}\n\nexport { hoverTooltip, showTooltip, tooltips };\n","export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","import { MapMode, Facet, Text as Text$1, EditorSelection, ChangeSet, Transaction, CharCategory, EditorState, precedence, combineConfig } from '@codemirror/next/state';\nimport { StyleModule } from 'style-mod';\nimport { RangeValue, RangeSet } from '@codemirror/next/rangeset';\nexport { Range } from '@codemirror/next/rangeset';\nimport { Text, countColumn, findColumn, codePointAt } from '@codemirror/next/text';\nimport { keyName, base } from 'w3c-keyname';\n\nlet [nav, doc] = typeof navigator != \"undefined\"\n    ? [navigator, document]\n    : [{ userAgent: \"\", vendor: \"\", platform: \"\" }, { documentElement: { style: {} } }];\nconst ie_edge = /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nvar browser = {\n    mac: /Mac/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +(/Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios: !ie && /AppleWebKit/.test(nav.userAgent) && /Mobile\\/\\w+/.test(nav.userAgent),\n    android: /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari: /Apple Computer/.test(nav.vendor),\n    webkit_version: webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\n\nfunction getSelection(root) {\n    return (root.getSelection ? root.getSelection() : document.getSelection());\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nfunction selectionCollapsed(domSel) {\n    let collapsed = domSel.isCollapsed;\n    if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n        collapsed = false;\n    return collapsed;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return dom.contains(selection.anchorNode.nodeType == 3 ? selection.anchorNode.parentNode : selection.anchorNode);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) {\n        let range = tempRange();\n        range.setEnd(dom, dom.nodeValue.length);\n        range.setStart(dom, 0);\n        return range.getClientRects();\n    }\n    else if (dom.nodeType == 1) {\n        return dom.getClientRects();\n    }\n    else {\n        return [];\n    }\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\n}\nfunction domIndex(node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\")\n                return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1)\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            off = dir < 0 ? maxOffset(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return { left: x, right: x, top: rect.top, bottom: rect.bottom };\n}\nfunction windowRect(win) {\n    return { left: 0, right: win.innerWidth,\n        top: 0, bottom: win.innerHeight };\n}\nconst ScrollSpace = 5;\nfunction scrollRectIntoView(dom, rect) {\n    let doc = dom.ownerDocument, win = doc.defaultView;\n    for (let cur = dom.parentNode; cur;) {\n        if (cur.nodeType == 1) { // Element\n            let bounding, top = cur == document.body;\n            if (top) {\n                bounding = windowRect(win);\n            }\n            else {\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth,\n                    top: rect.top, bottom: rect.top + cur.clientHeight };\n            }\n            let moveX = 0, moveY = 0;\n            if (rect.top < bounding.top)\n                moveY = -(bounding.top - rect.top + ScrollSpace);\n            else if (rect.bottom > bounding.bottom)\n                moveY = rect.bottom - bounding.bottom + ScrollSpace;\n            if (rect.left < bounding.left)\n                moveX = -(bounding.left - rect.left + ScrollSpace);\n            else if (rect.right > bounding.right)\n                moveX = rect.right - bounding.right + ScrollSpace;\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                }\n                else {\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY;\n                        moveY = cur.scrollTop - start;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX;\n                        moveX = cur.scrollLeft - start;\n                    }\n                    rect = { left: rect.left - moveX, top: rect.top - moveY,\n                        right: rect.right - moveX, bottom: rect.bottom - moveY };\n                }\n            }\n            if (top)\n                break;\n            cur = cur.parentNode;\n        }\n        else if (cur.nodeType == 11) { // A shadow root\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n}\nclass DOMSelection {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    set(domSel) {\n        this.anchorNode = domSel.anchorNode;\n        this.anchorOffset = domSel.anchorOffset;\n        this.focusNode = domSel.focusNode;\n        this.focusOffset = domSel.focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stack = [];\n    for (let cur = dom; cur; cur = cur.parentNode) {\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument)\n            break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for (let i = 0; i < stack.length;) {\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top)\n                elt.scrollTop = top;\n            if (elt.scrollLeft != left)\n                elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction tempRange() { return scratchRange || (scratchRange = document.createRange()); }\n\nclass DOMPos {\n    constructor(node, offset, precise = true) {\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\n}\nconst none = [];\nclass ContentView {\n    constructor() {\n        this.parent = null;\n        this.dom = null;\n        this.dirty = 2 /* Node */;\n    }\n    get editorView() {\n        if (!this.parent)\n            throw new Error(\"Accessing view in orphan content view\");\n        return this.parent.editorView;\n    }\n    get overrideDOMText() { return null; }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children) {\n            if (child == view)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    // Will return a rectangle directly before (when side < 0), after\n    // (side > 0) or directly on (when the browser supports it) the\n    // given position.\n    coordsAt(_pos, _side) { return null; }\n    sync(track) {\n        if (this.dirty & 2 /* Node */) {\n            let parent = this.dom, pos = null;\n            for (let child of this.children) {\n                if (child.dirty) {\n                    let next = pos ? pos.nextSibling : parent.firstChild;\n                    if (next && !child.dom && !ContentView.get(next))\n                        child.reuseDOM(next);\n                    child.sync(track);\n                    child.dirty = 0 /* Not */;\n                }\n                if (track && track.node == parent && pos != child.dom)\n                    track.written = true;\n                syncNodeInto(parent, pos, child.dom);\n                pos = child.dom;\n            }\n            let next = pos ? pos.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent)\n                track.written = true;\n            while (next)\n                next = rm(next);\n        }\n        else if (this.dirty & 1 /* Child */) {\n            for (let child of this.children)\n                if (child.dirty) {\n                    child.sync(track);\n                    child.dirty = 0 /* Not */;\n                }\n        }\n    }\n    reuseDOM(_dom) { return false; }\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        }\n        else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for (;;) {\n                let parent = node.parentNode;\n                if (parent == this.dom)\n                    break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild)\n                        bias = -1;\n                    else\n                        bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0)\n                after = node;\n            else\n                after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild)\n            return 0;\n        while (after && !ContentView.get(after))\n            after = after.nextSibling;\n        if (!after)\n            return this.length;\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i];\n            if (child.dom == after)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for (let i = 0, pos = offset; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to)\n                return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (end >= to && end != pos && toI == -1) {\n                toI = i;\n                toEnd = end;\n                break;\n            }\n            pos = end + child.breakAfter;\n        }\n        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd, startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: toI < this.children.length - 1 && toI >= 0 ? this.children[toI + 1].dom : null };\n    }\n    // FIXME track precise dirty ranges, to avoid full DOM sync on every touched node?\n    markDirty(andParent = false) {\n        if (this.dirty & 2 /* Node */)\n            return;\n        this.dirty |= 2 /* Node */;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for (let parent = this.parent; parent; parent = parent.parent) {\n            if (childList)\n                parent.dirty |= 2 /* Node */;\n            if (parent.dirty & 1 /* Child */)\n                return;\n            parent.dirty |= 1 /* Child */;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.dirty)\n                this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for (let v = this;;) {\n            let parent = v.parent;\n            if (!parent)\n                return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = none) {\n        this.markDirty();\n        for (let i = from; i < to; i++)\n            this.children[i].parent = null;\n        this.children.splice(from, to - from, ...children);\n        for (let i = 0; i < children.length; i++)\n            children[i].setParent(this);\n    }\n    ignoreMutation(_rec) { return false; }\n    ignoreEvent(_event) { return false; }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\n            (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) { return node.cmView; }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nfunction syncNodeInto(parent, after, dom) {\n    let next = after ? after.nextSibling : parent.firstChild;\n    if (dom.parentNode == parent)\n        while (next != dom)\n            next = rm(next);\n    else\n        parent.insertBefore(dom, next);\n}\nclass ChildCursor {\n    constructor(children, pos, i) {\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for (;;) {\n            if (pos > this.pos || pos == this.pos &&\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\n\nconst none$1 = [];\nclass InlineView extends ContentView {\n    /// Return true when this view is equivalent to `other` and can take\n    /// on its role.\n    become(_other) { return false; }\n    // When this is a zero-length view with a side, this should return a\n    // negative number to indicate it is before its position, or a\n    // positive number when after its position.\n    getSide() { return 0; }\n}\nInlineView.prototype.children = none$1;\nconst MaxJoinLen = 256;\nclass TextView extends InlineView {\n    constructor(text) {\n        super();\n        this.text = text;\n    }\n    get length() { return this.text.length; }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(track) {\n        if (!this.dom)\n            this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom)\n                track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType != 3)\n            return false;\n        this.createDOM(dom);\n        return true;\n    }\n    merge(from, to, source) {\n        if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))\n            return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    slice(from) {\n        return new TextView(this.text.slice(from));\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) { return new DOMPos(this.dom, pos); }\n    domBoundsAround(_from, _to, offset) {\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side, this.length);\n    }\n}\nclass MarkView extends InlineView {\n    constructor(mark, children = [], length = 0) {\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)\n            ch.setParent(this);\n    }\n    createDOM() {\n        let dom = document.createElement(this.mark.tagName);\n        if (this.mark.class)\n            dom.className = this.mark.class;\n        if (this.mark.attrs)\n            for (let name in this.mark.attrs)\n                dom.setAttribute(name, this.mark.attrs[name]);\n        this.setDOM(dom);\n    }\n    sync(track) {\n        if (!this.dom)\n            this.createDOM();\n        super.sync(track);\n    }\n    merge(from, to, source, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||\n            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))\n            return false;\n        mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    slice(from) {\n        return new MarkView(this.mark, sliceInlineChildren(this.children, from), this.length - from);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side, length) {\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges\n            if (pos) {\n                from--;\n                flatten = 1;\n            } // FIXME this is wrong in RTL text\n            else {\n                to++;\n                flatten = -1;\n            }\n        }\n    }\n    else {\n        if (side < 0)\n            from--;\n        else\n            to++;\n    }\n    let range = tempRange();\n    range.setEnd(text, to);\n    range.setStart(text, from);\n    let rects = range.getClientRects(), rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0)\n        rect = Array.prototype.find.call(rects, r => r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends InlineView {\n    constructor(widget, length, side) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n    }\n    static create(widget, length, side) {\n        return new (widget.customView || WidgetView)(widget, length, side);\n    }\n    slice(from) { return WidgetView.create(this.widget, this.length - from, this.side); }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() { return this.side; }\n    merge(from, to, source, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n            if (this.widget.constructor == other.widget.constructor) {\n                if (!this.widget.eq(other.widget))\n                    this.markDirty(true);\n                this.widget = other.widget;\n                return true;\n            }\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get overrideDOMText() {\n        if (this.length == 0)\n            return Text.empty;\n        let top = this;\n        while (top.parent)\n            top = top.parent;\n        let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : Text.empty;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() { return null; }\n    coordsAt(pos, side) {\n        let rects = this.dom.getClientRects(), rect = null;\n        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\n                break;\n        }\n        return (pos == 0 && side > 0 || pos == this.length && side <= 0) ? rect : flattenRect(rect, pos == 0);\n    }\n}\nclass CompositionView extends WidgetView {\n    domAtPos(pos) { return new DOMPos(this.widget.text, pos); }\n    sync() { if (!this.dom)\n        this.setDOM(this.widget.toDOM()); }\n    localPosFromDOM(node, offset) {\n        return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;\n    }\n    ignoreMutation() { return false; }\n    get overrideDOMText() { return null; }\n    coordsAt(pos, side) { return textCoords(this.widget.text, pos, side, this.length); }\n}\nfunction mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of elts)\n        dLen += view.length;\n    parent.length += dLen;\n    let { children } = parent;\n    // Both from and to point into the same text view\n    if (fromI == toI && fromOff) {\n        let start = children[fromI];\n        // Maybe just update that view and be done\n        if (elts.length == 1 && start.merge(fromOff, toOff, elts[0], openStart, openEnd))\n            return;\n        if (elts.length == 0) {\n            start.merge(fromOff, toOff, null, openStart, openEnd);\n            return;\n        }\n        // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards\n        let after = start.slice(toOff);\n        if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd))\n            elts[elts.length - 1] = after;\n        else\n            elts.push(after);\n        toI++;\n        openEnd = toOff = 0;\n    }\n    // Make sure start and end positions fall on node boundaries\n    // (fromOff/toOff are no longer used after this), and that if the\n    // start or end of the elts can be merged with adjacent nodes,\n    // this is done\n    if (toOff) {\n        let end = children[toI];\n        if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {\n            elts.pop();\n            openEnd = 0;\n        }\n        else {\n            end.merge(0, toOff, null, 0, 0);\n        }\n    }\n    else if (toI < children.length && elts.length &&\n        children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {\n        elts.pop();\n        openEnd = 0;\n    }\n    if (fromOff) {\n        let start = children[fromI];\n        if (elts.length && start.merge(fromOff, start.length, elts[0], openStart, 0)) {\n            elts.shift();\n            openStart = 0;\n        }\n        else {\n            start.merge(fromOff, start.length, null, 0, 0);\n        }\n        fromI++;\n    }\n    else if (fromI && elts.length) {\n        let end = children[fromI - 1];\n        if (end.merge(end.length, end.length, elts[0], openStart, 0)) {\n            elts.shift();\n            openStart = 0;\n        }\n    }\n    // Then try to merge any mergeable nodes at the start and end of\n    // the changed range\n    while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {\n        elts.pop();\n        toI--;\n        openEnd = 0;\n    }\n    while (fromI < toI && elts.length && children[fromI].become(elts[0])) {\n        elts.shift();\n        fromI++;\n        openStart = 0;\n    }\n    if (!elts.length && fromI && toI < children.length && openStart && openEnd &&\n        children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd))\n        fromI--;\n    // And if anything remains, splice the child array to insert the new elts\n    if (elts.length || fromI != toI)\n        parent.replaceChildren(fromI, toI, elts);\n}\nfunction sliceInlineChildren(children, from) {\n    let result = [], off = 0;\n    for (let elt of children) {\n        let end = off + elt.length;\n        if (end > from)\n            result.push(off < from ? elt.slice(from - off) : elt);\n        off = end;\n    }\n    return result;\n}\nfunction inlineDOMAtPos(dom, children, pos) {\n    let i = 0;\n    for (let off = 0; i < children.length; i++) {\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0)\n            continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom)\n            return child.domAtPos(pos - off);\n        if (pos <= off)\n            break;\n        off = end;\n    }\n    for (; i > 0; i--) {\n        let before = children[i - 1].dom;\n        if (before.parentNode == dom)\n            return DOMPos.after(before);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length &&\n        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    }\n    else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    for (let off = 0, i = 0; i < view.children.length; i++) {\n        let child = view.children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0)\n            continue;\n        if (side <= 0 || end == view.length ? end >= pos : end > pos)\n            return child.coordsAt(pos - off, side);\n        off = end;\n    }\n    return (view.dom.lastChild || view.dom).getBoundingClientRect();\n}\n\nfunction combineAttrs(source, target) {\n    for (let name in source) {\n        if (name == \"class\" && target.class)\n            target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style)\n            target.style += \";\" + source.style;\n        else\n            target[name] = source[name];\n    }\n    return target;\n}\nfunction attrsEq(a, b) {\n    if (a == b)\n        return true;\n    if (!a || !b)\n        return false;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length != keysB.length)\n        return false;\n    for (let key of keysA) {\n        if (keysB.indexOf(key) == -1 || a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    if (prev)\n        for (let name in prev)\n            if (!(attrs && name in attrs))\n                dom.removeAttribute(name);\n    if (attrs)\n        for (let name in attrs)\n            if (!(prev && prev[name] == attrs[name]))\n                dom.setAttribute(name, attrs[name]);\n}\n\n/// Widgets added to the content are described by subclasses of this\n/// class. This makes it possible to delay creating of the DOM\n/// structure for a widget until it is needed, and to avoid redrawing\n/// widgets even when the decorations that define them are recreated.\n/// `T` can be a type of value passed to instances of the widget type.\nclass WidgetType {\n    /// Compare this instance to another instance of the same type.\n    /// (TypeScript can't express this, but only instances of the same\n    /// specific class will be passed to this method.) This is used to\n    /// avoid redrawing widgets when they are replace by a new\n    /// decoration of the same type. The default implementation just\n    /// returns `false`, which may be wasteful.\n    eq(_widget) { return false; }\n    /// Update a DOM element created by a widget of the same type (but\n    /// different, non-`eq` content) to reflect this widget. May return\n    /// true to indicate that it could update, false to indicate it\n    /// couldn't (in which case the widget will be redrawn). The default\n    /// implementation just returns false.\n    updateDOM(_dom) { return false; }\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /// The estimated height this widget will have, to be used when\n    /// estimating the height of content that hasn't been drawn. May\n    /// return -1 to indicate you don't know. The default implementation\n    /// returns -1.\n    get estimatedHeight() { return -1; }\n    /// Can be used to configure which kinds of events inside the widget\n    /// should be ignored by the editor. The default is to ignore all\n    /// events.\n    ignoreEvent(_event) { return true; }\n    //// @internal\n    get customView() { return null; }\n}\n/// The different types of blocks that can occur in an editor view.\nvar BlockType;\n(function (BlockType) {\n    /// A line of text.\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /// A block widget associated with the position after it.\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /// A block widget associated with the position before it.\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /// A block widget [replacing](#view.Decoration^replace) a range of content.\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n})(BlockType || (BlockType = {}));\n/// A decoration provides information on how to draw or style a piece\n/// of content. You'll usually use it wrapped in a\n/// [`Range`](#rangeset.Range), which adds a start and end position.\nclass Decoration extends RangeValue {\n    /// @internal\n    constructor(\n    /// @internal\n    startSide, \n    /// @internal\n    endSide, \n    /// @internal\n    widget, \n    /// The config object used to create this decoration.\n    spec) {\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /// @internal\n    get heightRelevant() { return false; }\n    /// Create a mark decoration, which influences the styling of the\n    /// content in its range. Nested mark decorations will cause nested\n    /// DOM elements to be created. Nesting order is determined by\n    /// precedence of the [facet](#view.EditorView^decorations) or\n    /// (below the facet-provided decorations) [view\n    /// plugin](#view.PluginSpec.decorations). Such elements are broken\n    /// on line boundaries and on the boundaries of higher-precedence\n    /// decorations.\n    static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /// Create a widget decoration, which adds an element at the given\n    /// position.\n    static widget(spec) {\n        let side = spec.side || 0;\n        if (spec.block)\n            side += (200000000 /* BigBlock */ + 1) * (side > 0 ? 1 : -1);\n        return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);\n    }\n    /// Create a replace decoration which replaces the given range with\n    /// a widget, or simply hides it.\n    static replace(spec) {\n        let block = !!spec.block;\n        let { start, end } = getInclusive(spec);\n        let startSide = block ? -200000000 /* BigBlock */ * (start ? 2 : 1) : 100000000 /* BigInline */ * (start ? -1 : 1);\n        let endSide = block ? 200000000 /* BigBlock */ * (end ? 2 : 1) : 100000000 /* BigInline */ * (end ? 1 : -1);\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /// Create a line decoration, which can add DOM attributes to the\n    /// line starting at the given position.\n    static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /// Build a [`DecorationSet`](#view.DecorationSet) from the given\n    /// decorated range or ranges.\n    static set(of, sort = false) {\n        return RangeSet.of(of, sort);\n    }\n    /// @internal\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\n}\n/// The empty set of decorations.\nDecoration.none = RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec) {\n        let { start, end } = getInclusive(spec);\n        super(100000000 /* BigInline */ * (start ? -1 : 1), 100000000 /* BigInline */ * (end ? 1 : -1), null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        return this == other ||\n            other instanceof MarkDecoration &&\n                this.tagName == other.tagName &&\n                this.class == other.class &&\n                attrsEq(this.attrs, other.attrs);\n    }\n    range(from, to = from) {\n        if (from >= to)\n            throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec) {\n        super(-100000000 /* BigInline */, -100000000 /* BigInline */, null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from)\n            throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace) {\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? MapMode.TrackDel : startSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide < this.endSide ? BlockType.WidgetRange\n            : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }\n    eq(other) {\n        return other instanceof PointDecoration &&\n            widgetsEq(this.widget, other.widget) &&\n            this.block == other.block &&\n            this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide < 0)))\n            throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from)\n            throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null)\n        start = spec.inclusive;\n    if (end == null)\n        end = spec.inclusive;\n    return { start: start || false, end: end || false };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nconst MinRangeGap = 4;\nfunction addRange(from, to, ranges) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + MinRangeGap > from)\n        ranges[last] = Math.max(ranges[last], to);\n    else\n        ranges.push(from, to);\n}\n\nconst theme = Facet.define({ combine: strs => strs.join(\" \") });\nconst darkTheme = Facet.define({ combine: values => values.indexOf(true) > -1 });\nconst baseThemeID = StyleModule.newName();\nfunction expandThemeClasses(sel) {\n    return sel.replace(/\\$\\w[\\w\\.]*/g, cls => {\n        let parts = cls.slice(1).split(\".\"), result = \"\";\n        for (let i = 1; i <= parts.length; i++)\n            result += \".cm-\" + parts.slice(0, i).join(\"-\");\n        return result;\n    });\n}\nfunction buildTheme(main, spec) {\n    return new StyleModule(spec, {\n        process(sel) {\n            sel = expandThemeClasses(sel);\n            return /\\$/.test(sel) ? sel.replace(/\\$/, main) : main + \" \" + sel;\n        },\n        extend(template, sel) {\n            template = expandThemeClasses(template);\n            return sel.slice(0, main.length + 1) == main + \" \"\n                ? main + \" \" + template.replace(/&/, sel.slice(main.length + 1))\n                : template.replace(/&/, sel);\n        }\n    });\n}\n/// Create a set of CSS class names for the given theme class, which\n/// can be added to a DOM element within an editor to make themes able\n/// to style it. Theme classes can be single words or words separated\n/// by dot characters. In the latter case, the returned classes\n/// combine those that match the full name and those that match some\n/// prefix—for example `\"panel.search\"` will match both the theme\n/// styles specified as `\"panel.search\"` and those with just\n/// `\"panel\"`. More specific theme classes (with more dots) take\n/// precedence over less specific ones.\nfunction themeClass(selector) {\n    if (selector.indexOf(\".\") < 0)\n        return \"cm-\" + selector;\n    let parts = selector.split(\".\"), result = \"\";\n    for (let i = 1; i <= parts.length; i++)\n        result += (result ? \" \" : \"\") + \"cm-\" + parts.slice(0, i).join(\"-\");\n    return result;\n}\nconst baseTheme = buildTheme(\".\" + baseThemeID, {\n    $: {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&$focused\": {\n            // FIXME it would be great if we could directly use the browser's\n            // default focus outline, but it appears we can't, so this tries to\n            // approximate that\n            outline_fallback: \"1px dotted #212121\",\n            outline: \"5px auto -webkit-focus-ring-color\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    $scroller: {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0\n    },\n    $content: {\n        margin: 0,\n        flexGrow: 2,\n        minHeight: \"100%\",\n        display: \"block\",\n        whiteSpace: \"pre\",\n        boxSizing: \"border-box\",\n        padding: \"4px 0\",\n        outline: \"none\"\n    },\n    \"$$light $content\": { caretColor: \"black\" },\n    \"$$dark $content\": { caretColor: \"white\" },\n    $line: {\n        display: \"block\",\n        padding: \"0 2px 0 4px\"\n    },\n    $selectionLayer: {\n        zIndex: -1,\n        contain: \"size style\"\n    },\n    $selectionBackground: {\n        position: \"absolute\",\n    },\n    \"$$light $selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"$$dark $selectionBackground\": {\n        background: \"#222\"\n    },\n    \"$$focused$light $selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"$$focused$dark $selectionBackground\": {\n        background: \"#233\"\n    },\n    $cursorLayer: {\n        zIndex: 100,\n        contain: \"size style\",\n        pointerEvents: \"none\"\n    },\n    \"$$focused $cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": { \"0%\": {}, \"50%\": { visibility: \"hidden\" }, \"100%\": {} },\n    \"@keyframes cm-blink2\": { \"0%\": {}, \"50%\": { visibility: \"hidden\" }, \"100%\": {} },\n    $cursor: {\n        position: \"absolute\",\n        borderLeft: \"1.2px solid #bbb\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\"\n    },\n    \"$$dark $cursor\": {\n        borderLeftColor: \"#444\"\n    },\n    \"$$focused $cursor\": {\n        borderLeft: \"1.2px solid black\",\n    },\n    $placeholder: {\n        color: \"#888\",\n        display: \"inline-block\"\n    },\n    $button: {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"3px\"\n    },\n    \"$$light $button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"$$dark $button\": {\n        backgroundImage: \"linear-gradient(#555, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    $textfield: {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"$$light $textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"$$dark $textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n});\n\nconst LineClass = themeClass(\"line\");\nclass LineView extends ContentView {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, takeDeco, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView))\n                return false;\n            if (!this.dom)\n                source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (takeDeco)\n            this.setDeco(source ? source.attrs : null);\n        mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0)\n            return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].slice(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, 0, 0);\n            i++;\n        }\n        for (let j = i; j < this.children.length; j++)\n            end.append(this.children[j], 0);\n        while (i > 0 && this.children[i - 1].length == 0) {\n            this.children[i - 1].parent = null;\n            i--;\n        }\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom)\n            return;\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    // Only called when building a line view in ContentBuilder\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes;\n        if (attrs)\n            this.attrs = combineAttrs(attrs, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n    // FIXME might need another hack to work around Firefox's behavior\n    // of not actually displaying the cursor even though it's there in\n    // the DOM\n    sync(track) {\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = LineClass;\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(LineClass);\n            this.prevAttrs = undefined;\n        }\n        super.sync(track);\n        let last = this.dom.lastChild;\n        if (!last || (last.nodeName != \"BR\" && (ContentView.get(last) instanceof WidgetView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20)\n            return null;\n        let totalWidth = 0;\n        for (let child of this.children) {\n            if (!(child instanceof TextView))\n                return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1)\n                return null;\n            totalWidth += rects[0].width;\n        }\n        return { lineHeight: this.dom.getBoundingClientRect().height, charWidth: totalWidth / this.length };\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n    match(_other) { return false; }\n    get type() { return BlockType.Text; }\n    static find(docView, pos) {\n        for (let i = 0, off = 0;; i++) {\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView)\n                    return block;\n                if (block.length)\n                    return null;\n            }\n            off = end + block.breakAfter;\n        }\n    }\n}\nconst none$2 = [];\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, type) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.type = type;\n        this.breakAfter = 0;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        return new BlockWidgetView(this.widget, len, this.type);\n    }\n    get children() { return none$2; }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text$1.empty;\n    }\n    domBoundsAround() { return null; }\n    match(other) {\n        if (other instanceof BlockWidgetView && other.type == this.type &&\n            other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.eq(this.widget))\n                this.markDirty(true);\n            this.widget = other.widget;\n            this.length = other.length;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n}\n\nclass ContentBuilder {\n    constructor(doc, pos, end) {\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0)\n            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n    getLine() {\n        if (!this.curLine)\n            this.content.push(this.curLine = new LineView);\n        return this.curLine;\n    }\n    addWidget(view) {\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish() {\n        if (!this.posCovered())\n            this.getLine();\n    }\n    wrapMarks(view, active) {\n        for (let i = active.length - 1; i >= 0; i--)\n            view = new MarkView(active[i], [view], view.length);\n        return view;\n    }\n    buildText(length, active, openStart) {\n        while (length > 0) {\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done)\n                    throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered())\n                        this.getLine();\n                    if (this.content.length)\n                        this.content[this.content.length - 1].breakAfter = 1;\n                    else\n                        this.breakAtStart = 1;\n                    this.curLine = null;\n                    length--;\n                    continue;\n                }\n                else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length);\n            this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            length -= take;\n            this.textOff += take;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart) {\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                let { type } = deco;\n                if (type == BlockType.WidgetAfter && !this.posCovered())\n                    this.getLine();\n                this.addWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\n            }\n            else {\n                let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide), active);\n                this.getLine().append(widget, openStart);\n            }\n        }\n        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            }\n            else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    static build(text, from, to, decorations) {\n        let builder = new ContentBuilder(text, from, to);\n        builder.openEnd = RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0)\n            builder.openStart = builder.openEnd;\n        builder.finish();\n        return builder;\n    }\n}\nclass NullWidget extends WidgetType {\n    constructor(tag) {\n        super();\n        this.tag = tag;\n    }\n    eq(other) { return other.tag == this.tag; }\n    toDOM() { return document.createElement(this.tag); }\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }\n}\n\n/// Used to indicate [text direction](#view.EditorView.textDirection).\nvar Direction;\n(function (Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n})(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for (let i = 0; i < str.length; i++)\n        result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] :\n        0x590 <= ch && ch <= 0x5f4 ? 2 /* R */ :\n            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :\n                0x6ee <= ch && ch <= 0x8ac ? 4 /* AL */ :\n                    0x2000 <= ch && ch <= 0x200b ? 256 /* NI */ :\n                        ch == 0x200c ? 256 /* NI */ : 1 /* L */;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n/// Represents a contiguous range of text that has a single direction\n/// (as in left-to-right or right-to-left).\nclass BidiSpan {\n    /// @internal\n    constructor(\n    /// The start of the span (relative to the start of the line).\n    from, \n    /// The end of the span.\n    to, \n    /// The [\"bidi\n    /// level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    /// of the span (in this context, 0 means\n    /// left-to-right, 1 means right-to-left, 2 means left-to-right\n    /// number inside right-to-left text).\n    level) {\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /// The direction of this span.\n    get dir() { return this.level % 2 ? RTL : LTR; }\n    /// @internal\n    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }\n    /// @internal\n    static find(order, index, level, assoc) {\n        let maybe = -1;\n        for (let i = 0; i < order.length; i++) {\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level)\n                    return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))\n                    maybe = i;\n            }\n        }\n        if (maybe < 0)\n            throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\n// Reused array of character types\nconst types = [];\nfunction computeOrder(line, direction) {\n    let len = line.length, outerType = direction == LTR ? 1 /* L */ : 2 /* R */;\n    if (!line || outerType == 1 /* L */ && !BidiRE.test(line))\n        return trivialOrder(len);\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    // (Left after this: L, R, EN, AN, ET, CS, NI)\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n        let type = charType(line.charCodeAt(i));\n        if (type == 512 /* NSM */)\n            type = prev;\n        else if (type == 8 /* EN */ && prevStrong == 4 /* AL */)\n            type = 16 /* AN */;\n        types[i] = type == 4 /* AL */ ? 2 /* R */ : type;\n        if (type & 7 /* Strong */)\n            prevStrong = type;\n        prev = type;\n    }\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    // (Left after this: L, R, EN+AN, NI)\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n        let type = types[i];\n        if (type == 128 /* CS */) {\n            if (i < len - 1 && prev == types[i + 1] && (prev & 24 /* Num */))\n                type = types[i] = prev;\n            else\n                types[i] = 256 /* NI */;\n        }\n        else if (type == 64 /* ET */) {\n            let end = i + 1;\n            while (end < len && types[end] == 64 /* ET */)\n                end++;\n            let replace = (i && prev == 8 /* EN */) || (end < len && types[end] == 8 /* EN */) ? (prevStrong == 1 /* L */ ? 1 /* L */ : 8 /* EN */) : 256 /* NI */;\n            for (let j = i; j < end; j++)\n                types[j] = replace;\n            i = end - 1;\n        }\n        else if (type == 8 /* EN */ && prevStrong == 1 /* L */) {\n            types[i] = 1 /* L */;\n        }\n        prev = type;\n        if (type & 7 /* Strong */)\n            prevStrong = type;\n    }\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    // (Left after this: L, R, EN+AN)\n    for (let i = 0; i < len; i++) {\n        if (types[i] == 256 /* NI */) {\n            let end = i + 1;\n            while (end < len && types[end] == 256 /* NI */)\n                end++;\n            let beforeL = (i ? types[i - 1] : outerType) == 1 /* L */;\n            let afterL = (end < len ? types[end] : outerType) == 1 /* L */;\n            let replace = beforeL == afterL ? (beforeL ? 1 /* L */ : 2 /* R */) : outerType;\n            for (let j = i; j < end; j++)\n                types[j] = replace;\n            i = end - 1;\n        }\n    }\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    let order = [];\n    if (outerType == 1 /* L */) {\n        for (let i = 0; i < len;) {\n            let start = i, rtl = types[i++] != 1 /* L */;\n            while (i < len && rtl == (types[i] != 1 /* L */))\n                i++;\n            if (rtl) {\n                for (let j = i; j > start;) {\n                    let end = j, l = types[--j] != 2 /* R */;\n                    while (j > start && l == (types[j - 1] != 2 /* R */))\n                        j--;\n                    order.push(new BidiSpan(j, end, l ? 2 : 1));\n                }\n            }\n            else {\n                order.push(new BidiSpan(start, i, 0));\n            }\n        }\n    }\n    else {\n        for (let i = 0; i < len;) {\n            let start = i, rtl = types[i++] == 2 /* R */;\n            while (i < len && rtl == (types[i] == 2 /* R */))\n                i++;\n            order.push(new BidiSpan(start, i, rtl ? 1 : 2));\n        }\n    }\n    return order;\n}\nfunction trivialOrder(length) {\n    return [new BidiSpan(0, length, 0)];\n}\nlet movedOver = \"\";\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from, spanI = -1;\n    if (startIndex == 0) {\n        if (!forward || !line.length)\n            return null;\n        if (order[0].level != dir) {\n            startIndex = order[0].side(false, dir);\n            spanI = 0;\n        }\n    }\n    else if (startIndex == line.length) {\n        if (forward)\n            return null;\n        let last = order[order.length - 1];\n        if (last.level != dir) {\n            startIndex = last.side(true, dir);\n            spanI = order.length - 1;\n        }\n    }\n    if (spanI < 0)\n        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI];\n    // End of span. (But not end of line--that was checked for above.)\n    if (startIndex == span.side(forward, dir)) {\n        span = order[spanI += forward ? 1 : -1];\n        startIndex = span.side(!forward, dir);\n    }\n    let indexForward = forward == (span.dir == dir);\n    let nextIndex = line.findClusterBreak(startIndex, indexForward);\n    movedOver = line.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    if (nextIndex != span.side(forward, dir))\n        return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (!nextSpan && span.level != dir)\n        return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n    if (nextSpan && nextSpan.level < span.level)\n        return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, 0, nextSpan.level);\n    return EditorSelection.cursor(nextIndex + line.from, 0, span.level);\n}\n\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\"];\nclass HeightOracle {\n    constructor() {\n        this.doc = Text.empty;\n        this.lineWrapping = false;\n        this.direction = Direction.LTR;\n        this.heightSamples = {};\n        this.lineHeight = 14;\n        this.charWidth = 7;\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping)\n            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping)\n            return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) { this.doc = doc; return this; }\n    mustRefresh(lineHeights, whiteSpace, direction) {\n        let newHeight = false;\n        for (let i = 0; i < lineHeights.length; i++) {\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            }\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight || (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping || this.direction != direction;\n    }\n    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) ||\n            this.lineWrapping != lineWrapping ||\n            this.direction != direction;\n        this.lineWrapping = lineWrapping;\n        this.direction = direction;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for (let i = 0; i < knownHeights.length; i++) {\n                let h = knownHeights[i];\n                if (h < 0)\n                    i++;\n                else\n                    this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights) {\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() { return this.index < this.heights.length; }\n}\n/// Record used to represent information about a block-level element\n/// in the editor view.\nclass BlockInfo {\n    /// @internal\n    constructor(\n    /// The start of the element in the document.\n    from, \n    /// The length of the element.\n    length, \n    /// The top position of the element.\n    top, \n    /// Its height.\n    height, \n    /// The type of element this is. When querying lines, this may be\n    /// an array of all the blocks that make up the line.\n    type) {\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this.type = type;\n    }\n    /// The end of the element as a document position.\n    get to() { return this.from + this.length; }\n    /// The bottom position of the element.\n    get bottom() { return this.top + this.height; }\n    /// @internal\n    join(other) {\n        let detail = (Array.isArray(this.type) ? this.type : [this])\n            .concat(Array.isArray(other.type) ? other.type : [other]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n    }\n}\nvar QueryType;\n(function (QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n})(QueryType || (QueryType = {}));\nconst Epsilon = 1e-4;\nclass HeightMap {\n    constructor(length, // The number of characters covered\n    height, // Height of this part of the document\n    flags = 2 /* Outdated */) {\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() { return (this.flags & 2 /* Outdated */) > 0; }\n    set outdated(value) { this.flags = (value ? 2 /* Outdated */ : 0) | (this.flags & ~2 /* Outdated */); }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon)\n                oracle.heightChanged = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) { result.push(this); }\n    decomposeRight(_from, result) { result.push(this); }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this;\n        for (let i = changes.length - 1; i >= 0; i--) {\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while (i > 0 && start.from <= changes[i - 1].toA) {\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from)\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() { return new HeightMapText(0, 0); }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1)\n            return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for (;;) {\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break)\n                        nodes.splice(--i, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                }\n                else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break)\n                        nodes.splice(j, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (before < after) {\n                let next = nodes[i++];\n                if (next)\n                    before += next.size;\n            }\n            else {\n                let next = nodes[--j];\n                if (next)\n                    after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        }\n        else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, type) {\n        super(length, height);\n        this.type = type;\n    }\n    blockAt(_height, _doc, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.type);\n    }\n    lineAt(_value, _type, doc, top, offset) {\n        return this.blockAt(0, doc, top, offset);\n    }\n    forEachLine(_from, _to, doc, top, offset, f) {\n        f(this.blockAt(0, doc, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() { return `block(${this.length})`; }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height) {\n        super(length, height, BlockType.Text);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* SingleLine */)) &&\n            Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap)\n                node = new HeightMapText(node.length, this.height);\n            else\n                node.height = this.height;\n            if (!this.outdated)\n                node.outdated = false;\n            return node;\n        }\n        else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated)\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length) { super(length, 0); }\n    lines(doc, offset) {\n        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\n        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };\n    }\n    blockAt(height, doc, top, offset) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n        let { from, length } = doc.line(firstLine + line);\n        return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);\n    }\n    lineAt(value, type, doc, top, offset) {\n        if (type == QueryType.ByHeight)\n            return this.blockAt(value, doc, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, BlockType.Text);\n        }\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        let { from, length, number } = doc.lineAt(value);\n        return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        for (let pos = from; pos < to;) {\n            let line = doc.lineAt(pos);\n            if (pos == from)\n                top += lineHeight * (line.number - firstLine);\n            f(new BlockInfo(line.from, line.length, top, top += lineHeight, BlockType.Text));\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap)\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else\n                nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap)\n                nodes[0] = new HeightMapGap(from + first.length);\n            else\n                nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from);\n            if (measured.from > offset)\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while (pos <= end && measured.more) {\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length)\n                    nodes.push(null);\n                let line = new HeightMapText(len, measured.heights[measured.index++]);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end)\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            oracle.heightChanged = true;\n            return HeightMap.of(nodes);\n        }\n        else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() { return `gap(${this.length})`; }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right) {\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Outdated */ : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() { return this.flags & 1 /* Break */; }\n    blockAt(height, doc, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset)\n            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, doc, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, doc, top, offset)\n            : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\n            return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left)\n            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));\n        else\n            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset)\n                this.left.forEachLine(from, to, doc, top, offset, f);\n            if (to >= rightOffset)\n                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n        }\n        else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n            if (from < mid.from)\n                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n            if (mid.to >= from && mid.from <= to)\n                f(mid);\n            if (to > mid.to)\n                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart)\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length)\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0)\n            this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)\n            result.push(node);\n        if (from > 0)\n            mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left)\n            return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left)\n                result.push(null);\n        }\n        if (to > left)\n            this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right)\n            return this.right.decomposeRight(from - right, result);\n        if (from < left)\n            this.left.decomposeRight(from, result);\n        if (this.break && from < right)\n            result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more)\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else\n            left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more)\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else\n            right.updateHeight(oracle, rightStart, force);\n        if (rebalance)\n            return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null &&\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\n        (after = nodes[around + 1]) instanceof HeightMapGap)\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle) {\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText)\n                last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered)\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco.type));\n            }\n            else if (len || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, len);\n            }\n        }\n        else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1)\n            return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)\n                this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from)\n            this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to)\n            gap.flags |= 4 /* SingleLine */;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText)\n            return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        if (block.type == BlockType.WidgetAfter && !this.isCovered)\n            this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (block.type != BlockType.WidgetBefore)\n            this.covering = block;\n    }\n    addLineDeco(height, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\n            this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null)\n            this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes) {\n            if (node instanceof HeightMapText)\n                node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        RangeSet.spans(decorations, from, to, builder);\n        return builder.finish(from);\n    }\n    get minPointSize() { return 0; }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator();\n    RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange() { }\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant)\n            addRange(from, to, this.changes);\n    }\n    get minPointSize() { return 0; }\n}\n\nconst none$3 = [];\nconst clickAddsSelectionRange = Facet.define();\nconst dragMovesSelection = Facet.define();\nconst mouseSelectionStyle = Facet.define();\nconst exceptionSink = Facet.define();\nconst updateListener = Facet.define();\nconst inputHandler = Facet.define();\n/// Log or report an unhandled exception in client code. Should\n/// probably only be used by extension code that allows client code to\n/// provide functions, and calls those functions in a context where an\n/// exception can't be propagated to calling code in a reasonable way\n/// (for example when in an event handler).\n///\n/// Either calls a handler registered with\n/// [`EditorView.exceptionSink`](#view.EditorView^exceptionSink),\n/// `window.onerror`, if defined, or `console.error` (in which case\n/// it'll pass `context`, when given, as first argument).\nfunction logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length)\n        handler[0](exception);\n    else if (window.onerror)\n        window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context)\n        console.error(context + \":\", exception);\n    else\n        console.error(exception);\n}\nconst editable = Facet.define({ combine: values => values.length ? values[0] : true });\n/// Used to [declare](#view.PluginSpec.provide) which\n/// [fields](#view.PluginValue) a [view plugin](#view.ViewPlugin)\n/// provides.\nclass PluginFieldProvider {\n    /// @internal\n    constructor(\n    /// @internal\n    field, \n    /// @internal\n    get) {\n        this.field = field;\n        this.get = get;\n    }\n}\n/// Plugin fields are a mechanism for allowing plugins to provide\n/// values that can be retrieved through the\n/// [`pluginField`](#view.EditorView.pluginField) view method.\nclass PluginField {\n    from(get) {\n        return new PluginFieldProvider(this, get);\n    }\n    /// Define a new plugin field.\n    static define() { return new PluginField(); }\n}\n/// Plugins can provide additional scroll margins (space around the\n/// sides of the scrolling element that should be considered\n/// invisible) through this field. This can be useful when the\n/// plugin introduces elements that cover part of that element (for\n/// example a horizontally fixed gutter).\nPluginField.scrollMargins = PluginField.define();\nlet nextPluginID = 0;\nconst viewPlugin = Facet.define();\n/// View plugins associate stateful values with a view. They can\n/// influence the way the content is drawn, and are notified of things\n/// that happen in the view.\nclass ViewPlugin {\n    constructor(\n    /// @internal\n    id, \n    /// @internal\n    create, \n    /// @internal\n    fields) {\n        this.id = id;\n        this.create = create;\n        this.fields = fields;\n        this.extension = viewPlugin.of(this);\n    }\n    /// Define a plugin from a constructor function that creates the\n    /// plugin's value, given an editor view.\n    static define(create, spec) {\n        let { eventHandlers, provide, decorations } = spec || {};\n        let fields = [];\n        if (provide)\n            for (let provider of Array.isArray(provide) ? provide : [provide])\n                fields.push(provider);\n        if (eventHandlers)\n            fields.push(domEventHandlers.from((value) => ({ plugin: value, handlers: eventHandlers })));\n        if (decorations)\n            for (let get of Array.isArray(decorations) ? decorations : [decorations])\n                fields.push(pluginDecorations.from(get));\n        return new ViewPlugin(nextPluginID++, create, fields);\n    }\n    /// Create a plugin for a class whose constructor takes a single\n    /// editor view as argument.\n    static fromClass(cls, spec) {\n        return ViewPlugin.define(view => new cls(view), spec);\n    }\n}\n// FIXME somehow ensure that no replacing decorations end up in here\nconst pluginDecorations = PluginField.define();\nconst domEventHandlers = PluginField.define();\nclass PluginInstance {\n    constructor(value, spec) {\n        this.value = value;\n        this.spec = spec;\n    }\n    static create(spec, view) {\n        let value;\n        try {\n            value = spec.create(view);\n        }\n        catch (e) {\n            logException(view.state, e, \"CodeMirror plugin crashed\");\n            return PluginInstance.dummy;\n        }\n        return new PluginInstance(value, spec);\n    }\n    takeField(type, target) {\n        for (let { field, get } of this.spec.fields)\n            if (field == type)\n                target.push(get(this.value));\n    }\n    update(update) {\n        if (!this.value.update)\n            return this;\n        try {\n            this.value.update(update);\n            return this;\n        }\n        catch (e) {\n            logException(update.state, e, \"CodeMirror plugin crashed\");\n            if (this.value.destroy)\n                try {\n                    this.value.destroy();\n                }\n                catch (_) { }\n            return PluginInstance.dummy;\n        }\n    }\n    destroy(view) {\n        if (this.value.destroy) {\n            try {\n                this.value.destroy();\n            }\n            catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n}\nPluginInstance.dummy = new PluginInstance({}, ViewPlugin.define(() => ({})));\nconst editorAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst contentAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\n// Provide decorations\nconst decorations = Facet.define();\nconst styleModule = Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB) {\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for (; i > 0; i--) {\n            let range = set[i - 1];\n            if (range.fromA > me.toA)\n                continue;\n            if (range.toA < me.fromA)\n                break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0)\n            return diff;\n        let result = [];\n        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while (rI < ranges.length && ranges[rI] < end) {\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB)\n                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end)\n                    break;\n                else\n                    rI += 2;\n            }\n            if (!next)\n                return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/// View [plugins](#view.ViewPlugin) are given instances of this\n/// class, which describe what happened, whenever the view is updated.\nclass ViewUpdate {\n    /// @internal\n    constructor(\n    /// The editor view that the update is associated with.\n    view, \n    /// The new editor state.\n    state, \n    /// The transactions involved in the update. May be empty.\n    transactions = none$3) {\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /// @internal\n        this.flags = 0;\n        this.prevState = view.state;\n        this.changes = ChangeSet.empty(this.prevState.doc.length);\n        for (let tr of transactions)\n            this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            view.inputState.notifiedFocused = focus;\n            this.flags != 1 /* Focus */;\n        }\n        if (this.docChanged)\n            this.flags |= 2 /* Height */;\n    }\n    /// Tells you whether the viewport changed in this update.\n    get viewportChanged() {\n        return (this.flags & 4 /* Viewport */) > 0;\n    }\n    /// Indicates whether the line height in the editor changed in this update.\n    get heightChanged() {\n        return (this.flags & 2 /* Height */) > 0;\n    }\n    /// Returns true when the document changed or the size of the editor\n    /// or the lines or characters within it has changed.\n    get geometryChanged() {\n        return this.docChanged || (this.flags & (16 /* Geometry */ | 2 /* Height */)) > 0;\n    }\n    /// True when this update indicates a focus change.\n    get focusChanged() {\n        return (this.flags & 1 /* Focus */) > 0;\n    }\n    /// Whether the document changed in this update.\n    get docChanged() {\n        return this.transactions.some(tr => tr.docChanged);\n    }\n    /// Whether the selection was explicitly set in this update.\n    get selectionSet() {\n        return this.transactions.some(tr => tr.selection);\n    }\n    /// @internal\n    get empty() { return this.flags == 0 && this.transactions.length == 0; }\n}\n\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);\n    for (let parent = dom.parentNode; parent;) { // (Cast to any because TypeScript is useless with Node types)\n        if (parent.nodeType == 1) {\n            if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) &&\n                window.getComputedStyle(parent).overflow != \"visible\") {\n                let parentRect = parent.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(bottom, parentRect.bottom);\n            }\n            parent = parent.parentNode;\n        }\n        else if (parent.nodeType == 11) { // Shadow root\n            parent = parent.host;\n        }\n        else {\n            break;\n        }\n    }\n    return { left: left - rect.left, right: right - rect.left,\n        top: top - (rect.top + paddingTop), bottom: bottom - (rect.top + paddingTop) };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size) {\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)\n                return false;\n        }\n        return true;\n    }\n    draw(wrapping) {\n        return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical) {\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) { return other.size == this.size && other.vertical == this.vertical; }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        }\n        else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() { return this.vertical ? this.size : -1; }\n}\nclass ViewState {\n    constructor(state) {\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };\n        this.inView = true;\n        this.paddingTop = 0;\n        this.paddingBottom = 0;\n        this.contentWidth = 0;\n        this.heightOracle = new HeightOracle;\n        this.heightMap = HeightMap.empty();\n        this.scrollTo = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be signficant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        this.heightMap = this.heightMap.applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n        this.viewport = this.getViewport(0, null);\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\n        this.computeVisibleRanges();\n    }\n    update(update, scrollTo = null) {\n        let prev = this.state;\n        this.state = update.state;\n        let newDeco = this.state.facet(decorations);\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.prevState.facet(decorations), newDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight)\n            update.flags |= 2 /* Height */;\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTo && (scrollTo.head < viewport.from || scrollTo.head > viewport.to) || !this.viewportIsAppropriate(viewport))\n            viewport = this.getViewport(0, scrollTo);\n        if (!viewport.eq(this.viewport)) {\n            this.viewport = viewport;\n            update.flags |= 4 /* Viewport */;\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        this.computeVisibleRanges();\n        if (scrollTo)\n            this.scrollTo = scrollTo;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&\n            update.state.selection.primary.empty && update.state.selection.primary.assoc)\n            this.mustEnforceCursorAssoc = true;\n    }\n    measure(docView, repeated) {\n        let dom = docView.dom, whiteSpace = \"\", direction = Direction.LTR;\n        if (!repeated) {\n            // Vertical padding\n            let style = window.getComputedStyle(dom);\n            whiteSpace = style.whiteSpace, direction = (style.direction == \"rtl\" ? Direction.RTL : Direction.LTR);\n            this.paddingTop = parseInt(style.paddingTop) || 0;\n            this.paddingBottom = parseInt(style.paddingBottom) || 0;\n        }\n        // Pixel viewport\n        let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (!this.inView)\n            return 0;\n        let lineHeights = docView.measureVisibleLineHeights();\n        let refresh = false, bias = 0, result = 0, oracle = this.heightOracle;\n        if (!repeated) {\n            let contentWidth = docView.dom.clientWidth;\n            if (oracle.mustRefresh(lineHeights, whiteSpace, direction) ||\n                oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth } = docView.measureTextSize();\n                refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    docView.minWidth = 0;\n                    result |= 16 /* Geometry */;\n                }\n            }\n            if (this.contentWidth != contentWidth) {\n                this.contentWidth = contentWidth;\n                result |= 16 /* Geometry */;\n            }\n            if (dTop > 0 && dBottom > 0)\n                bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0)\n                bias = Math.min(dTop, dBottom);\n        }\n        oracle.heightChanged = false;\n        this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));\n        if (oracle.heightChanged)\n            result |= 2 /* Height */;\n        if (!this.viewportIsAppropriate(this.viewport, bias) ||\n            this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) {\n            this.viewport = this.getViewport(bias, this.scrollTo);\n            result |= 4 /* Viewport */;\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));\n        this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    getViewport(bias, scrollTo) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* Margin */ / 2));\n        let map = this.heightMap, doc = this.state.doc, { top, bottom } = this.pixelViewport;\n        let viewport = new Viewport(map.lineAt(top - marginTop * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(bottom + (1 - marginTop) * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).to);\n        // If scrollTo is given, make sure the viewport includes that position\n        if (scrollTo) {\n            if (scrollTo.head < viewport.from) {\n                let { top: newTop } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newTop - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (bottom - top) + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n            else if (scrollTo.head > viewport.to) {\n                let { bottom: newBottom } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newBottom - (bottom - top) - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\n        return (from == 0 || top <= this.pixelViewport.top - Math.max(10 /* MinCoverMargin */, Math.min(-bias, 250 /* MaxCoverMargin */))) &&\n            (to == this.state.doc.length ||\n                bottom >= this.pixelViewport.bottom + Math.max(10 /* MinCoverMargin */, Math.min(bias, 250 /* MaxCoverMargin */))) &&\n            (top > this.pixelViewport.top - 2 * 1000 /* Margin */ && bottom < this.pixelViewport.bottom + 2 * 1000 /* Margin */);\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty)\n            return gaps;\n        let mapped = [];\n        for (let gap of gaps)\n            if (!changes.touchesRange(gap.from, gap.to))\n                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current) {\n        let gaps = [];\n        // This won't work at all in predominantly right-to-left text.\n        if (this.heightOracle.direction != Direction.LTR)\n            return gaps;\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {\n            if (line.length < 10000 /* Margin */)\n                return;\n            let structure = lineStructure(line.from, line.to, this.state);\n            if (structure.total < 10000 /* Margin */)\n                return;\n            let viewFrom, viewTo;\n            if (this.heightOracle.lineWrapping) {\n                if (line.from != this.viewport.from)\n                    viewFrom = line.from;\n                else\n                    viewFrom = findPosition(structure, (this.pixelViewport.top - line.top) / line.height);\n                if (line.to != this.viewport.to)\n                    viewTo = line.to;\n                else\n                    viewTo = findPosition(structure, (this.pixelViewport.bottom - line.top) / line.height);\n            }\n            else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);\n                viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);\n            }\n            let sel = this.state.selection.primary;\n            // Make sure the gap doesn't cover a selection end\n            if (sel.from <= viewFrom && sel.to >= line.from)\n                viewFrom = sel.from;\n            if (sel.from <= line.to && sel.to >= viewTo)\n                viewTo = sel.to;\n            let gapTo = viewFrom - 10000 /* Margin */, gapFrom = viewTo + 10000 /* Margin */;\n            if (gapTo > line.from + 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000 /* HalfMargin */ && gap.to < gapTo + 5000 /* HalfMargin */) ||\n                    new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));\n            if (gapFrom < line.to - 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000 /* HalfMargin */ &&\n                    gap.from < gapFrom + 5000 /* HalfMargin */) ||\n                    new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));\n        });\n        return gaps;\n    }\n    gapSize(line, pos, start, structure) {\n        if (this.heightOracle.lineWrapping) {\n            let height = line.height * findFraction(structure, pos);\n            return start ? height : line.height - height;\n        }\n        else {\n            let ratio = findFraction(structure, pos);\n            return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\n            return 8 /* LineGaps */;\n        }\n        return 0;\n    }\n    computeVisibleRanges() {\n        let deco = this.state.facet(decorations);\n        if (this.lineGaps.length)\n            deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span(from, to) { ranges.push({ from, to }); },\n            point() { },\n            minPointSize: 20\n        });\n        this.visibleRanges = ranges;\n    }\n    lineAt(pos, editorTop) {\n        return this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    lineAtHeight(height, editorTop) {\n        return this.heightMap.lineAt(height, QueryType.ByHeight, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    blockAtHeight(height, editorTop) {\n        return this.heightMap.blockAt(height, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    forEachLine(from, to, f, editorTop) {\n        return this.heightMap.forEachLine(from, to, this.state.doc, editorTop + this.paddingTop, 0, f);\n    }\n}\n/// Indicates the range of the document that is in the visible\n/// viewport.\nclass Viewport {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n    eq(b) { return this.from == b.from && this.to == b.to; }\n}\nfunction lineStructure(from, to, state) {\n    let ranges = [], pos = from, total = 0;\n    RangeSet.spans(state.facet(decorations), from, to, {\n        span() { },\n        point(from, to) {\n            if (from > pos) {\n                ranges.push({ from: pos, to: from });\n                total += from - pos;\n            }\n            pos = to;\n        },\n        minPointSize: 20 // We're only interested in collapsed ranges of a significant size\n    });\n    if (pos < to) {\n        ranges.push({ from: pos, to });\n        total += to - pos;\n    }\n    return { total, ranges };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0)\n        return ranges[0].from;\n    if (ratio >= 1)\n        return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for (let i = 0;; i++) {\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size)\n            return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges) {\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)\n        if (f(val))\n            return val;\n    return undefined;\n}\n\nconst none$4 = [];\nclass DocView extends ContentView {\n    constructor(view) {\n        super();\n        this.view = view;\n        this.viewports = none$4;\n        this.compositionDeco = Decoration.none;\n        this.decorations = [];\n        // Track a minimum width for the editor. When measuring sizes in\n        // checkLayout, this is updated to point at the width of a given\n        // element and its extent in the document. When a change happens in\n        // that range, these are reset. That way, once we've seen a\n        // line/element of a given length, we keep the editor wide enough to\n        // fit at least that element, until it is changed, at which point we\n        // forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.setDOM(view.contentDOM);\n        this.children = [new LineView];\n        this.children[0].setParent(this);\n        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);\n    }\n    get root() { return this.view.root; }\n    get editorView() { return this.view; }\n    get length() { return this.view.state.doc.length; }\n    // Update the document view to a given state. scrollIntoView can be\n    // used as a hint to compute a new viewport that includes that\n    // position, if we know the editor is going to scroll that position\n    // into view.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = 0;\n            }\n            else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        if (!((_a = this.view.inputState) === null || _a === void 0 ? void 0 : _a.composing))\n            this.compositionDeco = Decoration.none;\n        else if (update.transactions.length)\n            this.compositionDeco = computeCompositionDeco(this.view, update.changes);\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update &&\n            update.state.doc.lines != update.prevState.doc.lines;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        let pointerSel = update.transactions.some(tr => tr.annotation(Transaction.userEvent) == \"pointerselection\");\n        if (this.dirty == 0 /* Not */ && changedRanges.length == 0 &&\n            !(update.flags & (4 /* Viewport */ | 8 /* LineGaps */)) &&\n            update.state.selection.primary.from >= this.view.viewport.from &&\n            update.state.selection.primary.to <= this.view.viewport.to) {\n            this.updateSelection(forceSelection, pointerSel);\n            return false;\n        }\n        else {\n            this.updateInner(changedRanges, deco, update.prevState.doc.length, forceSelection, pointerSel);\n            return true;\n        }\n    }\n    // Used both by update and checkLayout do perform the actual DOM\n    // update\n    updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {\n        this.updateChildren(changes, deco, oldLength);\n        this.view.observer.ignore(() => {\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.heightMap.height + \"px\";\n            this.dom.style.minWidth = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome ? { node: getSelection(this.view.root).focusNode, written: false } : undefined;\n            this.sync(track);\n            this.dirty = 0 /* Not */;\n            if (track === null || track === void 0 ? void 0 : track.written)\n                forceSelection = true;\n            this.updateSelection(forceSelection, pointerSel);\n            this.dom.style.height = \"\";\n        });\n    }\n    updateChildren(changes, deco, oldLength) {\n        let cursor = this.childCursor(oldLength);\n        for (let i = changes.length - 1;; i--) {\n            let next = i >= 0 ? changes[i] : null;\n            if (!next)\n                break;\n            let { fromA, toA, fromB, toB } = next;\n            let { content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n    }\n    replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd) {\n        let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;\n        let breakAtEnd = last ? last.breakAfter : breakAtStart;\n        // Change within a single line\n        if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 &&\n            before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0, openStart, openEnd))\n            return;\n        let after = this.children[toI];\n        // Make sure the end of the line after the update is preserved in `after`\n        if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {\n            // If we're splitting a line, separate part of the start line to\n            // avoid that being mangled when updating the start line.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                content[content.length - 1] = after;\n            }\n            else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && after.children[0].length == 0)\n                    after.merge(0, toOff, null, false, 0, openEnd);\n                content.push(after);\n            }\n        }\n        else if (after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last)\n                last.breakAfter = 1;\n            else\n                breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false, openStart, 0)) {\n                before.breakAfter = content.shift().breakAfter;\n            }\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n        // Try to merge widgets on the boundaries of the replacement\n        while (fromI < toI && content.length) {\n            if (this.children[toI - 1].match(content[content.length - 1]))\n                toI--, content.pop();\n            else if (this.children[fromI].match(content[0]))\n                fromI++, content.shift();\n            else\n                break;\n        }\n        if (fromI < toI || content.length)\n            this.replaceChildren(fromI, toI, content);\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(force = false, fromPointer = false) {\n        if (!(fromPointer || this.mayControlSelection()))\n            return;\n        let primary = this.view.state.selection.primary;\n        // FIXME need to handle the case where the selection falls inside a block range\n        let anchor = this.domAtPos(primary.anchor);\n        let head = this.domAtPos(primary.head);\n        let domSel = getSelection(this.root);\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode ||\n            (browser.gecko && primary.empty && nextToUneditable(domSel.focusNode, domSel.focusOffset)) ||\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.view.observer.ignore(() => {\n                if (primary.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* Before */ | 2 /* After */)) {\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* Before */ ? 1 : -1);\n                            if (text)\n                                anchor = new DOMPos(text, nextTo == 1 /* Before */ ? 0 : text.nodeValue.length);\n                        }\n                    }\n                    domSel.collapse(anchor.node, anchor.offset);\n                    if (primary.bidiLevel != null && domSel.cursorBidiLevel != null)\n                        domSel.cursorBidiLevel = primary.bidiLevel;\n                }\n                else if (domSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    domSel.collapse(anchor.node, anchor.offset);\n                    domSel.extend(head.node, head.offset);\n                }\n                else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (primary.anchor > primary.head)\n                        [anchor, head] = [head, anchor];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    domSel.removeAllRanges();\n                    domSel.addRange(range);\n                }\n            });\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    enforceCursorAssoc() {\n        let cursor = this.view.state.selection.primary;\n        let sel = getSelection(this.root);\n        if (!cursor.empty || !cursor.assoc || !sel.modify)\n            return;\n        let line = LineView.find(this, cursor.head); // FIXME provide view-line-range finding helper\n        if (!line)\n            return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length)\n            return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top)\n            return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n    }\n    mayControlSelection() {\n        return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, getSelection(this.root));\n    }\n    nearest(dom) {\n        for (let cur = dom; cur;) {\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this)\n                return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view)\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for (; i < this.children.length - 1;) {\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView)\n                break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        for (let off = this.length, i = this.children.length - 1;; i--) {\n            let child = this.children[i], start = off - child.breakAfter - child.length;\n            if (pos > start || pos == start && (child.type == BlockType.Text || !i || this.children[i - 1].breakAfter))\n                return child.coordsAt(pos - start, side);\n            off = start;\n        }\n    }\n    measureVisibleLineHeights() {\n        let result = [], { from, to } = this.view.viewState.viewport;\n        let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end > to)\n                break;\n            if (pos >= from) {\n                result.push(child.dom.getBoundingClientRect().height);\n                let width = child.dom.scrollWidth;\n                if (width > minWidth) {\n                    this.minWidth = minWidth = width;\n                    this.minWidthFrom = pos;\n                    this.minWidthTo = end;\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    measureTextSize() {\n        for (let child of this.children) {\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure)\n                    return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth;\n        dummy.className = \"cm-line\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(() => {\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            dummy.remove();\n        });\n        return { lineHeight, charWidth };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i)\n            pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let visible = this.view.viewState.viewport, viewports = [visible];\n        let { head, anchor } = this.view.state.selection.primary;\n        if (head < visible.from || head > visible.to) {\n            let { from, to } = this.view.viewState.lineAt(head, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        if (!viewports.some(({ from, to }) => anchor >= from && anchor <= to)) {\n            let { from, to } = this.view.viewState.lineAt(anchor, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        this.viewports = viewports.sort((a, b) => a.from - b.from);\n        let deco = [];\n        for (let pos = 0, i = 0;; i++) {\n            let next = i == viewports.length ? null : viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = this.view.viewState.lineAt(end, 0).bottom - this.view.viewState.lineAt(pos, 0).top;\n                deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));\n            }\n            if (!next)\n                break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        return this.decorations = [\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco,\n            this.compositionDeco,\n            ...this.view.state.facet(decorations),\n            ...this.view.pluginField(pluginDecorations)\n        ];\n    }\n    scrollPosIntoView(pos, side) {\n        let rect = this.coordsAt(pos, side);\n        if (!rect)\n            return;\n        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;\n        for (let margins of this.view.pluginField(PluginField.scrollMargins))\n            if (margins) {\n                let { left, right, top, bottom } = margins;\n                if (left != null)\n                    mLeft = Math.max(mLeft, left);\n                if (right != null)\n                    mRight = Math.max(mRight, right);\n                if (top != null)\n                    mTop = Math.max(mTop, top);\n                if (bottom != null)\n                    mBottom = Math.max(mBottom, bottom);\n            }\n        scrollRectIntoView(this.dom, {\n            left: rect.left - mLeft, top: rect.top - mTop,\n            right: rect.right + mRight, bottom: rect.bottom + mBottom\n        });\n    }\n}\n// Browsers appear to reserve a fixed amount of bits for height\n// styles, and ignore or clip heights above that. For Chrome and\n// Firefox, this is in the 20 million range, so we try to stay below\n// that.\nconst MaxNodeHeight = 1e7;\nclass BlockGapWidget extends WidgetType {\n    constructor(height) {\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) { return other.height == this.height; }\n    updateDOM(elt) {\n        if (this.height < MaxNodeHeight) {\n            while (elt.lastChild)\n                elt.lastChild.remove();\n            elt.style.height = this.height + \"px\";\n        }\n        else {\n            elt.style.height = \"\";\n            for (let remaining = this.height; remaining > 0; remaining -= MaxNodeHeight) {\n                let fill = elt.appendChild(document.createElement(\"div\"));\n                fill.style.height = Math.min(remaining, MaxNodeHeight) + \"px\";\n            }\n        }\n        return true;\n    }\n    get estimatedHeight() { return this.height; }\n}\nfunction computeCompositionDeco(view, changes) {\n    let sel = getSelection(view.root);\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n    if (!textNode)\n        return Decoration.none;\n    let cView = view.docView.nearest(textNode);\n    let from, to, topNode = textNode;\n    if (cView instanceof InlineView) {\n        while (cView.parent instanceof InlineView)\n            cView = cView.parent;\n        from = cView.posAtStart;\n        to = from + cView.length;\n        topNode = cView.dom;\n    }\n    else if (cView instanceof LineView) {\n        while (topNode.parentNode != cView.dom)\n            topNode = topNode.parentNode;\n        let prev = topNode.previousSibling;\n        while (prev && !ContentView.get(prev))\n            prev = prev.previousSibling;\n        from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n    }\n    else {\n        return Decoration.none;\n    }\n    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));\n    let text = textNode.nodeValue, { state } = view;\n    if (newTo - newFrom < text.length) {\n        if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text)\n            newTo = newFrom + text.length;\n        else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text)\n            newFrom = newTo - text.length;\n        else\n            return Decoration.none;\n    }\n    else if (state.sliceDoc(newFrom, newTo) != text) {\n        return Decoration.none;\n    }\n    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(topNode, textNode) }).range(newFrom, newTo));\n}\nclass CompositionWidget extends WidgetType {\n    constructor(top, text) {\n        super();\n        this.top = top;\n        this.text = text;\n    }\n    eq(other) { return this.top == other.top && this.text == other.text; }\n    toDOM() { return this.top; }\n    ignoreEvent() { return false; }\n    get customView() { return CompositionView; }\n}\nfunction nearbyTextNode(node, offset, side) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0 && side <= 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1)\n        return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* Before */ : 0) |\n        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* After */ : 0);\n}\nclass DecorationComparator$1 {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange(from, to) { addRange(from, to, this.changes); }\n    comparePoint(from, to) { addRange(from, to, this.changes); }\n}\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\n\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0)\n        return EditorSelection.cursor(pos);\n    if (linePos == 0)\n        bias = 1;\n    else if (linePos == line.length)\n        bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0)\n        from = line.findClusterBreak(linePos, false);\n    else\n        to = line.findClusterBreak(linePos, true);\n    let cat = categorize(line.slice(from, to));\n    while (from > 0) {\n        let prev = line.findClusterBreak(from, false);\n        if (categorize(line.slice(prev, from)) != cat)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = line.findClusterBreak(to, true);\n        if (categorize(line.slice(to, next)) != cat)\n            break;\n        to = next;\n    }\n    return EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\n// FIXME holding arrow-up/down at the end of the viewport is a rather\n// common use case that will repeatedly trigger this code. Maybe\n// introduce some element of binary search after all?\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY;\n    let above, below, aboveRect, belowRect;\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        let rects = clientRectsFor(child);\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect))\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0)\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                }\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            }\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            }\n            else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    }\n    else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest)\n        return { node: parent, offset: 0 };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3)\n        return domPosInText(closest, clipX, y);\n    if (!closestX && closest.contentEditable == \"true\")\n        return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return { node: parent, offset };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length, range = tempRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rects = range.getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (rect.top == rect.bottom)\n                continue;\n            if (rect.left - 1 <= x && rect.right + 1 >= x &&\n                rect.top - 1 <= y && rect.bottom + 1 >= y) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    range.setEnd(node, i);\n                    let rectBefore = range.getBoundingClientRect();\n                    if (rectBefore.left == rect.right)\n                        after = !right;\n                }\n                return { node, offset: i + (after ? 1 : 0) };\n            }\n        }\n    }\n    return { node, offset: 0 };\n}\nfunction posAtCoords(view, { x, y }, bias = -1) {\n    let content = view.contentDOM.getBoundingClientRect(), block;\n    let halfLine = view.defaultLineHeight / 2;\n    for (let bounced = false;;) {\n        block = view.blockAtHeight(y, content.top);\n        if (block.top > y || block.bottom < y) {\n            bias = block.top > y ? -1 : 1;\n            y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));\n            if (bounced)\n                return -1;\n            else\n                bounced = true;\n        }\n        if (block.type == BlockType.Text)\n            break;\n        y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n    }\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from)\n        return view.viewport.from == 0 ? 0 : null;\n    if (lineStart > view.viewport.to)\n        return view.viewport.to == view.state.doc.length ? view.state.doc.length : null;\n    // Clip x to the viewport sides\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    let root = view.root, element = root.elementFromPoint(x, y);\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {\n        if (root.caretPositionFromPoint) {\n            let pos = root.caretPositionFromPoint(x, y);\n            if (pos)\n                ({ offsetNode: node, offset } = pos);\n        }\n        else if (root.caretRangeFromPoint) {\n            let range = root.caretRangeFromPoint(x, y);\n            if (range)\n                ({ startContainer: node, startOffset: offset } = range);\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    return view.docView.posFromDOM(node, offset);\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = view.state.doc.lineAt(start.head);\n    let coords = !includeWrap || !view.lineWrapping ? null\n        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let pos = view.posAtCoords({ x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2 });\n        if (pos != null)\n            return EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    let lineView = LineView.find(view.docView, start.head);\n    let end = lineView ? (forward ? lineView.posAtEnd : lineView.posAtStart) : (forward ? line.to : line.from);\n    return EditorSelection.cursor(end, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    for (let cur = start, check = null;;) {\n        let next = moveVisually(line, spans, view.textDirection, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1))\n                return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = EditorSelection.cursor(forward ? line.from : line.to);\n        }\n        if (!check) {\n            if (!by)\n                return next;\n            check = by(char);\n        }\n        else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next) => {\n        let nextCat = categorize(next);\n        if (cat == CharCategory.Space)\n            cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    var _a;\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0))\n        return EditorSelection.cursor(startPos);\n    let startCoords = view.coordsAtPos(startPos);\n    if (startCoords) {\n        let rect = view.dom.getBoundingClientRect();\n        let goal = (_a = start.goalColumn) !== null && _a !== void 0 ? _a : startCoords.left - rect.left;\n        let resolvedGoal = rect.left + goal;\n        let dist = distance !== null && distance !== void 0 ? distance : 5;\n        for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, extra = 0; extra < 50; extra += 10) {\n            let pos = posAtCoords(view, { x: resolvedGoal, y: startY + (dist + extra) * dir }, dir);\n            if (pos == null)\n                break;\n            if (pos != startPos)\n                return EditorSelection.cursor(pos, undefined, undefined, goal);\n        }\n    }\n    // Outside of the drawn viewport, use a crude column-based approach\n    let { doc } = view.state, line = doc.lineAt(startPos), tabSize = view.state.tabSize;\n    let goal = start.goalColumn, goalCol = 0;\n    if (goal == null) {\n        for (const iter = doc.iterRange(line.from, startPos); !iter.next().done;)\n            goalCol = countColumn(iter.value, goalCol, tabSize);\n        goal = goalCol * view.defaultCharacterWidth;\n    }\n    else {\n        goalCol = Math.round(goal / view.defaultCharacterWidth);\n    }\n    if (dir < 0 && line.from == 0)\n        return EditorSelection.cursor(0);\n    else if (dir > 0 && line.to == doc.length)\n        return EditorSelection.cursor(line.to);\n    let otherLine = doc.line(line.number + dir);\n    let result = otherLine.from;\n    let seen = 0;\n    for (const iter = doc.iterRange(otherLine.from, otherLine.to); seen >= goalCol && !iter.next().done;) {\n        const { offset, leftOver } = findColumn(iter.value, seen, goalCol, tabSize);\n        seen = goalCol - leftOver;\n        result += offset;\n    }\n    return EditorSelection.cursor(result, undefined, undefined, goal);\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n    constructor(view) {\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.scrollHandlers = [];\n        this.registeredEvents = [];\n        this.customHandlers = [];\n        this.composing = false;\n        this.compositionEndedAt = 0;\n        this.mouseSelection = null;\n        for (let type in handlers) {\n            let handler = handlers[type];\n            view.contentDOM.addEventListener(type, (event) => {\n                if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))\n                    return;\n                if (this.mustFlushObserver(event))\n                    view.observer.forceFlush();\n                if (this.runCustomHandlers(type, view, event))\n                    event.preventDefault();\n                else\n                    handler(view, event);\n            });\n            this.registeredEvents.push(type);\n        }\n        // Must always run, even if a custom handler handled the event\n        view.contentDOM.addEventListener(\"keydown\", (event) => {\n            view.inputState.lastKeyCode = event.keyCode;\n            view.inputState.lastKeyTime = Date.now();\n        });\n        this.notifiedFocused = view.hasFocus;\n        this.ensureHandlers(view);\n    }\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    ensureHandlers(view) {\n        let handlers = this.customHandlers = view.pluginField(domEventHandlers);\n        for (let set of handlers) {\n            for (let type in set.handlers)\n                if (this.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\n                    this.registeredEvents.push(type);\n                    view.contentDOM.addEventListener(type, (event) => {\n                        if (!eventBelongsToEditor(view, event))\n                            return;\n                        if (this.runCustomHandlers(type, view, event))\n                            event.preventDefault();\n                    });\n                }\n        }\n    }\n    runCustomHandlers(type, view, event) {\n        for (let set of this.customHandlers) {\n            let handler = set.handlers[type];\n            if (handler) {\n                try {\n                    if (handler.call(set.plugin, event, view) || event.defaultPrevented)\n                        return true;\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n            }\n        }\n        return false;\n    }\n    runScrollHandlers(view, event) {\n        for (let set of this.customHandlers) {\n            let handler = set.handlers.scroll;\n            if (handler) {\n                try {\n                    handler.call(set.plugin, event, view);\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n            }\n        }\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type))\n            return false;\n        if (this.composing)\n            return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && event.timeStamp - this.compositionEndedAt < 500) {\n            this.compositionEndedAt = 0;\n            return true;\n        }\n        return false;\n    }\n    mustFlushObserver(event) {\n        return event.type == \"keydown\" || event.type == \"compositionend\";\n    }\n    startMouseSelection(view, event, style) {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n        this.mouseSelection = new MouseSelection(this, view, event, style);\n    }\n    update(update) {\n        if (this.mouseSelection)\n            this.mouseSelection.update(update);\n        this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n    }\n}\nclass MouseSelection {\n    constructor(inputState, view, startEvent, style) {\n        this.inputState = inputState;\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragMove = dragMovesSelection$1(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) ? null : false;\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) {\n            startEvent.preventDefault();\n            this.select(startEvent);\n        }\n    }\n    move(event) {\n        if (event.buttons == 0)\n            return this.destroy();\n        if (this.dragging !== false)\n            return;\n        this.select(event);\n    }\n    up(event) {\n        if (this.dragging == null)\n            this.select(this.startEvent);\n        if (!this.dragging)\n            event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.inputState.mouseSelection = null;\n    }\n    select(event) {\n        let selection = this.style.get(event, this.extend, this.multiple);\n        if (!selection.eq(this.view.state.selection) || selection.primary.assoc != this.view.state.selection.primary.assoc)\n            this.view.dispatch({\n                selection,\n                annotations: Transaction.userEvent.of(\"pointerselection\"),\n                scrollIntoView: true\n            });\n    }\n    update(update) {\n        if (update.docChanged && this.dragging)\n            this.dragging = this.dragging.map(update.changes);\n        this.style.update(update);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection$1(view, event) {\n    let facet = view.state.facet(dragMovesSelection);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { primary } = view.state.selection;\n    if (primary.empty)\n        return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (sel.rangeCount == 0)\n        return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\n            return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)\n        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))\n            return false;\n    return true;\n}\nconst handlers = Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n    (browser.ios && browser.webkit_version < 604);\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, input) {\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        changes = {\n            changes: state.selection.ranges.map(r => state.doc.lineAt(r.from))\n                .filter((l, i, a) => i == 0 || a[i - 1] != l)\n                .map(line => ({ from: line.from, insert: (byLine ? text.line(i++).slice() : input) + state.lineBreak }))\n        };\n    }\n    else if (byLine) {\n        changes = state.changeByRange(range => {\n            let line = text.line(i++);\n            return { changes: { from: range.from, to: range.to, insert: line.slice() },\n                range: EditorSelection.cursor(range.from + line.length) };\n        });\n    }\n    else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        annotations: Transaction.userEvent.of(\"paste\"),\n        scrollIntoView: true\n    });\n}\nfunction mustCapture(event) {\n    let mods = (event.ctrlKey ? 1 /* Ctrl */ : 0) | (event.metaKey ? 8 /* Meta */ : 0) |\n        (event.altKey ? 2 /* Alt */ : 0) | (event.shiftKey ? 4 /* Shift */ : 0);\n    let code = event.keyCode, macCtrl = browser.mac && mods == 1 /* Ctrl */;\n    return code == 8 || (macCtrl && code == 72) || // Backspace, Ctrl-h on Mac\n        code == 46 || (macCtrl && code == 68) || // Delete, Ctrl-d on Mac\n        code == 27 || // Esc\n        (mods == (browser.mac ? 8 /* Meta */ : 1 /* Ctrl */) && // Ctrl/Cmd-[biyz]\n            (code == 66 || code == 73 || code == 89 || code == 90));\n}\nhandlers.keydown = (view, event) => {\n    if (mustCapture(event))\n        event.preventDefault();\n    view.inputState.setSelectionOrigin(\"keyboardselection\");\n};\nhandlers.touchdown = handlers.touchmove = view => {\n    view.inputState.setSelectionOrigin(\"pointerselection\");\n};\nhandlers.mousedown = (view, event) => {\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\n        style = makeStyle(view, event);\n        if (style)\n            break;\n    }\n    if (!style && event.button == 0)\n        style = basicMouseSelection(view, event);\n    if (style) {\n        if (view.root.activeElement != view.contentDOM)\n            view.observer.ignore(() => focusPreventScroll(view.contentDOM));\n        view.inputState.startMouseSelection(view, event, style);\n    }\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) { // Single click\n        return EditorSelection.cursor(pos, bias);\n    }\n    else if (type == 2) { // Double click\n        return groupAt(view.state, pos, bias);\n    }\n    else { // Triple click\n        let line = LineView.find(view.docView, pos);\n        if (line)\n            return EditorSelection.range(line.posAtStart, line.posAtEnd);\n        let { from, to } = view.state.doc.lineAt(pos);\n        return EditorSelection.range(from, to);\n    }\n}\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line)\n        return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0)\n        return 1;\n    if (off == line.length)\n        return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before))\n        return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after))\n        return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // beside it.\n    return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    if (pos == null)\n        return null;\n    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail)\n        return event.detail;\n    let last = lastMouseDown;\n    lastMouseDown = event;\n    return lastMouseDownCount = !last || (last.timeStamp > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&\n        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    let last = start, lastEvent = event;\n    return {\n        update(update) {\n            if (update.changes) {\n                if (start)\n                    start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, extend, multiple) {\n            let cur;\n            if (event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY)\n                cur = last;\n            else {\n                cur = last = queryPos(view, event);\n                lastEvent = event;\n            }\n            if (!cur || !start)\n                return startSel;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);\n            }\n            if (extend)\n                return startSel.replaceRange(startSel.primary.extend(range.from, range.to));\n            else if (multiple)\n                return startSel.addRange(range);\n            else\n                return EditorSelection.create([range]);\n        }\n    };\n}\nhandlers.dragstart = (view, event) => {\n    let { selection: { primary } } = view.state;\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection)\n        mouseSelection.dragging = primary;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(primary.from, primary.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n};\nhandlers.drop = (view, event) => {\n    if (!event.dataTransfer)\n        return;\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    let text = event.dataTransfer.getData(\"Text\");\n    if (dropPos == null || !text)\n        return;\n    event.preventDefault();\n    let { mouseSelection } = view.inputState;\n    let del = mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ?\n        { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;\n    let ins = { from: dropPos, insert: text };\n    let changes = view.state.changes(del ? [del, ins] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },\n        annotations: Transaction.userEvent.of(\"drop\")\n    });\n};\nhandlers.paste = (view, event) => {\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = data && data.getData(\"text/plain\");\n    if (text) {\n        doPaste(view, text);\n        event.preventDefault();\n    }\n    else {\n        capturePaste(view);\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(() => {\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)\n        if (!range.empty) {\n            content.push(state.sliceDoc(range.from, range.to));\n            ranges.push(range);\n        }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges) {\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.slice());\n                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return { text: content.join(state.lineBreak), ranges, linewise };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event) => {\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text)\n        return;\n    lastLinewiseCopy = linewise ? text : null;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, text);\n    }\n    if (event.type == \"cut\")\n        view.dispatch({\n            changes: ranges,\n            scrollIntoView: true,\n            annotations: Transaction.userEvent.of(\"cut\")\n        });\n};\nhandlers.focus = handlers.blur = view => {\n    setTimeout(() => {\n        if (view.hasFocus != view.inputState.notifiedFocused)\n            view.update([]);\n    }, 10);\n};\nhandlers.beforeprint = view => {\n    view.viewState.printing = true;\n    view.requestMeasure();\n    setTimeout(() => {\n        view.viewState.printing = false;\n        view.requestMeasure();\n    }, 2000);\n};\nfunction forceClearComposition(view) {\n    if (view.docView.compositionDeco.size)\n        view.update([]);\n}\nhandlers.compositionstart = handlers.compositionupdate = view => {\n    if (!view.inputState.composing) {\n        if (view.docView.compositionDeco.size) {\n            view.observer.flush();\n            forceClearComposition(view);\n        }\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = true;\n    }\n};\nhandlers.compositionend = view => {\n    view.inputState.composing = false;\n    view.inputState.compositionEndedAt = Date.now();\n    setTimeout(() => {\n        if (!view.inputState.composing)\n            forceClearComposition(view);\n    }, 50);\n};\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view, onChange, onScrollChanged) {\n        this.view = view;\n        this.onChange = onChange;\n        this.onScrollChanged = onScrollChanged;\n        this.active = false;\n        this.ignoreSelection = new DOMSelection;\n        this.delayedFlush = -1;\n        this.queue = [];\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.intersecting = false;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver(mutations => {\n            for (let mut of mutations)\n                this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM\n            if (browser.ie && browser.ie_version <= 11 &&\n                mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n                this.flushSoon();\n            else\n                this.flush();\n        });\n        if (useCharData)\n            this.onCharData = (event) => {\n                this.queue.push({ target: event.target,\n                    type: \"characterData\",\n                    oldValue: event.prevValue });\n                this.flushSoon();\n            };\n        this.onSelectionChange = (event) => {\n            if (this.view.root.activeElement != this.dom)\n                return;\n            let sel = getSelection(this.view.root);\n            let context = sel.anchorNode && this.view.docView.nearest(sel.anchorNode);\n            if (context && context.ignoreEvent(event))\n                return;\n            // Deletions on IE11 fire their events in the wrong order, giving\n            // us a selection change event before the DOM changes are\n            // reported.\n            // (Selection.isCollapsed isn't reliable on IE)\n            if (browser.ie && browser.ie_version <= 11 && !this.view.state.selection.primary.empty &&\n                sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n                this.flushSoon();\n            else\n                this.flush();\n        };\n        this.start();\n        this.onScroll = this.onScroll.bind(this);\n        window.addEventListener(\"scroll\", this.onScroll);\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver(entries => {\n                if (this.parentCheck < 0)\n                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {});\n            this.intersection.observe(this.dom);\n        }\n        this.listenForScroll();\n    }\n    onScroll(e) {\n        if (this.intersecting) {\n            this.flush();\n            this.onScrollChanged(e);\n        }\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for (let dom = this.dom; dom;) {\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\n                    i++;\n                else if (!changed)\n                    changed = this.scrollTargets.slice(0, i);\n                if (changed)\n                    changed.push(dom);\n                dom = dom.parentNode;\n            }\n            else if (dom.nodeType == 11) { // Shadow root\n                dom = dom.host;\n            }\n            else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed)\n            changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)\n                dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)\n                dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active)\n            return f();\n        try {\n            this.stop();\n            return f();\n        }\n        finally {\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active)\n            return;\n        this.observer.observe(this.dom, observeOptions);\n        // FIXME is this shadow-root safe?\n        this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active)\n            return;\n        this.active = false;\n        this.observer.disconnect();\n        this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    clearSelection() {\n        this.ignoreSelection.set(getSelection(this.view.root));\n    }\n    // Throw away any pending changes\n    clear() {\n        this.observer.takeRecords();\n        this.queue.length = 0;\n        this.clearSelection();\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0)\n            this.delayedFlush = window.setTimeout(() => { this.delayedFlush = -1; this.flush(); }, 20);\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            window.clearTimeout(this.delayedFlush);\n            this.delayedFlush = -1;\n            this.flush();\n        }\n    }\n    // Apply pending changes, if any\n    flush() {\n        if (this.delayedFlush >= 0)\n            return;\n        let records = this.queue;\n        for (let mut of this.observer.takeRecords())\n            records.push(mut);\n        if (records.length)\n            this.queue = [];\n        let selection = getSelection(this.view.root);\n        let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);\n        if (records.length == 0 && !newSel)\n            return;\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records) {\n            let range = this.readMutation(record);\n            if (!range)\n                continue;\n            if (range.typeOver)\n                typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            }\n            else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        let startState = this.view.state;\n        if (from > -1 || newSel)\n            this.onChange(from, to, typeOver);\n        if (this.view.state == startState) { // The view wasn't updated\n            if (this.view.docView.dirty) {\n                this.ignore(() => this.view.docView.sync());\n                this.view.docView.dirty = 0 /* Not */;\n            }\n            this.view.docView.updateSelection();\n        }\n        this.clearSelection();\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec))\n            return null;\n        cView.markDirty();\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\n        }\n        else { // \"characterData\"\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\n        }\n    }\n    destroy() {\n        this.stop();\n        if (this.intersection)\n            this.intersection.disconnect();\n        for (let dom of this.scrollTargets)\n            dom.removeEventListener(\"scroll\", this.onScroll);\n        window.removeEventListener(\"scroll\", this.onScroll);\n        clearTimeout(this.parentCheck);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while (dom) {\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView)\n            return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n\nfunction applyDOMChange(view, start, end, typeOver) {\n    let change, newSel;\n    let sel = view.state.selection.primary, bounds;\n    if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {\n        let { from, to } = bounds;\n        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view.contentDOM, view.root);\n        let reader = new DOMReader(selPoints, view.state.lineBreak);\n        reader.readRange(bounds.startDOM, bounds.endDOM);\n        newSel = selectionFromPoints(selPoints, from);\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed\n        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);\n        if (diff)\n            change = { from: from + diff.from, to: from + diff.toA,\n                insert: view.state.toText(reader.text.slice(diff.from, diff.toB)) };\n    }\n    else if (view.hasFocus) {\n        let domSel = getSelection(view.root);\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ? view.state.selection.primary.head\n            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset\n            ? view.state.selection.primary.anchor\n            : selectionCollapsed(domSel) ? head : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n        if (head != sel.head || anchor != sel.anchor)\n            newSel = EditorSelection.single(anchor, head);\n    }\n    if (!change && !newSel)\n        return;\n    // Heuristic to notice typing over a selected character\n    if (!change && typeOver && !sel.empty && newSel && newSel.primary.empty)\n        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };\n    if (change) {\n        let startState = view.state;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events.\n        if (browser.android &&\n            ((change.from == sel.from && change.to == sel.to &&\n                change.insert.length == 1 && change.insert.lines == 2 &&\n                dispatchKey(view, \"Enter\", 10)) ||\n                (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 &&\n                    dispatchKey(view, \"Backspace\", 8)) ||\n                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&\n                    dispatchKey(view, \"Delete\", 46))))\n            return;\n        let text = change.insert.toString();\n        if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text)))\n            return;\n        let tr;\n        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3) {\n            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) +\n                after));\n        }\n        else {\n            let changes = startState.changes(change);\n            tr = {\n                changes,\n                selection: newSel && !startState.selection.primary.eq(newSel.primary) && newSel.primary.to <= changes.newLength\n                    ? startState.selection.replaceRange(newSel.primary) : undefined\n            };\n        }\n        view.dispatch(tr, { scrollIntoView: true, annotations: Transaction.userEvent.of(\"input\") });\n    }\n    else if (newSel && !newSel.primary.eq(sel)) {\n        let scrollIntoView = false, annotations;\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"keyboardselection\")\n                scrollIntoView = true;\n            else\n                annotations = Transaction.userEvent.of(view.inputState.lastSelectionOrigin);\n        }\n        view.dispatch({ selection: newSel, scrollIntoView, annotations });\n    }\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\n        from++;\n    if (from == minLen && a.length == b.length)\n        return null;\n    let toA = a.length, toB = b.length;\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    }\n    else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return { from, toA, toB };\n}\nclass DOMReader {\n    constructor(points, lineSep) {\n        this.points = points;\n        this.lineSep = lineSep;\n        this.text = \"\";\n    }\n    readRange(start, end) {\n        if (!start)\n            return;\n        let parent = start.parentNode;\n        for (let cur = start;;) {\n            this.findPointBefore(parent, cur);\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end)\n                break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if ((view ? view.breakAfter : isBlockElement(cur)) ||\n                ((nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == \"BR\" && !cur.cmIgnore)))\n                this.text += this.lineSep;\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n    }\n    readNode(node) {\n        if (node.cmIgnore)\n            return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        let text;\n        if (fromView != null)\n            text = fromView.sliceString(0, undefined, this.lineSep);\n        else if (node.nodeType == 3)\n            text = node.nodeValue;\n        else if (node.nodeName == \"BR\")\n            text = node.nextSibling ? this.lineSep : \"\";\n        else if (node.nodeType == 1)\n            this.readRange(node.firstChild, null);\n        if (text != null) {\n            this.findPointIn(node, text.length);\n            this.text += text;\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)\n            if (point.node == node && node.childNodes[point.offset] == next)\n                point.pos = this.text.length;\n    }\n    findPointIn(node, maxLen) {\n        for (let point of this.points)\n            if (point.node == node)\n                point.pos = this.text.length + Math.min(point.offset, maxLen);\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset) {\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nfunction selectionPoints(dom, root) {\n    let result = [];\n    if (root.activeElement != dom)\n        return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = getSelection(root);\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\n            result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0)\n        return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base, head + base) : null;\n}\nfunction dispatchKey(view, name, code) {\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\n    let down = new KeyboardEvent(\"keydown\", options);\n    view.contentDOM.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    view.contentDOM.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/// An editor view represents the editor's user interface. It holds\n/// the editable DOM surface, and possibly other elements such as the\n/// line number gutter. It handles events and dispatches state\n/// transactions for editing actions.\nclass EditorView {\n    /// Construct a new view. You'll usually want to put `view.dom` into\n    /// your document after creating a view, so that the user can see\n    /// it.\n    constructor(\n    /// Configuration options.\n    config = {}) {\n        this.plugins = [];\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        /// @internal\n        this.updateState = 2 /* Updating */;\n        /// @internal\n        this.measureScheduled = -1;\n        /// @internal\n        this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.className = themeClass(\"scroller\");\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.scrollDOM);\n        this._dispatch = config.dispatch || ((tr) => this.update([tr]));\n        this.dispatch = this.dispatch.bind(this);\n        this.root = (config.root || document);\n        this.viewState = new ViewState(config.state || EditorState.create());\n        this.plugins = this.state.facet(viewPlugin).map(spec => PluginInstance.create(spec, this));\n        this.observer = new DOMObserver(this, (from, to, typeOver) => {\n            applyDOMChange(this, from, to, typeOver);\n        }, event => {\n            this.inputState.runScrollHandlers(this, event);\n            this.measure();\n        });\n        this.docView = new DocView(this);\n        this.inputState = new InputState(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        ensureGlobalHandler();\n        this.requestMeasure();\n        if (config.parent)\n            config.parent.appendChild(this.dom);\n    }\n    /// The current editor state.\n    get state() { return this.viewState.state; }\n    /// To be able to display large documents without consuming too much\n    /// memory or overloading the browser, CodeMirror only draws the\n    /// code that is visible (plus a margin around it) to the DOM. This\n    /// property tells you the extent of the current drawn viewport, in\n    /// document positions.\n    get viewport() { return this.viewState.viewport; }\n    /// When there are, for example, large collapsed ranges in the\n    /// viewport, its size can be a lot bigger than the actual visible\n    /// content. Thus, if you are doing something like styling the\n    /// content in the viewport, it is preferable to only do so for\n    /// these ranges, which are the subset of the viewport that is\n    /// actually drawn.\n    get visibleRanges() { return this.viewState.visibleRanges; }\n    /// Returns false when the editor is entirely scrolled out of view\n    /// or otherwise hidden.\n    get inView() { return this.viewState.inView; }\n    /// Indicates whether the user is currently composing text via\n    /// [IME](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide).\n    get composing() { return this.inputState.composing; }\n    dispatch(...input) {\n        this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0]\n            : this.state.update(...input));\n    }\n    /// Update the view for the given array of transactions. This will\n    /// update the visible document and selection to match the state\n    /// produced by the transactions, and notify view plugins of the\n    /// change. You should usually call\n    /// [`dispatch`](#view.EditorView.dispatch) instead, which uses this\n    /// as a primitive.\n    update(transactions) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, update;\n        this.updateState = 2 /* Updating */;\n        try {\n            let state = this.state;\n            for (let tr of transactions) {\n                if (tr.startState != state)\n                    throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n                state = tr.state;\n            }\n            update = new ViewUpdate(this, state, transactions);\n            let scrollTo = transactions.some(tr => tr.scrollIntoView) ? state.selection.primary : null;\n            this.viewState.update(update, scrollTo);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty)\n                this.updatePlugins(update);\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules)\n                this.mountStyles();\n            this.updateAttrs();\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        if (redrawn || scrollTo || this.viewState.mustEnforceCursorAssoc)\n            this.requestMeasure();\n        for (let listener of this.state.facet(updateListener))\n            listener(update);\n    }\n    /// Reset the view to the given state. (This will cause the entire\n    /// document to be redrawn and all view plugins to be reinitialized,\n    /// so you should probably only use it when the new state isn't\n    /// derived from the old state. Otherwise, use\n    /// [`update`](#view.EditorView.update) instead.)\n    setState(newState) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        this.updateState = 2 /* Updating */;\n        try {\n            for (let plugin of this.plugins)\n                plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map(spec => PluginInstance.create(spec, this));\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.prevState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [], reused = [];\n            for (let spec of specs) {\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(PluginInstance.create(spec, this));\n                }\n                else {\n                    let plugin = this.plugins[found].update(update);\n                    reused.push(plugin);\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)\n                if (reused.indexOf(plugin) < 0)\n                    plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.inputState.ensureHandlers(this);\n        }\n        else {\n            for (let i = 0; i < this.plugins.length; i++)\n                this.plugins[i] = this.plugins[i].update(update);\n        }\n    }\n    /// @internal\n    measure() {\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n        this.measureScheduled = -1; // Prevent requestMeasure calls from scheduling another animation frame\n        let updated = null;\n        try {\n            for (let i = 0;; i++) {\n                this.updateState = 1 /* Measuring */;\n                let changed = this.viewState.measure(this.docView, i > 0);\n                let measuring = this.measureRequests;\n                if (!changed && !measuring.length && this.viewState.scrollTo == null)\n                    break;\n                this.measureRequests = [];\n                if (i > 5) {\n                    console.warn(\"Viewport failed to stabilize\");\n                    break;\n                }\n                let measured = measuring.map(m => {\n                    try {\n                        return m.read(this);\n                    }\n                    catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = new ViewUpdate(this, this.state);\n                update.flags |= changed;\n                if (!updated)\n                    updated = update;\n                else\n                    updated.flags |= changed;\n                this.updateState = 2 /* Updating */;\n                this.updatePlugins(update);\n                this.updateAttrs();\n                if (changed)\n                    this.docView.update(update);\n                for (let i = 0; i < measuring.length; i++)\n                    if (measured[i] != BadMeasure) {\n                        try {\n                            measuring[i].write(measured[i], this);\n                        }\n                        catch (e) {\n                            logException(this.state, e);\n                        }\n                    }\n                if (this.viewState.scrollTo) {\n                    this.docView.scrollPosIntoView(this.viewState.scrollTo.head, this.viewState.scrollTo.assoc);\n                    this.viewState.scrollTo = null;\n                }\n                if (!(changed & 4 /* Viewport */) && this.measureRequests.length == 0)\n                    break;\n            }\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        this.measureScheduled = -1;\n        if (updated)\n            for (let listener of this.state.facet(updateListener))\n                listener(updated);\n    }\n    /// Get the CSS classes for the currently active editor themes.\n    get themeClasses() {\n        return baseThemeID + \" \" +\n            (this.state.facet(darkTheme) ? \"cm-dark\" : \"cm-light\") + \" \" +\n            this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {\n            class: themeClass(\"wrap\") + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n        this.editorAttrs = editorAttrs;\n        let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {\n            spellcheck: \"false\",\n            contenteditable: String(this.state.facet(editable)),\n            class: themeClass(\"content\"),\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        });\n        updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n        this.contentAttrs = contentAttrs;\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());\n    }\n    /// Find the DOM parent node and offset (child offset if `node` is\n    /// an element, character offset when it is a text node) at the\n    /// given document position.\n    domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /// Find the document position at the given DOM node. Can be useful\n    /// for associating positions with DOM events. Will raise an error\n    /// when `node` isn't part of the editor content.\n    posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* Updating */)\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* Idle */ && this.measureScheduled > -1)\n            this.measure();\n    }\n    /// Make sure plugins get a chance to measure the DOM before the\n    /// next frame. Calling this is preferable to messing with the DOM\n    /// directly from, for example, an even handler, because it'll make\n    /// sure measuring and drawing done by other components is\n    /// synchronized, avoiding unnecessary DOM layout computations.\n    requestMeasure(request) {\n        if (this.measureScheduled < 0)\n            this.measureScheduled = requestAnimationFrame(() => this.measure());\n        if (request) {\n            if (request.key != null)\n                for (let i = 0; i < this.measureRequests.length; i++) {\n                    if (this.measureRequests[i].key === request.key) {\n                        this.measureRequests[i] = request;\n                        return;\n                    }\n                }\n            this.measureRequests.push(request);\n        }\n    }\n    /// Collect all values provided by the active plugins for a given\n    /// field.\n    pluginField(field) {\n        // FIXME make this error when called during plugin updating\n        let result = [];\n        for (let plugin of this.plugins)\n            plugin.takeField(field, result);\n        return result;\n    }\n    /// Get the value of a specific plugin, if present. Note that\n    /// plugins that crash can be dropped from a view, so even when you\n    /// know you registered a given plugin, it is recommended to check\n    /// the return value of this method.\n    plugin(plugin) {\n        for (let inst of this.plugins)\n            if (inst.spec == plugin)\n                return inst.value;\n        return null;\n    }\n    /// Find the line or block widget at the given vertical position.\n    /// `editorTop`, if given, provides the vertical position of the top\n    /// of the editor. It defaults to the editor's screen position\n    /// (which will force a DOM layout).\n    blockAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.blockAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find information for the visual line (see\n    /// [`visualLineAt`](#view.EditorView.visualLineAt)) at the given\n    /// vertical position. The resulting block info might hold another\n    /// array of block info structs in its `type` field if this line\n    /// consists of more than one block.\n    ///\n    /// Heights are interpreted relative to the given `editorTop`\n    /// position. When not given, the top position of the editor's\n    /// [content element](#view.EditorView.contentDOM) is taken.\n    visualLineAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.lineAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find the extent and height of the visual line (the content shown\n    /// in the editor as a line, which may be smaller than a document\n    /// line when broken up by block widgets, or bigger than a document\n    /// line when line breaks are covered by replaced decorations) at\n    /// the given position.\n    ///\n    /// Vertical positions are computed relative to the `editorTop`\n    /// argument. You can pass `view.dom.getBoundingClientRect().top`\n    /// here to get screen coordinates.\n    visualLineAt(pos, editorTop = 0) {\n        return this.viewState.lineAt(pos, editorTop);\n    }\n    /// Iterate over the height information of the lines in the\n    /// viewport.\n    viewportLines(f, editorTop) {\n        let { from, to } = this.viewport;\n        this.viewState.forEachLine(from, to, f, ensureTop(editorTop, this.contentDOM));\n    }\n    /// The editor's total content height.\n    get contentHeight() {\n        return this.viewState.heightMap.height + this.viewState.paddingTop + this.viewState.paddingBottom;\n    }\n    /// Move a cursor position by [grapheme\n    /// cluster](#text.nextClusterBreak). `forward` determines whether\n    /// the motion is away from the line start, or towards it. Motion in\n    /// bidirectional text is in visual order, in the editor's [text\n    /// direction](#view.EditorView.textDirection). When the start\n    /// position was the last one on the line, the returned position\n    /// will be across the line break. If there is no further line, the\n    /// original position is returned.\n    moveByChar(start, forward, by) {\n        return moveByChar(this, start, forward, by);\n    }\n    /// Move a cursor position across the next group of either\n    /// [letters](#state.EditorState.charCategorizer) or non-letter\n    /// non-whitespace characters.\n    moveByGroup(start, forward) {\n        return moveByChar(this, start, forward, initial => byGroup(this, start.head, initial));\n    }\n    /// Move to the next line boundary in the given direction. If\n    /// `includeWrap` is true, line wrapping is on, and there is a\n    /// further wrap point on the current line, the wrap point will be\n    /// returned. Otherwise this function will return the start or end\n    /// of the line.\n    moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /// Move a cursor position vertically. When `distance` isn't given,\n    /// it defaults to moving to the next line (including wrapped\n    /// lines). Otherwise, `distance` should provide a positive distance\n    /// in pixels.\n    ///\n    /// When `start` has a\n    /// [`goalColumn`](#state.SelectionRange.goalColumn), the vertical\n    /// motion will use that as a target horizontal position. Otherwise,\n    /// the cursor's own horizontal position is used. The returned\n    /// cursor will have its goal column set to whichever column was\n    /// used.\n    moveVertically(start, forward, distance) {\n        return moveVertically(this, start, forward, distance);\n    }\n    /// Scroll the given document position into view.\n    scrollPosIntoView(pos) {\n        this.viewState.scrollTo = EditorSelection.cursor(pos);\n        this.requestMeasure();\n    }\n    /// Get the document position at the given screen coordinates.\n    /// Returns null if no valid position could be found.\n    posAtCoords(coords) {\n        this.readMeasured();\n        return posAtCoords(this, coords);\n    }\n    /// Get the screen coordinates at the given document position.\n    coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right)\n            return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));\n    }\n    /// The default width of a character in the editor. May not\n    /// accurately reflect the width of all characters.\n    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }\n    /// The default height of a line in the editor.\n    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }\n    /// The text direction (`direction` CSS property) of the editor.\n    get textDirection() { return this.viewState.heightOracle.direction; }\n    /// Whether this editor [wraps lines](#view.EditorView.lineWrapping)\n    /// (as determined by the `white-space` CSS property of its content\n    /// element).\n    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }\n    /// Returns the bidirectional text structure of the given line\n    /// (which should be in the current document) as an array of span\n    /// objects. The order of these spans matches the [text\n    /// direction](#view.EditorView.textDirection)—if that is\n    /// left-to-right, the leftmost spans come first, otherwise the\n    /// rightmost spans come first.\n    bidiSpans(line) {\n        if (line.length > MaxBidiLine)\n            return trivialOrder(line.length);\n        let dir = this.textDirection;\n        for (let entry of this.bidiCache)\n            if (entry.from == line.from && entry.dir == dir)\n                return entry.order;\n        let order = computeOrder(line.slice(), this.textDirection);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));\n        return order;\n    }\n    /// Check whether the editor has focus.\n    get hasFocus() {\n        return document.hasFocus() && this.root.activeElement == this.contentDOM;\n    }\n    /// Put focus on the editor.\n    focus() {\n        this.observer.ignore(() => {\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /// Clean up this editor view, removing its element from the\n    /// document, unregistering event handlers, and notifying\n    /// plugins. The view instance can no longer be used after\n    /// calling this.\n    destroy() {\n        for (let plugin of this.plugins)\n            plugin.destroy(this);\n        this.inputState.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n    }\n    /// Facet that can be used to add DOM event handlers. The value\n    /// should be an object mapping event names to handler functions. The\n    /// first such function to return true will be assumed to have handled\n    /// that event, and no other handlers or built-in behavior will be\n    /// activated for it.\n    /// These are registered on the [content\n    /// element](#view.EditorView.contentDOM), except for `scroll`\n    /// handlers, which will be called any time the editor's [scroll\n    /// element](#view.EditorView.scrollDOM) or one of its parent nodes\n    /// is scrolled.\n    static domEventHandlers(handlers) {\n        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });\n    }\n    /// Create a theme extension. The first argument can be a\n    /// [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    /// style spec providing the styles for the theme. These will be\n    /// prefixed with a generated class for the style.\n    ///\n    /// It is highly recommended you use _theme classes_, rather than\n    /// regular CSS classes, in your selectors. These are prefixed with\n    /// a `$` instead of a `.`, and will be expanded (as with\n    /// [`themeClass`](#view.themeClass)) to one or more prefixed class\n    /// names. So for example `$content` targets the editor's [content\n    /// element](#view.EditorView.contentDOM).\n    ///\n    /// Because the selectors will be prefixed with a scope class,\n    /// directly matching the editor's [wrapper\n    /// element](#view.EditorView.dom), which is the element on which\n    /// the scope class will be added, needs to be explicitly\n    /// differentiated by adding an additional `$` to the front of the\n    /// pattern. For example `$$focused $panel` will expand to something\n    /// like `.[scope].cm-focused .cm-panel`.\n    ///\n    /// When `dark` is set to true, the theme will be marked as dark,\n    /// which will add the `$dark` selector to the wrapper element (as\n    /// opposed to `$light` when a light theme is active).\n    static theme(spec, options) {\n        let prefix = StyleModule.newName();\n        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${baseThemeID}.${prefix}`, spec))];\n        if (options && options.dark)\n            result.push(darkTheme.of(true));\n        return result;\n    }\n    /// Create an extension that adds styles to the base theme. The\n    /// given object works much like the one passed to\n    /// [`theme`](#view.EditorView^theme). You'll often want to qualify\n    /// base styles with `$dark` or `$light` so they only apply when\n    /// there is a dark or light theme active. For example `\"$$dark\n    /// $myHighlight\"`.\n    static baseTheme(spec) {\n        return precedence(styleModule.of(buildTheme(\".\" + baseThemeID, spec)), \"fallback\");\n    }\n}\n/// Facet to add a [style\n/// module](https://github.com/marijnh/style-mod#documentation) to\n/// an editor view. The view will ensure that the module is\n/// registered in its [document\n/// root](#view.EditorView.constructor^config.root).\nEditorView.styleModule = styleModule;\n/// An input handler can be used to override the way changes to the\n/// content are handled. A handler is passed the document positions\n/// between which the change was found, and the new content. When it\n/// returns true, no further input handlers are called and the\n/// default behavior is prevented.\nEditorView.inputHandler = inputHandler;\n/// Allows you to provide a function that should be called when the\n/// library catches an exception from an extension (mostly from view\n/// plugins, but may be used by other extensions to route exceptions\n/// from user-code-provided callbacks). This is mostly useful for\n/// debugging and logging. See [`logException`](#view.logException).\nEditorView.exceptionSink = exceptionSink;\n/// A facet that can be used to have a listener function be notified\n/// every time the view updates.\nEditorView.updateListener = updateListener;\n/// Facet that controls whether the editor content is editable. When\n/// its the highest-precedence value is `false`, editing is\n/// disabled, and the content element will no longer have its\n/// `contenteditable` attribute set to `true`. (Note that this\n/// doesn't affect API calls that change the editor content, even\n/// when those are bound to keys or buttons.)\nEditorView.editable = editable;\n/// Facet used to configure whether a given selection drag event\n/// should move or copy the selection. The given predicate will be\n/// called with the `mousedown` event, and can return `true` when\n/// the drag should move the content.\nEditorView.dragMovesSelection = dragMovesSelection;\n/// Facet used to configure whether a given selecting click adds\n/// a new range to the existing selection or replaces it entirely.\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/// Allows you to influence the way mouse selection happens. The\n/// functions in this facet will be called for a `mousedown` event\n/// on the editor, and can return an object that overrides the way a\n/// selection is computed from that mouse click or drag.\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\n/// A facet that determines which [decorations](#view.Decoration)\n/// are shown in the view. See also [view\n/// plugins](#view.EditorView^decorations), which have a separate\n/// mechanism for providing decorations.\nEditorView.decorations = decorations;\n/// An extension that enables line wrapping in the editor.\nEditorView.lineWrapping = EditorView.theme({ $content: { whiteSpace: \"pre-wrap\" } });\n/// Facet that provides attributes for the editor's editable DOM\n/// element.\nEditorView.contentAttributes = contentAttributes;\n/// Facet that provides editor DOM attributes for the editor's\n/// outer element.\nEditorView.editorAttributes = editorAttributes;\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nfunction ensureTop(given, dom) {\n    return given == null ? dom.getBoundingClientRect().top : given;\n}\nlet resizeDebounce = -1;\nfunction ensureGlobalHandler() {\n    window.addEventListener(\"resize\", () => {\n        if (resizeDebounce == -1)\n            resizeDebounce = setTimeout(handleResize, 50);\n    });\n}\nfunction handleResize() {\n    resizeDebounce = -1;\n    let found = document.querySelectorAll(\".cm-content\");\n    for (let i = 0; i < found.length; i++) {\n        let docView = ContentView.get(found[i]);\n        if (docView)\n            docView.editorView.requestMeasure();\n    }\n}\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, order) {\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty)\n            return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))\n                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));\n        }\n        return result;\n    }\n}\n\nconst currentPlatform = typeof navigator == \"undefined\" ? \"key\"\n    : /Mac/.test(navigator.platform) ? \"mac\"\n        : /Win/.test(navigator.platform) ? \"win\"\n            : /Linux|X11/.test(navigator.platform) ? \"linux\"\n                : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; ++i) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\")\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\nconst keymaps = Facet.define();\nconst handleKeyEvents = EditorView.domEventHandlers({\n    keydown(event, view) {\n        return runHandlers(view.state.facet(keymaps), event, view, \"editor\");\n    }\n});\n/// Create a view extension that registers a keymap.\n///\n/// You can add multiple keymap extensions to an editor. Their\n/// priorities determine their precedence (the ones specified early or\n/// with high priority get checked first). When a handler has returned\n/// `true` for a given key, no further handlers are called.\n///\n/// When a key is bound multiple times (either in a single keymap or\n/// in separate maps), the bound commands all get a chance to handle\n/// the key stroke, in order of precedence, until one of them returns\n/// true.\nfunction keymap(bindings, platform) {\n    return [handleKeyEvents, keymaps.of(buildKeymap(bindings, platform))];\n}\n/// Run the key handlers registered for a given scope. Returns true if\n/// any of them handled the event.\nfunction runScopeHandlers(view, event, scope) {\n    return runHandlers(view.state.facet(keymaps), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is) => {\n        let current = isPrefix[name];\n        if (current == null)\n            isPrefix[name] = is;\n        else if (current != is)\n            throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault) => {\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\n        for (let i = 1; i < parts.length; i++) {\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix])\n                scopeObj[prefix] = {\n                    preventDefault: true,\n                    commands: [(view) => {\n                            let ourObj = storedPrefix = { view, prefix, scope };\n                            setTimeout(() => { if (storedPrefix == ourObj)\n                                storedPrefix = null; }, PrefixTimeout);\n                            return true;\n                        }]\n                };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });\n        binding.commands.push(command);\n        if (preventDefault)\n            binding.preventDefault = true;\n    };\n    for (let b of bindings) {\n        let name = b[platform] || b.key;\n        if (!name)\n            continue;\n        for (let scope of b.scope ? b.scope.split(\" \") : [\"editor\"]) {\n            add(scope, name, b.run, b.preventDefault);\n            if (b.shift)\n                add(scope, \"Shift-\" + name, b.shift, b.preventDefault);\n        }\n    }\n    return bound;\n}\nfunction runHandlers(maps, event, view, scope) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \";\n    let prefix = \"\";\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        storedPrefix = null;\n    }\n    let fallthrough = !!prefix;\n    let runFor = (binding) => {\n        if (binding) {\n            for (let cmd of binding.commands)\n                if (cmd(view))\n                    return true;\n            if (binding.preventDefault)\n                fallthrough = true;\n        }\n        return false;\n    };\n    for (let map of maps) {\n        let scopeObj = map[scope], baseName;\n        if (!scopeObj)\n            continue;\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))\n            return true;\n        if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&\n            (baseName = base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))\n                return true;\n        }\n        else if (isChar && event.shiftKey) {\n            if (runFor(scopeObj[prefix + modifiers(name, event, true)]))\n                return true;\n        }\n    }\n    return fallthrough;\n}\n\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b) => Math.min(a, b),\n            drawRangeCursor: (a, b) => a || b\n        });\n    }\n});\n/// Returns an extension that hides the browser's native selection and\n/// cursor, replacing the selection with a background behind the text\n/// (labeled with the `$selectionBackground` theme class), and the\n/// cursors with elements overlaid over the code (using\n/// `$cursor.primary` and `$cursor.secondary`).\n///\n/// This allows the editor to display secondary selection ranges, and\n/// tends to produce a type of selection more in line with that users\n/// expect in a text editor (the native selection styling will often\n/// leave gaps between lines and won't fill the horizontal space after\n/// a line when the selection continues past it).\n///\n/// It does have a performance cost, in that it requires an extra DOM\n/// layout cycle for many updates (the selection is drawn based on DOM\n/// layout information that's only available after laying out the\n/// content).\nfunction drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        drawSelectionPlugin,\n        hideNativeSelection\n    ];\n}\nclass Piece {\n    constructor(left, top, width, height, className) {\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n        this.className = className;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width >= 0)\n            elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n        return elt;\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&\n            this.className == p.className;\n    }\n}\nconst drawSelectionPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.selectionLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.selectionLayer.className = themeClass(\"selectionLayer\");\n        this.selectionLayer.setAttribute(\"aria-hidden\", \"true\");\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = themeClass(\"cursorLayer\");\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n    }\n    update(update) {\n        let confChanged = update.prevState.facet(selectionConfig) != update.state.facet(selectionConfig);\n        if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)\n            this.view.requestMeasure(this.measureReq);\n        if (update.transactions.some(tr => tr.scrollIntoView))\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        if (confChanged)\n            this.setBlinkRate();\n    }\n    readPos() {\n        let { state } = this.view, conf = state.facet(selectionConfig);\n        let rangePieces = state.selection.ranges.map(r => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.primary;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let piece = measureCursor(this.view, r, prim);\n                if (piece)\n                    cursors.push(piece);\n            }\n        }\n        return { rangePieces, cursors };\n    }\n    drawSel({ rangePieces, cursors }) {\n        if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {\n            this.selectionLayer.textContent = \"\";\n            for (let p of rangePieces)\n                this.selectionLayer.appendChild(p.draw());\n            this.rangePieces = rangePieces;\n        }\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            this.cursorLayer.textContent = \"\";\n            for (let c of cursors)\n                this.cursorLayer.appendChild(c.draw());\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.selectionLayer.remove();\n        this.cursorLayer.remove();\n    }\n});\nconst themeSpec = {\n    $line: {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" }\n    }\n};\nif (CanHidePrimary)\n    themeSpec.$line.caretColor = \"transparent !important\";\nconst hideNativeSelection = precedence(EditorView.theme(themeSpec), \"override\");\nconst selectionClass = themeClass(\"selectionBackground\");\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    return { left: rect.left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\n}\nfunction wrappedLine(view, pos, inside) {\n    let range = EditorSelection.cursor(pos);\n    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from) };\n}\nfunction measureRange(view, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to)\n        return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineStyle = window.getComputedStyle(content.firstChild);\n    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);\n    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);\n    let visualStart = view.visualLineAt(from);\n    let visualEnd = view.visualLineAt(to);\n    if (view.lineWrapping) {\n        visualStart = wrappedLine(view, from, visualStart);\n        visualEnd = wrappedLine(view, to, visualEnd);\n    }\n    if (visualStart.from == visualEnd.from) {\n        return pieces(drawForLine(range.from, range.to));\n    }\n    else {\n        let top = drawForLine(range.from, null);\n        let bottom = drawForLine(null, range.to);\n        let between = [];\n        if (visualStart.to < visualEnd.from - 1)\n            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && bottom.top - top.bottom < 4)\n            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new Piece(left - base.left, top - base.top, right - left, bottom - top, selectionClass);\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for (let i = 0; i < horizontal.length; i += 2)\n            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            let fromCoords = view.coordsAtPos(from, 1), toCoords = view.coordsAtPos(to, -1);\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR)\n                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else\n                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : view.moveToLineBoundary(EditorSelection.cursor(to, 1), false).head;\n        let end = to !== null && to !== void 0 ? to : view.moveToLineBoundary(EditorSelection.cursor(from, -1), true).head;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)\n            if (r.to > start && r.from < end) {\n                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {\n                    let docLine = view.state.doc.lineAt(pos);\n                    for (let span of view.bidiSpans(docLine)) {\n                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                        if (spanFrom >= endPos)\n                            break;\n                        if (spanTo > pos)\n                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                    }\n                    pos = docLine.to + 1;\n                    if (pos >= endPos)\n                        break;\n                }\n            }\n        if (horizontal.length == 0) {\n            let coords = view.coordsAtPos(start, -1);\n            top = Math.min(coords.top, top);\n            bottom = Math.max(coords.bottom, bottom);\n        }\n        return { top, bottom, horizontal };\n    }\n}\nconst primaryCursorClass = themeClass(\"cursor.primary\");\nconst cursorClass = themeClass(\"cursor.secondary\");\nfunction measureCursor(view, cursor, primary) {\n    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);\n    if (!pos)\n        return null;\n    let base = getBase(view);\n    return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? primaryCursorClass : cursorClass);\n}\n\nconst Specials = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200c\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/gu;\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = (styles.tabSize || styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst specialCharConfig = Facet.define({\n    combine(configs) {\n        // FIXME make configurations compose properly\n        let config = combineConfig(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize())\n            config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars)\n            config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/// Returns an extension that installs highlighting of special\n/// characters.\nfunction highlightSpecialChars(\n/// Configuration options.\nconfig = {}) {\n    let ext = [specialCharConfig.of(config), specialCharPlugin];\n    if (!supportsTabSize())\n        ext.push(tabStyle);\n    return ext;\n}\nconst specialCharPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = Decoration.none;\n        this.decorationCache = Object.create(null);\n        this.recompute();\n    }\n    update(update) {\n        let confChange = update.prevState.facet(specialCharConfig) != update.state.facet(specialCharConfig);\n        if (confChange)\n            this.decorationCache = Object.create(null);\n        if (confChange || update.changes.length || update.viewportChanged)\n            this.recompute();\n    }\n    recompute() {\n        let decorations = [];\n        for (let { from, to } of this.view.visibleRanges)\n            this.getDecorationsFor(from, to, decorations);\n        this.decorations = Decoration.set(decorations);\n    }\n    getDecorationsFor(from, to, target) {\n        let config = this.view.state.facet(specialCharConfig);\n        let { doc } = this.view.state;\n        for (let pos = from, cursor = doc.iterRange(from, to), m; !cursor.next().done;) {\n            if (!cursor.lineBreak) {\n                while (m = config.specialChars.exec(cursor.value)) {\n                    let code = codePointAt(m[0], 0), deco;\n                    if (code == null)\n                        continue;\n                    if (code == 9) {\n                        let line = doc.lineAt(pos + m.index);\n                        let size = this.view.state.tabSize, col = countColumn(doc.sliceString(line.from, pos + m.index), 0, size);\n                        deco = Decoration.replace({ widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth) });\n                    }\n                    else {\n                        deco = this.decorationCache[code] ||\n                            (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(config, code) }));\n                    }\n                    target.push(deco.range(pos + m.index, pos + m.index + m[0].length));\n                }\n            }\n            pos += cursor.value.length;\n        }\n    }\n}, {\n    decorations: v => v.decorations\n});\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeHolder(code) {\n    if (code >= 32)\n        return null;\n    if (code == 10)\n        return \"\\u2424\";\n    return String.fromCharCode(9216 + code);\n}\nconst DefaultPlaceholder = \"\\u2022\";\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code) {\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) { return other.code == this.code; }\n    toDOM() {\n        let ph = placeHolder(this.code) || DefaultPlaceholder;\n        let desc = \"Control character \" + (Names[this.code] || this.code);\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom)\n            return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.style.color = \"red\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nclass TabWidget extends WidgetType {\n    constructor(width) {\n        super();\n        this.width = width;\n    }\n    eq(other) { return other.width == this.width; }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\\t\";\n        span.className = tab;\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nconst tab = StyleModule.newName(), tabStyle = EditorView.styleModule.of(new StyleModule({\n    [\".\" + tab]: {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    }\n}));\n\nclass Placeholder extends WidgetType {\n    constructor(content) {\n        super();\n        this.content = content;\n    }\n    toDOM() {\n        let wrap = document.createElement(\"span\");\n        wrap.className = themeClass(\"placeholder\");\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n        if (typeof this.content == \"string\")\n            wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else\n            wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    ignoreEvent() { return false; }\n}\n/// Extension that enables a placeholder—a piece of extample content\n/// to show when the editor is empty.\nfunction placeholder(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]);\n        }\n        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }\n    }, { decorations: v => v.decorations });\n}\n\n/// @internal\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };\n\nexport { BidiSpan, BlockInfo, BlockType, Decoration, Direction, EditorView, PluginField, PluginFieldProvider, ViewPlugin, ViewUpdate, WidgetType, __test, drawSelection, highlightSpecialChars, keymap, logException, placeholder, runScopeHandlers, themeClass };\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapping = exports.map = exports.match = exports.tuple = exports.injection = exports.projection = exports.dereference = exports.constant = exports.identifier = exports.isVariant = exports.Variant = exports.unit = exports.isRecord = exports.Record = exports.isLiteralValue = exports.isNamedNode = exports.isPointer = exports.Pointer = exports.instance = exports.isCoproduct = exports.coproduct = exports.isProduct = exports.product = exports.isLiteral = exports.literal = exports.isUri = exports.uri = exports.isReference = exports.reference = exports.schema = void 0;\n\nvar N3 = _interopRequireWildcard(require(\"n3.ts\"));\n\nvar _utils = require(\"./utils.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst schema = labels => Object.freeze(labels);\n\nexports.schema = schema;\n\nconst reference = value => Object.freeze({\n  type: \"reference\",\n  value\n});\n\nexports.reference = reference;\n\nconst isReference = type => type.type === \"reference\";\n\nexports.isReference = isReference;\n\nconst uri = () => Object.freeze({\n  type: \"uri\"\n});\n\nexports.uri = uri;\n\nconst isUri = type => type.type === \"uri\";\n\nexports.isUri = isUri;\n\nconst literal = datatype => Object.freeze({\n  type: \"literal\",\n  datatype\n});\n\nexports.literal = literal;\n\nconst isLiteral = type => type.type === \"literal\";\n\nexports.isLiteral = isLiteral;\n\nconst product = components => Object.freeze({\n  type: \"product\",\n  components: Object.freeze(components)\n});\n\nexports.product = product;\n\nconst isProduct = type => type.type === \"product\";\n\nexports.isProduct = isProduct;\n\nconst coproduct = options => Object.freeze({\n  type: \"coproduct\",\n  options: Object.freeze(options)\n});\n\nexports.coproduct = coproduct;\n\nconst isCoproduct = type => type.type === \"coproduct\";\n\nexports.isCoproduct = isCoproduct;\n\nconst instance = (schema, instance) => {\n  for (const [{}, values] of (0, _utils.forEntries)(instance)) {\n    Object.freeze(values);\n  }\n\n  return Object.freeze(instance);\n};\n\nexports.instance = instance;\n\nclass Pointer {\n  constructor(index) {\n    this.index = index;\n    Object.freeze(this);\n  }\n\n  get termType() {\n    return \"Pointer\";\n  }\n\n}\n\nexports.Pointer = Pointer;\n\nconst isPointer = value => value.termType === \"Pointer\";\n\nexports.isPointer = isPointer;\n\nconst isNamedNode = value => value.termType === \"NamedNode\";\n\nexports.isNamedNode = isNamedNode;\n\nconst isLiteralValue = value => value.termType === \"Literal\";\n\nexports.isLiteralValue = isLiteralValue;\n\nclass Record extends Array {\n  get termType() {\n    return \"Record\";\n  }\n\n  constructor(components, values) {\n    super(...values);\n    this.components = components;\n    Object.freeze(this);\n  }\n\n  get(key) {\n    const index = this.components.indexOf(key);\n\n    if (index in this) {\n      return this[index];\n    } else {\n      throw new Error(`Index out of range: ${index}`);\n    }\n  }\n\n  map(f) {\n    const result = new Array(this.length);\n\n    for (const [i, value] of this.entries()) {\n      result[i] = f(value, i, this);\n    }\n\n    return result;\n  }\n\n}\n\nexports.Record = Record;\n\nconst isRecord = value => value.termType === \"Record\";\n\nexports.isRecord = isRecord;\nconst unitKeys = [];\nconst unitValues = [];\n\nconst unit = () => new Record(unitKeys, unitValues);\n\nexports.unit = unit;\n\nclass Variant {\n  constructor(options, key, value) {\n    this.options = options;\n    this.key = key;\n    this.value = value;\n    this.index = options.indexOf(key);\n\n    if (this.index in options) {\n      Object.freeze(this);\n    } else {\n      throw new Error(\"Varint index out of range\");\n    }\n  }\n\n  get termType() {\n    return \"Variant\";\n  }\n\n  is(key) {\n    return key === this.key;\n  }\n\n}\n\nexports.Variant = Variant;\n\nconst isVariant = value => value.termType === \"Variant\";\n\nexports.isVariant = isVariant;\n\nconst identifier = value => Object.freeze({\n  type: \"identifier\",\n  value\n});\n\nexports.identifier = identifier;\n\nconst constant = (value, datatype) => Object.freeze({\n  type: \"constant\",\n  value,\n  datatype\n});\n\nexports.constant = constant;\n\nconst dereference = key => Object.freeze({\n  type: \"dereference\",\n  key\n});\n\nexports.dereference = dereference;\n\nconst projection = key => Object.freeze({\n  type: \"projection\",\n  key\n});\n\nexports.projection = projection;\n\nconst injection = key => Object.freeze({\n  type: \"injection\",\n  key\n});\n\nexports.injection = injection;\n\nconst tuple = slots => Object.freeze({\n  type: \"tuple\",\n  slots: Object.freeze(slots)\n});\n\nexports.tuple = tuple;\n\nconst match = cases => Object.freeze({\n  type: \"match\",\n  cases: Object.freeze(cases)\n});\n\nexports.match = match;\n\nconst map = (source, value) => Object.freeze({\n  type: \"map\",\n  source,\n  value\n});\n\nexports.map = map;\n\nconst mapping = maps => Object.freeze(maps);\n\nexports.mapping = mapping;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  APG: true,\n  ns: true\n};\nexports.ns = exports.APG = void 0;\n\nvar APG = _interopRequireWildcard(require(\"./apg.js\"));\n\nexports.APG = APG;\n\nvar ns = _interopRequireWildcard(require(\"./namespace.js\"));\n\nexports.ns = ns;\n\nvar _mapping = require(\"./mapping.js\");\n\nObject.keys(_mapping).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _mapping[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _mapping[key];\n    }\n  });\n});\n\nvar _morphism = require(\"./morphism.js\");\n\nObject.keys(_morphism).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _morphism[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _morphism[key];\n    }\n  });\n});\n\nvar _type = require(\"./type.js\");\n\nObject.keys(_type).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _type[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _type[key];\n    }\n  });\n});\n\nvar _value = require(\"./value.js\");\n\nObject.keys(_value).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _value[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _value[key];\n    }\n  });\n});\n\nvar _utils = require(\"./utils.js\");\n\nObject.keys(_utils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _utils[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _utils[key];\n    }\n  });\n});\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateMapping = validateMapping;\nexports.fold = fold;\nexports.map = map;\nexports.delta = delta;\nexports.mapExpressions = void 0;\n\nvar N3 = _interopRequireWildcard(require(\"n3.ts\"));\n\nvar _ziterable = _interopRequireDefault(require(\"ziterable\"));\n\nvar APG = _interopRequireWildcard(require(\"./apg.js\"));\n\nvar _morphism = require(\"./morphism.js\");\n\nvar _utils = require(\"./utils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction validateMapping(M, S, T) {\n  for (const [key, type] of (0, _utils.forEntries)(S)) {\n    if (!(key in M)) {\n      return false;\n    }\n\n    const {\n      source,\n      value\n    } = M[key];\n\n    if ((0, _morphism.validateExpressions)(S, value, T[source], fold(M, S, T, type))) {\n      continue;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction fold(M, S, T, type) {\n  if (type.type === \"reference\") {\n    const {\n      source\n    } = M[type.value];\n    const value = T[source];\n\n    if (value === undefined) {\n      throw new Error(\"Invalid reference index\");\n    } else {\n      return value;\n    }\n  } else if (type.type === \"uri\") {\n    return type;\n  } else if (type.type === \"literal\") {\n    return type;\n  } else if (type.type === \"product\") {\n    return APG.product((0, _utils.mapKeys)(type.components, value => fold(M, S, T, value)));\n  } else if (type.type === \"coproduct\") {\n    return APG.coproduct((0, _utils.mapKeys)(type.options, value => fold(M, S, T, value)));\n  } else {\n    (0, _utils.signalInvalidType)(type);\n  }\n}\n\nconst mapExpressions = (expressions, value, instance, schema) => expressions.reduce((value, expression) => map(expression, value, instance, schema), value);\n\nexports.mapExpressions = mapExpressions;\n\nfunction map(expression, value, instance, schema) {\n  if (expression.type === \"identifier\") {\n    return new N3.NamedNode(expression.value);\n  } else if (expression.type === \"constant\") {\n    return new N3.Literal(expression.value, \"\", new N3.NamedNode(expression.datatype));\n  } else if (expression.type === \"dereference\") {\n    if (value.termType === \"Pointer\") {\n      const {\n        key\n      } = expression;\n\n      if (key in instance && value.index in instance[key]) {\n        return instance[key][value.index];\n      } else {\n        throw new Error(\"Invalid pointer dereference\");\n      }\n    } else {\n      throw new Error(\"Invalid pointer dereference\");\n    }\n  } else if (expression.type === \"projection\") {\n    if (value.termType === \"Record\") {\n      return value.get(expression.key);\n    } else {\n      throw new Error(\"Invalid projection\");\n    }\n  } else if (expression.type === \"match\") {\n    if (value.termType === \"Variant\") {\n      if (value.key in expression.cases) {\n        const c = expression.cases[value.key];\n        return mapExpressions(c, value.value, instance, schema);\n      } else {\n        throw new Error(\"Invalid case analysis\");\n      }\n    } else {\n      throw new Error(\"Invalid match morphism\");\n    }\n  } else if (expression.type === \"tuple\") {\n    const keys = (0, _utils.getKeys)(expression.slots);\n    return new APG.Record(keys, keys.map(key => mapExpressions(expression.slots[key], value, instance, schema)));\n  } else if (expression.type === \"injection\") {\n    return new APG.Variant(Object.freeze([expression.key]), expression.key, value);\n  } else {\n    (0, _utils.signalInvalidType)(expression);\n  }\n}\n\nfunction delta(M, S, T, TI) {\n  const SI = (0, _utils.mapKeys)(S, () => []);\n  const indices = (0, _utils.mapKeys)(S, () => new Map());\n\n  for (const [key, type] of (0, _utils.forEntries)(S)) {\n    if (!(key in M) || !(key in indices)) {\n      throw new Error(\"Invalid mapping\");\n    }\n\n    const {\n      source\n    } = M[key];\n\n    if (!(source in TI)) {\n      throw new Error(\"Invalid instance\");\n    }\n\n    for (const value of TI[source]) {\n      if (indices[key].has(value)) {\n        continue;\n      } else {\n        const imageValue = mapExpressions(M[key].value, value, TI, T);\n        const i = SI[key].push(placeholder) - 1;\n        indices[key].set(value, i);\n        SI[key][i] = pullback({\n          M,\n          S,\n          T,\n          SI,\n          TI,\n          indices\n        }, type, imageValue);\n      }\n    }\n  }\n\n  for (const key of (0, _utils.getKeys)(S)) {\n    Object.freeze(SI[key]);\n  }\n\n  Object.freeze(SI);\n  return SI;\n}\n\nconst placeholder = new N3.NamedNode(_utils.rootId);\n\nfunction pullback(state, type, // in source\nvalue) {\n  if (type.type === \"reference\") {\n    // Here we actually know that value is an instance of M1[type.value]\n    // So now what?\n    // First we check to see if the value is in the index cache.\n    // (We're ultimately going to return a Pointer for sure)\n    const index = state.indices[type.value].get(value);\n\n    if (index !== undefined) {\n      return new APG.Pointer(index);\n    } else {\n      // Otherwise, we map value along the morphism M2[type.value].\n      // This gives us a value that is an instance of the image of the referenced type\n      // - ie an instance of fold(M1, T, S[type.value].value)\n      const t = state.S[type.value];\n      const m = state.M[type.value];\n      const v = mapExpressions(m.value, value, state.TI, state.T);\n      const index = state.SI[type.value].push(placeholder) - 1;\n      state.indices[type.value].set(value, index);\n      const p = pullback(state, t, v);\n      state.SI[type.value][index] = p;\n      return new APG.Pointer(index);\n    }\n  } else if (type.type === \"uri\") {\n    if (value.termType !== \"NamedNode\") {\n      throw new Error(\"Invalid image value: expected iri\");\n    } else {\n      return value;\n    }\n  } else if (type.type === \"literal\") {\n    if (value.termType !== \"Literal\") {\n      throw new Error(\"Invalid image value: expected literal\");\n    } else {\n      return value;\n    }\n  } else if (type.type === \"product\") {\n    if (value.termType !== \"Record\") {\n      throw new Error(\"Invalid image value: expected record\");\n    } else {\n      return new APG.Record(value.components, pullbackComponents(state, type, value));\n    }\n  } else if (type.type === \"coproduct\") {\n    if (value.termType !== \"Variant\") {\n      throw new Error(\"Invalid image value: expected variant\");\n    } else if (value.key in type.options) {\n      return new APG.Variant(value.options, value.key, pullback(state, type.options[value.key], value.value));\n    } else {\n      throw new Error(\"Invalid image variant\");\n    }\n  } else {\n    (0, _utils.signalInvalidType)(type);\n  }\n}\n\nfunction* pullbackComponents(state, type, value) {\n  for (const [k1, k2, field] of (0, _ziterable.default)((0, _utils.getKeys)(type.components), value.components, value)) {\n    if (k1 === k2) {\n      yield pullback(state, type.components[k1], field);\n    } else {\n      throw new Error(\"Invalid image record\");\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.apply = apply;\nexports.validateExpressions = validateExpressions;\nexports.applyExpressions = void 0;\n\nvar APG = _interopRequireWildcard(require(\"./apg.js\"));\n\nvar _type = require(\"./type.js\");\n\nvar _utils = require(\"./utils.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst applyExpressions = (S, expressions, source) => expressions.reduce((type, expression) => apply(S, expression, type), source);\n\nexports.applyExpressions = applyExpressions;\n\nfunction apply(S, expression, source) {\n  if (expression.type === \"identifier\") {\n    return APG.uri();\n  } else if (expression.type === \"constant\") {\n    return APG.literal(expression.datatype);\n  } else if (expression.type === \"dereference\") {\n    if (source.type === \"reference\" && source.value in S && source.value === expression.key) {\n      return S[source.value];\n    } else {\n      throw new Error(\"Invalid dereference morphism\");\n    }\n  } else if (expression.type === \"projection\") {\n    if (source.type === \"product\" && expression.key in source.components) {\n      return source.components[expression.key];\n    } else {\n      throw new Error(\"Invalid projection morphism\");\n    }\n  } else if (expression.type === \"injection\") {\n    const {\n      key\n    } = expression;\n    return APG.coproduct({\n      [key]: source\n    });\n  } else if (expression.type === \"tuple\") {\n    return APG.product((0, _utils.mapKeys)(expression.slots, value => applyExpressions(S, value, source)));\n  } else if (expression.type === \"match\") {\n    if (source.type === \"coproduct\") {\n      const cases = Array.from(applyCases(S, source, expression));\n\n      if (cases.length === 0) {\n        throw new Error(\"Empty case analysis\");\n      } else {\n        return cases.reduce(_type.unify);\n      }\n    } else {\n      throw new Error(\"Invalid match morphism\");\n    }\n  } else {\n    (0, _utils.signalInvalidType)(expression);\n  }\n}\n\nfunction* applyCases(S, source, {\n  cases\n}) {\n  for (const key of (0, _utils.getKeys)(source.options)) {\n    if (key in cases) {\n      yield applyExpressions(S, cases[key], source.options[key]);\n    } else {\n      throw new Error(\"Invalid case analysis\");\n    }\n  }\n}\n\nfunction validateExpressions(S, expressions, source, target) {\n  let type;\n\n  try {\n    type = applyExpressions(S, expressions, source);\n  } catch (e) {\n    return false;\n  }\n\n  return (0, _type.isTypeAssignable)(type, target);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.map = exports.path = exports.CASE = exports.match = exports.slot = exports.tuple = exports.injection = exports.projection = exports.dereference = exports.constant = exports.identifier = exports.identity = exports.expression = exports.tail = exports.head = exports.some = exports.none = exports.target = exports.source = exports.value = exports.key = exports.option = exports.component = exports.coproduct = exports.product = exports.datatype = exports.literal = exports.uri = exports.reference = exports.label = void 0;\nconst label = \"http://underlay.org/ns/label\",\n      reference = \"http://underlay.org/ns/reference\",\n      uri = \"http://underlay.org/ns/uri\",\n      literal = \"http://underlay.org/ns/literal\",\n      datatype = \"http://underlay.org/ns/datatype\",\n      product = \"http://underlay.org/ns/product\",\n      coproduct = \"http://underlay.org/ns/coproduct\",\n      component = \"http://underlay.org/ns/component\",\n      option = \"http://underlay.org/ns/option\",\n      key = \"http://underlay.org/ns/key\",\n      value = \"http://underlay.org/ns/value\",\n      source = \"http://underlay.org/ns/source\",\n      target = \"http://underlay.org/ns/target\",\n      none = \"http://underlay.org/ns/none\",\n      some = \"http://underlay.org/ns/some\",\n      head = \"http://underlay.org/ns/head\",\n      tail = \"http://underlay.org/ns/tail\",\n      expression = \"http://underlay.org/ns/expression\",\n      identity = \"http://underlay.org/ns/identity\",\n      identifier = \"http://underlay.org/ns/identifier\",\n      constant = \"http://underlay.org/ns/constant\",\n      dereference = \"http://underlay.org/ns/dereference\",\n      projection = \"http://underlay.org/ns/injection\",\n      injection = \"http://underlay.org/ns/injection\",\n      tuple = \"http://underlay.org/ns/tuple\",\n      slot = \"http://underlay.org/ns/slot\",\n      match = \"http://underlay.org/ns/match\",\n      CASE = \"http://underlay.org/ns/case\",\n      path = \"http://underlay.org/ns/path\",\n      map = \"http://underlay.org/ns/map\";\nexports.map = map;\nexports.path = path;\nexports.CASE = CASE;\nexports.match = match;\nexports.slot = slot;\nexports.tuple = tuple;\nexports.injection = injection;\nexports.projection = projection;\nexports.dereference = dereference;\nexports.constant = constant;\nexports.identifier = identifier;\nexports.identity = identity;\nexports.expression = expression;\nexports.tail = tail;\nexports.head = head;\nexports.some = some;\nexports.none = none;\nexports.target = target;\nexports.source = source;\nexports.value = value;\nexports.key = key;\nexports.option = option;\nexports.component = component;\nexports.coproduct = coproduct;\nexports.product = product;\nexports.datatype = datatype;\nexports.literal = literal;\nexports.uri = uri;\nexports.reference = reference;\nexports.label = label;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forType = forType;\nexports.isTypeEqual = isTypeEqual;\nexports.isTypeAssignable = isTypeAssignable;\nexports.unify = unify;\n\nvar _ziterable = _interopRequireDefault(require(\"ziterable\"));\n\nvar APG = _interopRequireWildcard(require(\"./apg.js\"));\n\nvar _utils = require(\"./utils.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction* forType(type, stack = []) {\n  if (stack.includes(type)) {\n    throw new Error(\"Recursive type\");\n  }\n\n  yield [type, stack];\n\n  if (type.type === \"product\") {\n    stack.push(type);\n\n    for (const key of (0, _utils.getKeys)(type.components)) {\n      yield* forType(type.components[key], stack);\n    }\n\n    stack.pop();\n  } else if (type.type === \"coproduct\") {\n    stack.push(type);\n\n    for (const key of (0, _utils.getKeys)(type.options)) {\n      yield* forType(type.options[key], stack);\n    }\n\n    stack.pop();\n  }\n}\n\nfunction isTypeEqual(a, b) {\n  if (a === b) {\n    return true;\n  } else if (a.type !== b.type) {\n    return false;\n  } else if (a.type === \"reference\" && b.type === \"reference\") {\n    return a.value === b.value;\n  } else if (a.type === \"uri\" && b.type === \"uri\") {\n    return true;\n  } else if (a.type === \"literal\" && b.type === \"literal\") {\n    return a.datatype === b.datatype;\n  } else if (a.type === \"product\" && b.type === \"product\") {\n    const A = (0, _utils.getKeys)(a.components);\n    const B = (0, _utils.getKeys)(b.components);\n\n    if (A.length !== B.length) {\n      return false;\n    }\n\n    for (const [keyA, keyB] of (0, _ziterable.default)(A, B)) {\n      if (keyA !== keyB) {\n        return false;\n      } else if (isTypeEqual(a.components[keyA], a.components[keyB])) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (a.type === \"coproduct\" && b.type === \"coproduct\") {\n    const A = (0, _utils.getKeys)(a.options);\n    const B = (0, _utils.getKeys)(b.options);\n\n    if (A.length !== B.length) {\n      return false;\n    }\n\n    for (const [keyA, keyB] of (0, _ziterable.default)(A, B)) {\n      if (keyA !== keyB) {\n        return false;\n      } else if (isTypeEqual(a.options[keyA], b.options[keyB])) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isTypeAssignable(a, b) {\n  if (a === b) {\n    return true;\n  } else if (a.type !== b.type) {\n    return false;\n  } else if (a.type === \"reference\" && b.type === \"reference\") {\n    return a.value === b.value;\n  } else if (a.type === \"uri\" && b.type === \"uri\") {\n    return true;\n  } else if (a.type === \"literal\" && b.type === \"literal\") {\n    return a.datatype === b.datatype;\n  } else if (a.type === \"product\" && b.type === \"product\") {\n    for (const key of (0, _utils.getKeys)(b.components)) {\n      if (key in a.components && isTypeAssignable(a.components[key], b.components[key])) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (a.type === \"coproduct\" && b.type === \"coproduct\") {\n    for (const key of (0, _utils.getKeys)(a.options)) {\n      if (key in b.options && isTypeAssignable(a.options[key], b.options[key])) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction unify(a, b) {\n  if (a === b) {\n    return b;\n  } else if (a.type === \"reference\" && b.type === \"reference\") {\n    if (a.value === b.value) {\n      return b;\n    }\n  } else if (a.type === \"uri\" && b.type === \"uri\") {\n    return b;\n  } else if (a.type === \"literal\" && b.type === \"literal\") {\n    if (a.datatype === b.datatype) {\n      return b;\n    }\n  } else if (a.type === \"product\" && b.type === \"product\") {\n    return APG.product(Object.fromEntries(unifyComponents(a, b)));\n  }\n\n  if (a.type === \"coproduct\" && b.type === \"coproduct\") {\n    return APG.coproduct(Object.fromEntries(unifyOptions(a, b)));\n  } else {\n    throw new Error(\"Cannot unify unequal types\");\n  }\n}\n\nfunction* unifyComponents(a, b) {\n  const A = (0, _utils.getKeys)(a.components);\n  const B = (0, _utils.getKeys)(b.components);\n\n  if (A.length !== B.length) {\n    throw new Error(\"Cannot unify unequal products\");\n  }\n\n  for (const [keyA, keyB] of (0, _ziterable.default)(A, B)) {\n    if (keyA !== keyB) {\n      throw new Error(\"Cannot unify unequal types\");\n    } else {\n      yield [keyA, unify(a.components[keyA], b.components[keyB])];\n    }\n  }\n}\n\nfunction* unifyOptions(a, b) {\n  const keys = Array.from(new Set([...(0, _utils.getKeys)(a.options), ...(0, _utils.getKeys)(b.options)])).sort();\n\n  for (const key of keys) {\n    const A = a.options[key];\n    const B = b.options[key];\n\n    if (A !== undefined && B === undefined) {\n      yield [key, A];\n    } else if (A === undefined && B !== undefined) {\n      yield [key, B];\n    } else if (A !== undefined && B !== undefined) {\n      yield [key, unify(A, B)];\n    } else {\n      throw new Error(\"Error unifying options\");\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forEntries = forEntries;\nexports.getKeys = getKeys;\nexports.getKeyIndex = getKeyIndex;\nexports.mapKeys = mapKeys;\nexports.signalInvalidType = signalInvalidType;\nexports.rootId = void 0;\n\nvar _uuid = require(\"uuid\");\n\nconst keyMap = new WeakMap();\n\nfunction* forEntries(object) {\n  for (const [index, key] of getKeys(object).entries()) {\n    yield [key, object[key], index];\n  }\n}\n\nfunction getKeys(object) {\n  if (keyMap.has(object)) {\n    return keyMap.get(object);\n  } else {\n    const keys = Object.keys(object).sort();\n    Object.freeze(keys);\n    keyMap.set(object, keys);\n    return keys;\n  }\n}\n\nfunction getKeyIndex(object, key) {\n  if (keyMap.has(object)) {\n    const index = keyMap.get(object).indexOf(key);\n\n    if (index === -1) {\n      throw new Error(`Key not found: ${key}`);\n    }\n\n    return index;\n  } else {\n    const keys = Object.keys(object).sort();\n    Object.freeze(keys);\n    keyMap.set(object, keys);\n    const index = keys.indexOf(key);\n\n    if (index === -1) {\n      throw new Error(`Key not found: ${key}`);\n    }\n\n    return index;\n  }\n}\n\nfunction mapKeys(object, map) {\n  const keys = getKeys(object);\n  const result = Object.fromEntries(keys.map(key => [key, map(object[key], key)]));\n  keyMap.set(result, keys);\n  Object.freeze(result);\n  return result;\n}\n\nfunction signalInvalidType(type) {\n  console.error(type);\n  throw new Error(\"Invalid type\");\n}\n\nconst rootId = (0, _uuid.v4)();\nexports.rootId = rootId;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateInstance = validateInstance;\nexports.validateValue = validateValue;\nexports.forValue = forValue;\n\nvar _ziterable = _interopRequireDefault(require(\"ziterable\"));\n\nvar APG = _interopRequireWildcard(require(\"./apg.js\"));\n\nvar _utils = require(\"./utils.js\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validateInstance(schema, instance) {\n  const iter = (0, _ziterable.default)((0, _utils.forEntries)(schema), (0, _utils.forEntries)(instance));\n\n  for (const [[k1, type], [k2, values]] of iter) {\n    if (k1 !== k2) {\n      return false;\n    }\n\n    for (const value of values) {\n      if (validateValue(type, value)) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction validateValue(type, value) {\n  if (APG.isReference(type)) {\n    return value.termType === \"Pointer\";\n  } else if (APG.isUri(type)) {\n    return value.termType === \"NamedNode\";\n  } else if (APG.isLiteral(type)) {\n    return APG.isLiteralValue(value) && value.datatype.value === type.datatype;\n  } else if (APG.isProduct(type)) {\n    if (APG.isRecord(value)) {\n      const keys = (0, _utils.getKeys)(type.components);\n\n      if (keys.length !== value.length) {\n        return false;\n      }\n\n      for (const [k1, k2, v] of (0, _ziterable.default)(keys, value.components, value)) {\n        if (k1 !== k2) {\n          return false;\n        } else if (validateValue(type.components[k1], v)) {\n          continue;\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  } else if (APG.isCoproduct(type)) {\n    if (APG.isVariant(value) && value.key in type.options) {\n      return validateValue(type.options[value.key], value.value);\n    } else {\n      return false;\n    }\n  } else {\n    console.error(type);\n    throw new Error(\"Unexpected type\");\n  }\n}\n\nfunction* forValue(value, stack = []) {\n  if (stack.includes(value)) {\n    throw new Error(\"Recursive type\");\n  }\n\n  yield [value, stack];\n\n  if (value.termType === \"Record\") {\n    stack.push(value);\n\n    for (const leaf of value) {\n      yield* forValue(leaf, stack);\n    }\n\n    stack.pop();\n  } else if (value.termType === \"Variant\") {\n    stack.push(value);\n    yield* forValue(value.value, stack);\n    stack.pop();\n  }\n}","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n}\n\nexport default v1;","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;","import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","export default '00000000-0000-0000-0000-000000000000';","import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nexport default version;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parser = void 0;\n\nvar _lezer = require(\"lezer\");\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {\n  __proto__: null,\n  namespace: 8,\n  type: 16,\n  class: 42,\n  edge: 46,\n  list: 50\n};\n\nconst parser = _lezer.Parser.deserialize({\n  version: 13,\n  states: \")`QYQPOOOkQPO'#C_OpQPO'#CcOuQQO'#CpOzQQO'#CrO!PQQO'#CtOOQO'#C|'#C|OOQO'#Cv'#CvQYQPOOOOQO'#Ca'#CaO!UQQO,58yOOQO'#Ce'#CeO!ZQPO,58}O!ZQPO,59[O!rQPO,59^O!wQPO,59`OOQO-E6t-E6tOOQO1G.e1G.eOOQO'#Cf'#CfO!ZQPO'#CgO!|QQO'#ChO#RQQO'#CkO#WQQO'#ClO#`QQO'#CnOOQO'#DO'#DOOOQO1G.i1G.iOOQO1G.v1G.vO#hQQO1G.xO!ZQPO1G.zOOQO,59R,59ROOQO,59S,59SO#mQPO,59VO#rQPO'#CmO#wQPO'#DTO$PQPO,59WO$UQQO'#CoO$aQPO'#DYO$iQPO,59YO$nQPO7+$dOOQO7+$f7+$fOOQO1G.q1G.qO!ZQPO,59XO$uQQO,59oO$}QPO,59oOOQO1G.r1G.rO!ZQPO,59ZO%VQQO,59tO%_QPO,59tOOQO1G.t1G.tO%gQQO<<HOO%lQPO<<HOOOQO1G.s1G.sOOQO,59c,59cO%qQQO1G/ZOOQO-E6u-E6uOOQO1G.u1G.uOOQO,59d,59dO%yQQO1G/`OOQO-E6v-E6vOOQOAN=jAN=jO&RQQOAN=jP&WQQO'#CwP&]QQO'#CxOOQOG23UG23U\",\n  stateData: \"&b~OoOSPOS~OSPOWQOeROgSOiTO~OqXO~OqZO~OU]O~OU^O~OU_O~OUaO~O]dO^hOqbOscOteOvfO{gO~O!PkO~O!RlO~OUnO~OUoO~OUpOzwP~OUsO!O|P~OUvO~OuxO~OxyO~OyzOzwX~Oz|O~O}}OycX!OcX~Oy!OO!O|X~O!O!QO~O!Q!RO~P!ZOUpOzwa~Oy!VOzwa~OUsO!O|a~Oy!ZO!O|a~OU!]O~O!Q!^O~OUpOzwi~OUsO!O|i~OU!aO~OUpO~OUsO~O\",\n  goto: \"#v}PPP!OP!SP!OP!V!Y!Y!YPP!Y!Y!c!Y!k!OP!OP!OP!s!y#PPPP#VP#ZPPPP#pPPPP#sTUOWRYPR[Q_h[]clvy}QqfV!Uz!V!_QtgV!Y!O!Z!`QWOR`WQ{qR!W{Q!PtR![!PTVOWQi[Qj]QmcQwlQ!SvQ!TyR!X}RrfRug\",\n  nodeNames: \"⚠ Comment Schema Namespace namespace Prefix Term Type type TypeName Variable Optional Reference Pointer Uri Literal Product Component Coproduct Option Class class Edge edge List list\",\n  maxTerm: 49,\n  nodeProps: [[_lezer.NodeProp.group, -7, 10, 11, 12, 14, 15, 16, 18, \"Expression\"]],\n  skippedNodes: [0, 1],\n  repeatNodeCount: 3,\n  tokenData: \"'c~RjX^!spq!sst#hz{#s}!O#x!P!Q$T![!]$f!]!^$q!^!_$v!_!`%T!`!a%f!a!b%s!c!}%x!}#O&}#P#Q'S#T#o%x#o#p'X#q#r'^#y#z!s$f$g!s#BY#BZ!s$IS$I_!s$I|$JO!s$JT$JU!s$KV$KW!s&FU&FV!s~!xYo~X^!spq!s#y#z!s$f$g!s#BY#BZ!s$IS$I_!s$I|$JO!s$JT$JU!s$KV$KW!s&FU&FV!s~#mQP~OY#hZ~#h~#xO]~~#{P!`!a$O~$TOx~~$WP!_!`$Z~$^P!`!a$a~$fO!Q~~$iP![!]$l~$qO!R~~$vOy~~${Pt~!`!a%O~%TO^~~%WP!_!`%Z~%^P!P!Q%a~%fO!P~R%kPuP}!O%nQ%sO}Q~%xOs~R&PSUQqP!Q![%x![!]&]!c!}%x#T#o%xQ&bXUQst&]}!O&]!O!P&]!P!Q&]!Q![&]![!]&]!c!}&]#R#S&]#T#o&]~'SO{~~'XO!O~~'^Ov~~'cOz~\",\n  tokenizers: [0, 1],\n  topRules: {\n    \"Schema\": [0, 2]\n  },\n  specialized: [{\n    term: 33,\n    get: value => spec_identifier[value] || -1\n  }],\n  tokenPrec: 0\n});\n\nexports.parser = parser;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parser = void 0;\n\nvar _lezer = require(\"lezer\");\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {\n  __proto__: null,\n  namespace: 8,\n  expr: 16,\n  map: 50\n};\n\nconst parser = _lezer.Parser.deserialize({\n  version: 13,\n  states: \")xQYQPOOOeQPO'#C_OjQPO'#CcOoQQO'#CtOOQO'#C}'#C}OOQO'#Cv'#CvQYQPOOOOQO'#Ca'#CaOtQQO,58yOOQO'#Ce'#CeOyQPO,58}O!hQPO,59`OOQO-E6t-E6tOOQO1G.e1G.eOOQO'#Cf'#CfO!oQQO'#CgO!tQQO'#CiO!yQQO'#CkO#OQQO'#CmO#TQPO'#CnO#YQQO'#CpO#bQQO'#CrOOQO'#DR'#DRO#jQPO'#DPO$UQPO'#DPOOQO1G.i1G.iOOQO1G.z1G.zO$pQQO1G.zOOQO,59R,59ROOQO,59T,59TOOQO,59V,59VO$uQPO,59XO$zQQO,59YO%PQPO'#CqO%[QPO'#DVO%dQPO,59[O%iQQO'#CsO%tQPO'#D[O%|QPO,59^O$UQPO'#CyO&RQPO,59kO&RQPO,59kOyQPO7+$fOOQO1G.s1G.sO&mQPO1G.tOyQPO,59]O&rQQO,59qO&zQPO,59qOOQO1G.v1G.vOyQPO,59_O'SQQO,59vO'[QPO,59vOOQO1G.x1G.xOOQO,59e,59eOOQO-E6w-E6wO'dQPO1G/VOOQO<<HQ<<HQOOQO7+$`7+$`OOQO1G.w1G.wOOQO,59c,59cO(OQQO1G/]OOQO-E6u-E6uOOQO1G.y1G.yOOQO,59d,59dO(WQQO1G/bOOQO-E6v-E6vP(`QQO'#CwP(eQQO'#Cx\",\n  stateData: \"(j~OpOSPOS~OSPOWQOiRO~OrVO~OrXO~OUZO~OU]O~O[_O^`O`aOccOr^OthOvbOxdO}eO~O!RkO~PyOUlO~OUmO~OUnO~OUoO~OvpO~OUqO|yP~OUtO!Q!OP~OtwOSsXWsXisXnsX{sX|sX!QsX~O[_O^`O`aOccOr^OvbOxdO}eO~OUzO~Ow{O~OU|O~Oz}O{eX|eX~O{!OO|yX~O|!QO~O!P!RO{gX!QgX~O{!SO!Q!OX~O!Q!UO~OtwOSsaWsaisansa{sa|sa!Qsa~Ow!ZO~OUqO|ya~O{!^O|ya~OUtO!Q!Oa~O{!bO!Q!Oa~OtwOSsiWsiisinsi{si|si!Qsi~OUqO|yi~OUtO!Q!Oi~OUqO~OUtO~O\",\n  goto: \"$Z!PPPP!QP!UP!QP!X![![P![P![P![![P![!e![!m!QP!u!{#R#XPPP#cP#gP#vPPP$TPPPP$WTSOURWPRYQ_fYZhwz}!RQrdV!]!O!^!dQueV!a!S!b!eQUOR[UQ!PrR!_!PQ!TuR!c!TQxgS!Wx!XR!XyTTOUQiYQjZQ!YzQ![}R!`!RYgYZz}!RQyhR!VwRsdRve\",\n  nodeNames: \"⚠ Comment Mapping Namespace namespace Prefix Term Expr expr ExprName Variable Dereference Pointer Projection Projector Injection Injector Identifier Constant String Tuple Slot Match Case Map map\",\n  maxTerm: 49,\n  nodeProps: [[_lezer.NodeProp.group, -8, 10, 11, 13, 15, 17, 18, 20, 22, \"Expression\"]],\n  skippedNodes: [0, 1],\n  repeatNodeCount: 4,\n  tokenData: \")Q~RkX^!vpq!vrs#kst%wz{&S}!O&X!O!P&d!P!Q&i![!]&n!]!^&y!^!_'O!`!a'T!c!}'b!}#O(g#P#Q(l#T#o'b#o#p(q#p#q(v#q#r({#y#z!v$f$g!v#BY#BZ!v$IS$I_!v$I|$JO!v$JT$JU!v$KV$KW!v&FU&FV!v~!{Yp~X^!vpq!v#y#z!v$f$g!v#BY#BZ!v$IS$I_!v$I|$JO!v$JT$JU!v$KV$KW!v&FU&FV!v~#nUpq#kqr#krs$Qs#O#k#O#P$V#P~#k~$VOc~~$YXrs#k!P!Q#k#O#P#k#U#V#k#Y#Z#k#b#c#k#f#g#k#h#i#k#i#j$u~$xR!Q![%R!c!i%R#T#Z%R~%UR!Q![%_!c!i%_#T#Z%_~%bR!Q![%k!c!i%k#T#Z%k~%nR!Q![#k!c!i#k#T#Z#k~%|QP~OY%wZ~%w~&XO[~~&[P!`!a&_~&dOz~~&iO^~~&nO`~~&qP![!]&t~&yO!R~~'OO{~~'TOv~R'YPwP}!O']Q'bO!PQR'iSUQrP!Q!['b![!]'u!c!}'b#T#o'bQ'zXUQst'u}!O'u!O!P'u!P!Q'u!Q!['u![!]'u!c!}'u#R#S'u#T#o'u~(lO}~~(qO!Q~~(vOx~~({Ot~~)QO|~\",\n  tokenizers: [0, 1],\n  topRules: {\n    \"Mapping\": [0, 2]\n  },\n  specialized: [{\n    term: 34,\n    get: value => spec_identifier[value] || -1\n  }],\n  tokenPrec: 0\n});\n\nexports.parser = parser;","export * from \"./tasl.js\"\nexport * from \"./taslx.js\"\nexport * from \"./stdlib.js\"\nexport * from \"./utils.js\"\n","import { APG } from \"@underlay/apg\"\nimport { rdf, xsd } from \"n3.ts\"\n\nexport const defaultTypes: Record<string, APG.Type> = {\n\tunit: APG.product({}),\n\turi: APG.uri(),\n\n\tstring: APG.literal(xsd.string),\n\tboolean: APG.literal(xsd.boolean),\n\tinteger: APG.literal(xsd.integer),\n\tdouble: APG.literal(xsd.double),\n\tdate: APG.literal(xsd.date),\n\tdateTime: APG.literal(xsd.dateTime),\n\tbase64Binary: APG.literal(xsd.base64Binary),\n\tJSON: APG.literal(rdf.JSON),\n}\n\nexport const defaultNamespaces: Record<string, string> = {\n\tul: \"http://underlay.org/ns/\",\n\txsd: \"http://www.w3.org/2001/XMLSchema#\",\n\trdf: \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n}\n","import { APG, ns } from \"@underlay/apg\"\nimport { SyntaxNode } from \"lezer\"\n\nimport { parser } from \"../grammar/tasl.js\"\n\nimport {\n\tLintError,\n\tnamespacePattern,\n\tParseState,\n\tparseURI,\n\turiPattern,\n} from \"./utils.js\"\nimport { defaultTypes } from \"./stdlib.js\"\n\ninterface parseState extends ParseState {\n\tschema: Record<string, APG.Type>\n\ttypes: Record<string, APG.Type>\n\treferences: { from: number; to: number; key: string }[]\n}\n\nexport interface ParseTaslResult {\n\tschema: APG.Schema\n\tnamespaces: Record<string, string>\n}\n\nexport function parseTasl(input: string): ParseTaslResult {\n\tconst tree = parser.configure({ strict: true }).parse(input)\n\tconst cursor = tree.cursor()\n\n\tif (cursor.name === \"Schema\") {\n\t\tcursor.firstChild()\n\t} else {\n\t\tthrow new LintError(cursor.from, cursor.to, \"\", \"Invalid top-level node\")\n\t}\n\n\tconst slice = ({ from, to }: SyntaxNode) => input.slice(from, to)\n\tconst error = (node: SyntaxNode, message: string) =>\n\t\tnew LintError(node.from, node.to, slice(node), message)\n\tconst state: parseState = {\n\t\tslice,\n\t\terror,\n\t\tnamespaces: {},\n\t\ttypes: { ...defaultTypes },\n\t\tschema: {},\n\t\treferences: [],\n\t}\n\n\tdo {\n\t\tif (cursor.type.name === \"Namespace\") {\n\t\t\tconst term = cursor.node.getChild(\"Term\")!\n\t\t\tconst namespace = state.slice(term)\n\t\t\tif (!uriPattern.test(namespace)) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tterm,\n\t\t\t\t\t`Invalid URI: URIs must match ${uriPattern.source}`\n\t\t\t\t)\n\t\t\t} else if (!namespacePattern.test(namespace)) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tterm,\n\t\t\t\t\t\"Invalid namespace: namespaces must end in / or #\"\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst identifier = cursor.node.getChild(\"Prefix\")!\n\t\t\tconst prefix = state.slice(identifier)\n\t\t\tif (prefix in state.namespaces) {\n\t\t\t\tthrow state.error(identifier, `Duplicate namespace: ${prefix}`)\n\t\t\t} else {\n\t\t\t\tstate.namespaces[prefix] = namespace\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Type\") {\n\t\t\tconst identifier = cursor.node.getChild(\"TypeName\")!\n\t\t\tconst expression = cursor.node.getChild(\"Expression\")!\n\t\t\tconst type = parseType(state, expression)\n\n\t\t\tconst name = state.slice(identifier)\n\t\t\tif (name in state.types) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tidentifier,\n\t\t\t\t\t`Invalid type declaration: type ${name} has already been declared`\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tstate.types[name] = type\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Class\") {\n\t\t\tconst node = cursor.node.getChild(\"Term\")!\n\t\t\tconst term = parseURI(state, node)!\n\t\t\tif (term in state.schema) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tnode,\n\t\t\t\t\t`Invalid class declaration: class ${term} has already been declared`\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tconst expression = cursor.node.getChild(\"Expression\")!\n\t\t\t\tstate.schema[term] = parseType(state, expression)\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Edge\") {\n\t\t\tconst terms = cursor.node.getChildren(\"Term\")\n\t\t\tconst names = terms.map((uri) => parseURI(state, uri))\n\n\t\t\tconst expression = cursor.node.getChild(\"Expression\")\n\t\t\tconst value = expression && parseType(state, expression)\n\n\t\t\tconst [sourceNode, labelNode, targetNode] = terms\n\t\t\tconst [source, label, target] = names\n\t\t\tif (label in state.schema) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tlabelNode,\n\t\t\t\t\t`Invalid edge declaration: class ${label} has already been declared`\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tif (!(source in state.schema)) {\n\t\t\t\t\tconst { from, to } = sourceNode\n\t\t\t\t\tstate.references.push({ from, to, key: source })\n\t\t\t\t}\n\n\t\t\t\tif (!(target in state.schema)) {\n\t\t\t\t\tconst { from, to } = targetNode\n\t\t\t\t\tstate.references.push({ from, to, key: target })\n\t\t\t\t}\n\n\t\t\t\tconst components: Record<string, APG.Type> = {\n\t\t\t\t\t[ns.source]: APG.reference(source),\n\t\t\t\t\t[ns.target]: APG.reference(target),\n\t\t\t\t}\n\n\t\t\t\tif (value !== null) {\n\t\t\t\t\tcomponents[ns.value] = value\n\t\t\t\t}\n\n\t\t\t\tstate.schema[label] = APG.product(components)\n\t\t\t}\n\t\t} else if (cursor.type.name === \"List\") {\n\t\t\tconst node = cursor.node.getChild(\"Term\")!\n\t\t\tconst term = parseURI(state, node)!\n\t\t\tif (term in state.schema) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tnode,\n\t\t\t\t\t`Invalid list declaration: class ${term} has already been declared`\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tconst expression = cursor.node.getChild(\"Expression\")!\n\t\t\t\tstate.schema[term] = APG.coproduct({\n\t\t\t\t\t[ns.none]: APG.product({}),\n\t\t\t\t\t[ns.some]: APG.product({\n\t\t\t\t\t\t[ns.head]: parseType(state, expression),\n\t\t\t\t\t\t[ns.tail]: APG.reference(term),\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t} while (cursor.nextSibling())\n\n\tfor (const { from, to, key } of state.references) {\n\t\tif (key in state.schema) {\n\t\t\tcontinue\n\t\t} else {\n\t\t\tconst message = `Invalid reference: class ${key} is not defined`\n\t\t\tthrow new LintError(from, to, key, message)\n\t\t}\n\t}\n\n\treturn { schema: APG.schema(state.schema), namespaces: state.namespaces }\n}\n\n// Variable | Optional | Reference  | Uri | Literal | Product | Coproduct\nexport function parseType(state: parseState, node: SyntaxNode): APG.Type {\n\tif (node.name === \"Variable\") {\n\t\tconst value = state.slice(node)\n\t\tif (value in state.types) {\n\t\t\treturn state.types[value]\n\t\t} else {\n\t\t\tthrow state.error(node, `Type ${value} is not defined`)\n\t\t}\n\t} else if (node.name === \"Optional\") {\n\t\tconst expression = node.getChild(\"Expression\")!\n\t\tconst type = parseType(state, expression)\n\t\treturn APG.coproduct({ [ns.none]: APG.product({}), [ns.some]: type })\n\t} else if (node.name === \"Reference\") {\n\t\tconst term = node.getChild(\"Term\")!\n\t\tconst key = parseURI(state, term)\n\t\tif (!(key in state.schema)) {\n\t\t\tconst { from, to } = term\n\t\t\tstate.references.push({ from, to, key })\n\t\t}\n\n\t\treturn APG.reference(key)\n\t} else if (node.name === \"Uri\") {\n\t\treturn APG.uri()\n\t} else if (node.name === \"Literal\") {\n\t\tconst term = node.getChild(\"Term\")!\n\t\tconst datatype = parseURI(state, term)\n\t\treturn APG.literal(datatype)\n\t} else if (node.name === \"Product\") {\n\t\tconst components: Record<string, APG.Type> = {}\n\t\tfor (const component of node.getChildren(\"Component\")) {\n\t\t\tconst term = component.getChild(\"Term\")!\n\n\t\t\tconst key = parseURI(state, term)\n\t\t\tif (key in components) {\n\t\t\t\tthrow state.error(term, `Duplicate product component key: ${key}`)\n\t\t\t} else {\n\t\t\t\tconst expression = component.getChild(\"Expression\")!\n\t\t\t\tcomponents[key] = parseType(state, expression)\n\t\t\t}\n\t\t}\n\n\t\treturn APG.product(components)\n\t} else if (node.name === \"Coproduct\") {\n\t\tconst options: Record<string, APG.Type> = {}\n\t\tfor (const option of node.getChildren(\"Option\")) {\n\t\t\tconst term = option.getChild(\"Term\")!\n\t\t\tconst key = parseURI(state, term)\n\t\t\tif (key in options) {\n\t\t\t\tthrow state.error(term, `Duplicate coproduct option key: ${key}`)\n\t\t\t} else {\n\t\t\t\tconst expression = option.getChild(\"Expression\")\n\t\t\t\tif (expression === null) {\n\t\t\t\t\toptions[key] = APG.product({})\n\t\t\t\t} else {\n\t\t\t\t\toptions[key] = parseType(state, expression)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn APG.coproduct(options)\n\t} else {\n\t\tthrow new Error(\"Unexpected Expression node\")\n\t}\n}\n","import { APG } from \"@underlay/apg\"\nimport { SyntaxNode } from \"lezer\"\n\nimport { parser } from \"../grammar/taslx.js\"\n\nimport {\n\tLintError,\n\tnamespacePattern,\n\tparseURI,\n\turiPattern,\n\tParseState,\n} from \"./utils.js\"\n\ninterface parseState extends ParseState {\n\tmapping: Record<string, APG.Map>\n\texprs: Record<string, APG.Expression[]>\n}\n\nexport interface ParseTaslxResult {\n\tmapping: APG.Mapping\n\tnamespaces: Record<string, string>\n}\n\nexport function parseTaslx(input: string): ParseTaslxResult {\n\tconst slice = (node: SyntaxNode) => input.slice(node.from, node.to)\n\tconst error = (node: SyntaxNode, message: string) =>\n\t\tnew LintError(node.from, node.to, slice(node), message)\n\n\tconst state: parseState = {\n\t\tslice,\n\t\terror,\n\t\tnamespaces: {},\n\t\texprs: {},\n\t\tmapping: {},\n\t}\n\n\tconst tree = parser.configure({ strict: true }).parse(input)\n\tconst cursor = tree.cursor()\n\n\tif (cursor.name === \"Mapping\") {\n\t\tcursor.firstChild()\n\t} else {\n\t\tthrow state.error(cursor.node, \"Invalid top-level node\")\n\t}\n\n\tdo {\n\t\tif (cursor.type.name === \"Namespace\") {\n\t\t\tconst term = cursor.node.getChild(\"Term\")!\n\t\t\tconst namespace = state.slice(term)\n\t\t\tif (!uriPattern.test(namespace)) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tterm,\n\t\t\t\t\t`Invalid URI: URIs must match ${uriPattern.source}`\n\t\t\t\t)\n\t\t\t} else if (!namespacePattern.test(namespace)) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tterm,\n\t\t\t\t\t\"Invalid namespace: namespaces must end in / or #\"\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst identifier = cursor.node.getChild(\"Prefix\")!\n\t\t\tconst prefix = state.slice(identifier)\n\t\t\tif (prefix in state.namespaces) {\n\t\t\t\tthrow state.error(identifier, `Duplicate namespace: ${prefix}`)\n\t\t\t} else {\n\t\t\t\tstate.namespaces[prefix] = namespace\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Expr\") {\n\t\t\tconst identifier = cursor.node.getChild(\"ExprName\")!\n\t\t\tconst nodes = cursor.node.getChildren(\"Expression\")\n\t\t\tconst exprs = parseExprs(state, nodes)\n\n\t\t\tconst name = state.slice(identifier)\n\t\t\tif (name in state.exprs) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\tidentifier,\n\t\t\t\t\t`Invalid expression declaration: expression ${name} has already been declared`\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tstate.exprs[name] = exprs\n\t\t\t}\n\t\t} else if (cursor.type.name === \"Map\") {\n\t\t\tconst termNodes = cursor.node.getChildren(\"Term\")\n\t\t\tconst terms = termNodes.map((node) => parseURI(state, node))\n\t\t\tconst key = terms[0]\n\t\t\tconst source = terms.length > 1 ? terms[1] : key\n\t\t\tif (key in state.mapping) {\n\t\t\t\tthrow state.error(\n\t\t\t\t\ttermNodes[0],\n\t\t\t\t\t`Invalid map declaration: map ${key} has already been declared`\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tconst expressions = cursor.node.getChildren(\"Expression\")\n\t\t\t\tstate.mapping[key] = APG.map(source, parseExprs(state, expressions))\n\t\t\t}\n\t\t}\n\t} while (cursor.nextSibling())\n\n\treturn { mapping: APG.mapping(state.mapping), namespaces: state.namespaces }\n}\n\nexport const parseExprs = (state: parseState, nodes: SyntaxNode[]) =>\n\tnodes.reduce<APG.Expression[]>(\n\t\t(exprs, node) => exprs.concat(parseExpr(state, node)),\n\t\t[]\n\t)\n\nexport function parseExpr(\n\tstate: parseState,\n\tnode: SyntaxNode\n): APG.Expression[] {\n\tif (node.name === \"Variable\") {\n\t\tconst value = state.slice(node)\n\t\tif (value in state.exprs) {\n\t\t\treturn state.exprs[value]\n\t\t} else {\n\t\t\tthrow state.error(node, `Expression ${value} is not defined`)\n\t\t}\n\t} else if (node.name === \"Dereference\") {\n\t\tconst term = node.getChild(\"Term\")!\n\t\tconst key = parseURI(state, term)\n\t\treturn [APG.dereference(key)]\n\t} else if (node.name === \"Projection\") {\n\t\tconst term = node.getChild(\"Term\")!\n\t\tconst key = parseURI(state, term)\n\t\treturn [APG.projection(key)]\n\t} else if (node.name === \"Injection\") {\n\t\tconst term = node.getChild(\"Term\")!\n\t\tconst key = parseURI(state, term)\n\t\treturn [APG.injection(key)]\n\t} else if (node.name === \"Identifier\") {\n\t\tconst term = node.getChild(\"Term\")!\n\t\tconst key = parseURI(state, term)\n\t\treturn [APG.identifier(key)]\n\t} else if (node.name === \"Constant\") {\n\t\tconst string = node.getChild(\"String\")!\n\t\tconst text = state.slice(string)\n\t\tconst value = JSON.parse(text)\n\t\tif (typeof value !== \"string\") {\n\t\t\tthrow state.error(string, `Invalid constant: ${text}`)\n\t\t}\n\t\tconst term = node.getChild(\"Term\")!\n\t\tconst datatype = parseURI(state, term)\n\t\treturn [APG.constant(value, datatype)]\n\t} else if (node.name === \"Tuple\") {\n\t\tconst slots: Record<string, APG.Expression[]> = {}\n\t\tfor (const slot of node.getChildren(\"Slot\")) {\n\t\t\tconst term = slot.getChild(\"Term\")!\n\t\t\tconst key = parseURI(state, term)\n\t\t\tif (key in slots) {\n\t\t\t\tthrow state.error(term, `Duplicate tuple slot key: ${key}`)\n\t\t\t} else {\n\t\t\t\tconst expressions = slot.getChildren(\"Expressions\")\n\t\t\t\tslots[key] = parseExprs(state, expressions)\n\t\t\t}\n\t\t}\n\n\t\treturn [APG.tuple(slots)]\n\t} else if (node.name === \"Match\") {\n\t\tconst cases: Record<string, APG.Expression[]> = {}\n\t\tfor (const CASE of node.getChildren(\"Case\")) {\n\t\t\tconst term = CASE.getChild(\"Term\")!\n\t\t\tconst key = parseURI(state, term)\n\t\t\tif (key in cases) {\n\t\t\t\tthrow state.error(term, `Duplicate match case key: ${key}`)\n\t\t\t} else {\n\t\t\t\tconst expressions = CASE.getChildren(\"Expressions\")\n\t\t\t\tcases[key] = parseExprs(state, expressions)\n\t\t\t}\n\t\t}\n\n\t\treturn [APG.match(cases)]\n\t} else {\n\t\tthrow new Error(\"Unexpected Expression node\")\n\t}\n}\n","import { SyntaxNode } from \"lezer\"\n\nexport interface ParseState {\n\tslice: (node: SyntaxNode) => string\n\terror: (node: SyntaxNode, message: string) => LintError\n\tnamespaces: Record<string, string>\n}\n\nexport class LintError extends Error {\n\tconstructor(\n\t\treadonly from: number,\n\t\treadonly to: number,\n\t\treadonly value: string,\n\t\tmessage: string\n\t) {\n\t\tsuper(message)\n\t}\n}\n\nexport const uriPattern = /^[a-z]+:[a-zA-Z0-9-/_.:#]+$/\nexport const namespacePattern = /[#/]$/\n\nexport function parseURI(\n\tstate: {\n\t\tnamespaces: Record<string, string>\n\t\tslice: (node: SyntaxNode) => string\n\t},\n\tnode: SyntaxNode\n): string {\n\tconst value = state.slice(node)\n\tconst index = value.indexOf(\":\")\n\tif (index === -1) {\n\t\tconst { from, to } = node\n\t\tconst message = `Invalid URI: URIs must be of the form [namespace]:[path]`\n\t\tthrow new LintError(from, to, value, message)\n\t}\n\n\tconst prefix = value.slice(0, index)\n\tif (prefix in state.namespaces) {\n\t\treturn state.namespaces[prefix] + value.slice(index + 1)\n\t} else {\n\t\tconst { from, to } = node\n\t\tconst message = `Invalid URI: namespace ${prefix} is not defined`\n\t\tthrow new LintError(from, to, value, message)\n\t}\n}\n\nexport function printSyntax(node: SyntaxNode, prefix: string = \"\") {\n\tconsole.log(`${prefix}- ${node.type.name} ${node.from} ${node.to}`)\n\tfor (let child = node.firstChild; child !== null; child = child.nextSibling) {\n\t\tprintSyntax(child, prefix + \"  \")\n\t}\n}\n","/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024\n\nlet nextPropID = 0\n\nconst CachedNode = new WeakMap<Tree, TreeNode>()\n\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file. Defaults to raising an error.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({deserialize}: {deserialize?: (str: string) => T} = {}) {\n    this.id = nextPropID++\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n  static string() { return new NodeProp<string>({deserialize: str => str}) }\n\n  /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n  static number() { return new NodeProp<number>({deserialize: Number}) }\n\n  /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n  static flag() { return new NodeProp<boolean>({deserialize: () => true}) }\n\n  /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n  set(propObj: {[prop: number]: any}, value: T) {\n    propObj[this.id] = value\n    return propObj\n  }\n\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the set. Takes a [match\n  /// object](#tree.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    if (typeof match != \"function\") match = NodeType.match(match)\n    return (type) => {\n      let result = (match as (type: NodeType) => T | undefined)(type)\n      return result === undefined ? null : [this, result]\n    }\n  }\n\n  /// Prop that is used to describe matching delimiters. For opening\n  /// delimiters, this holds an array of node names (written as a\n  /// space-separated string when declaring this prop in a grammar)\n  /// for the node types of closing delimiters that match it.\n  static closedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n  /// attached to closing delimiters, holding an array of node names\n  /// of types of matching opening delimiters.\n  static openedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// Used to assign node types to groups (for example, all node\n  /// types that represent an expression could be tagged with an\n  /// `\"Expression\"` group).\n  static group = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n}\n\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node set.\nexport type NodePropSource = (type: NodeType) => null | [NodeProp<any>, any]\n\n// Note: this is duplicated in lezer/src/constants.ts\nconst enum NodeFlag {\n  Top = 1,\n  Skipped = 2,\n  Error = 4,\n  Anonymous = 8\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number,\n    /// @internal\n    readonly flags: number = 0) {}\n\n  static define(spec: {\n    /// The ID of the node type. When this type is used in a\n    /// [set](#tree.NodeSet), the ID must correspond to its index in\n    /// the type array.\n    id: number, \n    /// The name of the node type. Leave empty to define an anonymous\n    /// node.\n    name?: string,\n    /// [Node props](#tree.NodeProp) to assign to the type. The value\n    /// given for any given prop should correspond to the prop's type.\n    props?: readonly ([NodeProp<any>, any] | NodePropSource)[],\n    /// Whether is is a [top node](#tree.NodeType.isTop).\n    top?: boolean,\n    /// Whether this node counts as an [error\n    /// node](#tree.NodeType.isError).\n    error?: boolean,\n    /// Whether this node is a [skipped](#tree.NodeType.isSkipped)\n    /// node.\n    skipped?: boolean\n  }) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps\n    let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) |\n      (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0)\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags)\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type)!\n      if (src) src[0].set(props, src[1])\n    }\n    return type\n  }\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// True when this is the top node of a grammar.\n  get isTop() { return (this.flags & NodeFlag.Top) > 0 }\n\n  /// True when this node is produced by a skip rule.\n  get isSkipped() { return (this.flags & NodeFlag.Skipped) > 0 }\n\n  /// Indicates whether this is an error node.\n  get isError() { return (this.flags & NodeFlag.Error) > 0 }\n\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() { return (this.flags & NodeFlag.Anonymous) > 0 }\n\n  /// Returns true when this node's name or one of its\n  /// [groups](#tree.NodeProp^group) matches the given string.\n  is(name: string | number) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true\n      let group = this.prop(NodeProp.group)\n      return group ? group.indexOf(name) > -1 : false\n    }\n    return this.id == name\n  }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0, NodeFlag.Anonymous)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#tree.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups![i]]\n        if (found) return found\n      }\n    }\n  }\n}\n\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this set, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\")\n  }\n\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeSet {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps = null\n      for (let source of props) {\n        let add = source(type)\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props)\n          add[0].set(newProps, add[1])\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)\n    }\n    return new NodeSet(newTypes)\n  }\n}\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nexport class Tree {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  constructor(\n    readonly type: NodeType,\n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree\n    readonly length: number\n  ) {}\n\n  /// @internal\n  toString(): string {\n    let children = this.children.map(c => c.toString()).join()\n    return !this.type.name ? children :\n      (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n  /// to the given position and side.\n  cursor(pos?: number, side: -1 | 0 | 1 = 0): TreeCursor {\n    let scope = (pos != null && CachedNode.get(this)) || (this.topNode as TreeNode)\n    let cursor = new TreeCursor(scope)\n    if (pos != null) {\n      cursor.moveTo(pos, side)\n      CachedNode.set(this, cursor._tree)\n    }\n    return cursor\n  }\n\n  /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n  /// nodes.\n  fullCursor(): TreeCursor {\n    return new TreeCursor(this.topNode as TreeNode, true)\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode(): SyntaxNode {\n    return new TreeNode(this, 0, 0, null)\n  }\n\n  /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor(pos, side).node\n  }\n\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, the given node\n  /// will not have its children iterated over (or `leave` called).\n  iterate(spec: {\n    enter(type: NodeType, from: number, to: number): false | void,\n    leave?(type: NodeType, from: number, to: number): void,\n    from?: number,\n    to?: number\n  }) {\n    let {enter, leave, from = 0, to = this.length} = spec\n    for (let c = this.cursor();;) {\n      let mustLeave = false\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue\n        if (!c.type.isAnonymous) mustLeave = true\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to)\n        mustLeave = c.type.isAnonymous\n        if (c.nextSibling()) break\n        if (!c.parent()) return\n        mustLeave = true\n      }\n    }\n  }\n\n  /// Balance the direct children of this tree.\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this\n      : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0,\n                     maxBufferLength, this.length)\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\ntype BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  ///\n  /// When this is an array, it should contain four values for every\n  /// node in the tree.\n  ///\n  ///  - The first holds the node's type, as a node ID pointing into\n  ///    the given `NodeSet`.\n  ///  - The second holds the node's start offset.\n  ///  - The third the end offset.\n  ///  - The fourth the amount of space taken up in the array by this\n  ///    node and its children. Since there's four values per node,\n  ///    this is the total number of nodes inside this node (children\n  ///    and transitive children) plus one for the node itself, times\n  ///    four.\n  ///\n  /// Parent nodes should appear _after_ child nodes in the array. As\n  /// an example, a node of type 10 spanning positions 0 to 4, with\n  /// two children, of type 11 and 12, might look like this:\n  ///\n  ///     [11, 0, 1, 4, 12, 2, 4, 4, 10, 0, 4, 12]\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  nodeSet: NodeSet,\n  /// The id of the top node type, if any.\n  topID?: number,\n  /// The position the tree should start at. Defaults to 0.\n  start?: number,\n  /// The length of the wrapping node. The end offset of the last\n  /// child is used when not provided.\n  length?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#tree.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional set of reused nodes that the buffer can refer to.\n  reused?: (Tree | TreeBuffer)[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor(\n    /// @internal\n    readonly buffer: Uint16Array,\n    // The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// @internal\n    readonly set: NodeSet,\n    readonly type = NodeType.none\n  ) {}\n\n  /// @internal\n  toString() {\n    let result: string[] = []\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result.join(\",\")\n  }\n\n  /// @internal\n  childString(index: number): string {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.set.types[id], result = type.name\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result)\n    index += 4\n    if (endIndex == index) return result\n    let children: string[] = []\n    while (index < endIndex) {\n      children.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result + \"(\" + children.join(\",\") + \")\"\n  }\n\n  /// @internal\n  findChild(startIndex: number, endIndex: number, dir: 1 | -1, after: number) {\n    let {buffer} = this, pick = -1\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != After.None) {\n        let start = buffer[i + 1], end = buffer[i + 2]\n        if (dir > 0) {\n          if (end > after) pick = i\n          if (end > after) break\n        } else {\n          if (start < after) pick = i\n          if (end >= after) break\n        }\n      } else {\n        pick = i\n        if (dir > 0) break\n      }\n    }\n    return pick\n  }\n}\n\nconst enum After { None = -1e8 }\n\n/// A syntax node provides an immutable pointer at a give node in a\n/// tree. When iterating over large amounts of nodes, you may want to\n/// use a mutable [cursor](#tree.TreeCursor) instead, which is more\n/// efficient.\nexport interface SyntaxNode {\n  /// The type of the node.\n  type: NodeType\n  /// The name of the node (`.type.name`).\n  name: string\n  /// The start position of the node.\n  from: number\n  /// The end position of the node.\n  to: number\n\n  /// The node's parent node, if any.\n  parent: SyntaxNode | null\n  /// The first child, if the node has children.\n  firstChild: SyntaxNode | null\n  /// The node's last child, if available.\n  lastChild: SyntaxNode | null\n  /// The first child that starts at or after `pos`.\n  childAfter(pos: number): SyntaxNode | null\n  /// The last child that ends at or before `pos`.\n  childBefore(pos: number): SyntaxNode | null\n  /// This node's next sibling, if any.\n  nextSibling: SyntaxNode | null\n  /// This node's previous sibling.\n  prevSibling: SyntaxNode | null\n  /// A [tree cursor](#tree.TreeCursor) starting at this node.\n  cursor: TreeCursor\n  /// Find the node around, before (if `side` is -1), or after (`side`\n  /// is 1) the given position. Will look in parent nodes if the\n  /// position is outside this node.\n  resolve(pos: number, side?: -1 | 0 | 1): SyntaxNode\n\n  /// Get the first child of the given type (which may be a [node\n  /// name](#tree.NodeProp.name) or a [group\n  /// name](#tree.NodeProp^group)). If `before` is non-null, only\n  /// return children that occur somewhere after a node with that name\n  /// or group. If `after` is non-null, only return children that\n  /// occur somewhere before a node with that name or group.\n  getChild(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode | null\n\n  /// Like [`getChild`](#tree.SyntaxNode.getChild), but return all\n  /// matching children, not just the first.\n  getChildren(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode[]\n}\n\nclass TreeNode implements SyntaxNode {\n  constructor(readonly node: Tree,\n              readonly from: number,\n              readonly index: number,\n              readonly _parent: TreeNode | null) {}\n\n  get type() { return this.node.type }\n\n  get name() { return this.node.type.name }\n\n  get to() { return this.from + this.node.length }\n\n  nextChild(i: number, dir: 1 | -1, after: number, full = false): TreeNode | BufferNode | null {\n    for (let parent: TreeNode = this;;) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent.from\n        if (after != After.None && (dir < 0 ? start >= after : start + next.length <= after))\n          continue\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == After.None ? After.None : after - start)\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index)\n        } else if (full || (!next.type.isAnonymous || hasChild(next))) {\n          let inner = new TreeNode(next, start, i, parent)\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after)\n        }\n      }\n      if (full || !parent.type.isAnonymous) return null\n      i = parent.index + dir\n      parent = parent._parent!\n      if (!parent) return null\n    }\n  }\n\n  get firstChild() { return this.nextChild(0, 1, After.None) }\n  get lastChild() { return this.nextChild(this.node.children.length - 1, -1, After.None) }\n\n  childAfter(pos: number) { return this.nextChild(0, 1, pos) }\n  childBefore(pos: number) { return this.nextChild(this.node.children.length - 1, -1, pos) }\n\n  nextSignificantParent() {\n    let val: TreeNode = this\n    while (val.type.isAnonymous && val._parent) val = val._parent\n    return val\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null\n  }\n\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null\n  }\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n\n  /// @internal\n  toString() { return this.node.toString() }\n}\n\nfunction getChildren(node: SyntaxNode, type: string | number, before: string | number | null, after: string | number | null): SyntaxNode[] {\n  let cur = node.cursor, result: SyntaxNode[] = []\n  if (!cur.firstChild()) return result\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result\n    if (cur.type.is(type)) result.push(cur.node)\n    if (!cur.nextSibling()) return after == null ? result : []\n  }\n}\n\nclass BufferContext {\n  constructor(readonly parent: TreeNode,\n              readonly buffer: TreeBuffer,\n              readonly index: number,\n              readonly start: number) {}\n}\n\nclass BufferNode implements SyntaxNode {\n  type: NodeType\n\n  get name() { return this.type.name }\n\n  get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] }\n\n  get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] }\n\n  constructor(readonly context: BufferContext,\n              readonly _parent: BufferNode | null,\n              readonly index: number) {\n    this.type = context.buffer.set.types[context.buffer.buffer[index]]\n  }\n\n  child(dir: 1 | -1, after: number): BufferNode | null {\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.context.start)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get firstChild() { return this.child(1, After.None) }\n  get lastChild() { return this.child(-1, After.None) }\n\n  childAfter(pos: number) { return this.child(1, pos) }\n  childBefore(pos: number) { return this.child(-1, pos) }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent()\n  }\n\n  externalSibling(dir: 1 | -1) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1)\n  }\n\n  get nextSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let after = buffer.buffer[this.index + 3]\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n      return new BufferNode(this.context, this._parent, after)\n    return this.externalSibling(1)\n  }\n\n  get prevSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let parentStart = this._parent ? this._parent.index + 4 : 0\n    if (this.index == parentStart) return this.externalSibling(-1)\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, After.None))\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  /// @internal\n  toString() { return this.context.buffer.childString(this.index) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n}\n\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nexport class TreeCursor {\n  /// The node's type.\n  type!: NodeType\n\n  /// Shorthand for `.type.name`.\n  get name() { return this.type.name }\n\n  /// The start source offset of this node.\n  from!: number\n\n  /// The end source offset.\n  to!: number\n\n  /// @internal\n  _tree!: TreeNode\n  private buffer: BufferContext | null = null\n  private stack: number[] = []\n  private index: number = 0\n  private bufferNode: BufferNode | null = null\n\n  /// @internal\n  constructor(node: TreeNode | BufferNode, readonly full = false) {\n    if (node instanceof TreeNode) {\n      this.yieldNode(node)\n    } else {\n      this._tree = node.context.parent\n      this.buffer = node.context\n      for (let n: BufferNode | null = node._parent; n; n = n._parent) this.stack.unshift(n.index)\n      this.bufferNode = node\n      this.yieldBuf(node.index)\n    }\n  }\n\n  private yieldNode(node: TreeNode | null) {\n    if (!node) return false\n    this._tree = node\n    this.type = node.type\n    this.from = node.from\n    this.to = node.to\n    return true\n  }\n\n  private yieldBuf(index: number, type?: NodeType) {\n    this.index = index\n    let {start, buffer} = this.buffer!\n    this.type = type || buffer.set.types[buffer.buffer[index]]\n    this.from = start + buffer.buffer[index + 1]\n    this.to = start + buffer.buffer[index + 2]\n    return true\n  }\n\n  private yield(node: TreeNode | BufferNode | null) {\n    if (!node) return false\n    if (node instanceof TreeNode) {\n      this.buffer = null\n      return this.yieldNode(node)\n    }\n    this.buffer = node.context\n    return this.yieldBuf(node.index, node.type)\n  }\n\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()\n  }\n\n  /// @internal\n  enter(dir: 1 | -1, after: number) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full))\n\n    let {buffer} = this.buffer\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.buffer.start)\n    if (index < 0) return false\n    this.stack.push(this.index)\n    return this.yieldBuf(index)\n  }\n\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() { return this.enter(1, After.None) }\n\n  /// Move the cursor to this node's last child.\n  lastChild() { return this.enter(-1, After.None) }\n\n  /// Move the cursor to the first child that starts at or after `pos`.\n  childAfter(pos: number) { return this.enter(1, pos) }\n\n  /// Move to the last child that ends at or before `pos`.\n  childBefore(pos: number) { return this.enter(-1, pos) }\n\n  /// Move the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent)\n    if (this.stack.length) return this.yieldBuf(this.stack.pop()!)\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent()\n    this.buffer = null\n    return this.yieldNode(parent)\n  }\n\n  /// @internal\n  sibling(dir: 1 | -1) {\n    if (!this.buffer)\n      return !this._tree._parent ? false\n        : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, After.None, this.full))\n\n    let {buffer} = this.buffer, d = this.stack.length - 1\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4\n      if (this.index != parentStart)\n        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, After.None))\n    } else {\n      let after = buffer.buffer[this.index + 3]\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n        return this.yieldBuf(after)\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, After.None, this.full)) : false\n  }\n\n  /// Move to this node's next sibling, if any.\n  nextSibling() { return this.sibling(1) }\n\n  /// Move to this node's previous sibling, if any.\n  prevSibling() { return this.sibling(-1) }\n\n  private atLastNode(dir: 1 | -1) {\n    let index, parent: TreeNode | null, {buffer} = this\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false\n      }\n      ;({index, parent} = buffer)\n    } else {\n      ({index, _parent: parent} = this._tree)\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i]\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false\n      }\n    }\n    return true\n  }\n\n  private move(dir: 1 | -1) {\n    if (this.enter(dir, After.None)) return true\n    for (;;) {\n      if (this.sibling(dir)) return true\n      if (this.atLastNode(dir) || !this.parent()) return false\n    }\n  }\n\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty, its next sibling or the next sibling of\n  /// the first parent node that has one.\n  next() { return this.move(1) }\n\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by ist last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev() { return this.move(-1) }\n\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos: number, side: -1 | 0 | 1 = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to ||\n           (side < 1 ? this.from >= pos : this.from > pos) ||\n           (side > -1 ? this.to <= pos : this.to < pos))\n      if (!this.parent()) break\n\n    // Then scan down into child nodes as far as possible\n    for (;;) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break\n      if (this.from == this.to ||\n          (side < 1 ? this.from >= pos : this.from > pos) ||\n          (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent()\n        break\n      }\n    }\n    return this\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n  /// position.\n  get node(): SyntaxNode {\n    if (!this.buffer) return this._tree\n    \n    let cache = this.bufferNode, result: BufferNode | null = null, depth = 0\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c: BufferNode | null = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c\n          result = c\n          depth = d + 1\n          break scan\n        }\n        index = this.stack[--d]\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i])\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index)\n  }\n\n  /// Get the [tree](#tree.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#tree.TreeBuffer).\n  get tree(): Tree | null {\n    return this.buffer ? null : this._tree.node\n  }\n}\n\nfunction hasChild(tree: Tree): boolean {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch))\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer. A cursor initially points at the very last element\n/// in the buffer. Every time `next()` is called it moves on to the\n/// previous one.\nexport interface BufferCursor {\n  /// The current buffer position (four times the number of nodes\n  /// remaining).\n  pos: number\n  /// The node ID of the next node in the buffer.\n  id: number\n  /// The start position of the next node in the buffer.\n  start: number\n  /// The end position of the next node.\n  end: number\n  /// The size of the next node (the number of nodes inside, counting\n  /// the node itself, times 4).\n  size: number\n  /// Moves `this.pos` down by 4.\n  next(): void\n  /// Create a copy of this cursor.\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\nconst BalanceBranchFactor = 8\n\nfunction buildTree(data: BuildData) {\n  let {buffer, nodeSet, topID = 0,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = nodeSet.types.length} = data as BuildData\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = nodeSet.types\n  function takeNode(parentStart: number, minPos: number,\n                    children: (Tree | TreeBuffer)[], positions: number[],\n                    inRepeat: number) {\n    let {id, start, end, size} = cursor\n    while (id == inRepeat) { cursor.next(); ({id, start, end, size} = cursor) }\n\n    let startPos = start - parentStart\n    if (size < 0) { // Reused node\n      children.push(reused[id])\n      positions.push(startPos)\n      cursor.next()\n      return\n    }\n\n    let type = types[id], node, buffer: {size: number, start: number, skip: number} | undefined\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index, inRepeat)\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat])\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      let localInRepeat = id >= minRepeatType ? id : -1\n      while (cursor.pos > endPos)\n        takeNode(start, endPos, localChildren, localPositions, localInRepeat)\n      localChildren.reverse(); localPositions.reverse()\n\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start)\n      else\n        node = new Tree(type, localChildren, localPositions, end - start)\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function findBufferSize(maxSize: number, inRepeat: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    let result = {size: 0, start: 0, skip: 0}\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size; result.start = start; result.skip = skip\n        skip += 4; size += 4\n        fork.next()\n        continue\n      }\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan\n        if (fork.id >= minRepeatType) localSkipped += 4\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size; result.start = start; result.skip = skip\n    }\n    return result.size > 4 ? result : undefined\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number, inRepeat: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    if (id == inRepeat) return index\n    let startIndex = index\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4)\n      while (cursor.pos > endPos)\n        index = copyToBuffer(bufferStart, buffer, index, inRepeat)\n    }\n    if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1)\n  let length = data.length ?? (children.length ? positions[0] + children[0].length : 0)\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length)\n}\n\nfunction balanceRange(outerType: NodeType, innerType: NodeType,\n                      children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                      from: number, to: number,\n                      start: number, maxBufferLength: number, length: number): Tree {\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i])\n      localPositions.push(positions[i] - start)\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor))\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i]\n      i++\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length\n        if (nextEnd - groupStart > maxChild) break\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom]\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j])\n            localPositions.push(only.positions[j] + groupStart - start)\n          }\n          continue\n        }\n        localChildren.push(only)\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom])\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart,\n                                 maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart)\n        if (innerType != NodeType.none && !containsType(inner.children, innerType))\n          inner = new Tree(NodeType.none, inner.children, inner.positions, inner.length)\n        localChildren.push(inner)\n      }\n      localPositions.push(groupStart - start)\n    }\n  }\n  return new Tree(outerType, localChildren, localPositions, length)\n}\n\nfunction containsType(nodes: readonly (Tree | TreeBuffer)[], type: NodeType) {\n  for (let elt of nodes) if (elt.type == type) return true\n  return false\n}\n\n/// The [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges)\n/// method expects changed ranges in this format.\nexport interface ChangedRange {\n  /// The start of the change in the start document\n  fromA: number\n  /// The end of the change in the start document\n  toA: number\n  /// The start of the replacement in the new document\n  fromB: number\n  /// The end of the replacement in the new document\n  toB: number\n}\n\nconst enum Open { Start = 1, End = 2 }\n\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nexport class TreeFragment {\n  constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    readonly from: number,\n    /// The end of the unchanged range.\n    readonly to: number,\n    /// The tree that this fragment is based on.\n    readonly tree: Tree,\n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    readonly offset: number,\n    private open: number\n  ) {}\n\n  get openStart() { return (this.open & Open.Start) > 0 }\n\n  get openEnd() { return (this.open & Open.End) > 0 }\n\n  /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n  static applyChanges(fragments: readonly TreeFragment[], changes: readonly ChangedRange[], minGap = 128) {\n    if (!changes.length) return fragments\n    let result: TreeFragment[] = []\n    let fI = 1, nextF = fragments.length ? fragments[0] : null\n    let cI = 0, pos = 0, off = 0\n    for (;;) {\n      let nextC = cI < changes.length ? changes[cI++] : null\n      let nextPos = nextC ? nextC.fromA : 1e9\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut: TreeFragment | null = nextF\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off\n          cut = fFrom >= fTo ? null :\n            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off,\n                             (cI > 0 ? Open.Start : 0) | (nextC ? Open.End : 0))\n        }\n        if (cut) result.push(cut)\n        if (nextF.to > nextPos) break\n        nextF = fI < fragments.length ? fragments[fI++] : null\n      }\n      if (!nextC) break\n      pos = nextC.toA\n      off = nextC.toA - nextC.toB\n    }\n    return result\n  }\n\n  /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the token at its\n  /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n  static addTree(tree: Tree, fragments: readonly TreeFragment[] = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? Open.End : 0)]\n    for (let f of fragments) if (f.to > tree.length) result.push(f)\n    return result\n  }\n}\n\n/// Interface used to represent an in-progress parse, which can be\n/// moved forward piece-by-piece.\nexport interface PartialParse {\n  /// Advance the parse state by some amount.\n  advance(): Tree | null\n  /// The current parse position.\n  pos: number\n  /// Get the currently parsed content as a tree, even though the\n  /// parse hasn't finished yet.\n  forceFinish(): Tree\n}\n\n/// A parse context is an object providing additional information to the\n/// parser. It is passed through to nested parsers.\nexport interface ParseContext {\n  /// A set of fragments from a previous parse to be used for incremental\n  /// parsing. These should be aligned with the current document\n  /// (through a call to\n  /// [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges))\n  /// if any changes were made since they were produced. The parser\n  /// will try to reuse nodes from the fragments in the new parse,\n  /// greatly speeding up the parse when it can do so for most of the\n  /// document.\n  fragments?: readonly TreeFragment[]\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code units. Most (but not _all_)\n/// access, especially through `get`, will be sequential, so\n/// implementations can optimize for that.\nexport interface Input {\n  /// The end of the stream.\n  length: number\n  /// Get the code unit at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream.\n  get(pos: number): number\n  /// Returns the string between `pos` and the next newline character\n  /// or the end of the document. Not used by the built-in tokenizers,\n  /// but can be useful in custom tokenizers or completely custom\n  /// parsers.\n  lineAfter(pos: number): string\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `Input` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): Input\n}\n\n// Creates an `Input` that is backed by a single, flat string.\nexport function stringInput(input: string): Input { return new StringInput(input) }\n\nclass StringInput implements Input {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n\n  lineAfter(pos: number) {\n    if (pos < 0) return \"\"\n    let end = this.string.indexOf(\"\\n\", pos)\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length))\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringInput(this.string, at) }\n}\n","export const type = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\";\nexport const nil = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#nil\";\nexport const first = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#first\";\nexport const rest = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#rest\";\nexport const langString = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\";\nexport const JSON = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON\";\n","export const string = \"http://www.w3.org/2001/XMLSchema#string\";\nexport const boolean = \"http://www.w3.org/2001/XMLSchema#boolean\";\nexport const Decimal = \"http://www.w3.org/2001/XMLSchema#decimal\";\nexport const integer = \"http://www.w3.org/2001/XMLSchema#integer\";\nexport const double = \"http://www.w3.org/2001/XMLSchema#double\";\nexport const float = \"http://www.w3.org/2001/XMLSchema#float\";\nexport const date = \"http://www.w3.org/2001/XMLSchema#date\";\nexport const time = \"http://www.w3.org/2001/XMLSchema#time\";\nexport const dateTime = \"http://www.w3.org/2001/XMLSchema#dateTime\";\nexport const dateTimeStamp = \"http://www.w3.org/2001/XMLSchema#dateTimeStamp\";\nexport const gYear = \"http://www.w3.org/2001/XMLSchema#gYear\";\nexport const gMonth = \"http://www.w3.org/2001/XMLSchema#gMonth\";\nexport const gDay = \"http://www.w3.org/2001/XMLSchema#gDay\";\nexport const gYearMonth = \"http://www.w3.org/2001/XMLSchema#gYearMonth\";\nexport const gMonthDay = \"http://www.w3.org/2001/XMLSchema#gMonthDay\";\nexport const duration = \"http://www.w3.org/2001/XMLSchema#duration\";\nexport const yearMonthDuration = \"http://www.w3.org/2001/XMLSchema#yearMonthDuration\";\nexport const dayTimeDuration = \"http://www.w3.org/2001/XMLSchema#dayTimeDuration\";\nexport const byte = \"http://www.w3.org/2001/XMLSchema#byte\";\nexport const short = \"http://www.w3.org/2001/XMLSchema#short\";\nexport const int = \"http://www.w3.org/2001/XMLSchema#int\";\nexport const long = \"http://www.w3.org/2001/XMLSchema#long\";\nexport const unsignedByte = \"http://www.w3.org/2001/XMLSchema#unsignedByte\";\nexport const unsignedShort = \"http://www.w3.org/2001/XMLSchema#unsignedShort\";\nexport const unsignedInt = \"http://www.w3.org/2001/XMLSchema#unsignedInt\";\nexport const unsignedLong = \"http://www.w3.org/2001/XMLSchema#unsignedLong\";\nexport const positiveInteger = \"http://www.w3.org/2001/XMLSchema#positiveInteger\";\nexport const nonNegativeInteger = \"http://www.w3.org/2001/XMLSchema#nonNegativeInteger\";\nexport const nonPositiveInteger = \"http://www.w3.org/2001/XMLSchema#nonPositiveInteger\";\nexport const hexBinary = \"http://www.w3.org/2001/XMLSchema#hexBinary\";\nexport const base64Binary = \"http://www.w3.org/2001/XMLSchema#base64Binary\";\nexport const anyURI = \"http://www.w3.org/2001/XMLSchema#anyURI\";\nexport const language = \"http://www.w3.org/2001/XMLSchema#language\";\nexport const normalizedString = \"http://www.w3.org/2001/XMLSchema#normalizedString\";\nexport const token = \"http://www.w3.org/2001/XMLSchema#token\";\nexport const NMTOKEN = \"http://www.w3.org/2001/XMLSchema#NMTOKEN\";\nexport const Name = \"http://www.w3.org/2001/XMLSchema#Name\";\nexport const NCNames = \"http://www.w3.org/2001/XMLSchema#NCNames\";\n","import { rdf, xsd } from \"./IRIs.js\";\nlet _blankNodeCounter = 0;\nexport class NamedNode {\n    constructor(value) {\n        this.value = value;\n    }\n    get termType() {\n        return \"NamedNode\";\n    }\n    get id() {\n        return `<${this.value}>`;\n    }\n    equals(other) {\n        if (other === undefined || other === null) {\n            return false;\n        }\n        else {\n            return other.termType === \"NamedNode\" && other.value === this.value;\n        }\n    }\n    toJSON() {\n        return {\n            termType: this.termType,\n            value: this.value,\n        };\n    }\n}\nconst xsdString = new NamedNode(xsd.string);\nconst rdfLangString = new NamedNode(rdf.langString);\nexport class Literal {\n    constructor(value, language, datatype) {\n        this.value = value;\n        this.language = language;\n        this.datatype = datatype;\n        if (datatype.value === xsd.string) {\n            this.id = JSON.stringify(value);\n        }\n        else if (datatype.value === rdf.langString && language !== \"\") {\n            this.id = `${JSON.stringify(value)}@${this.language}`;\n        }\n        else {\n            this.id = `${JSON.stringify(value)}^^<${datatype.value}>`;\n        }\n    }\n    get termType() {\n        return \"Literal\";\n    }\n    get datatypeString() {\n        return this.datatype.value;\n    }\n    equals(term) {\n        if (term === null || term === undefined) {\n            return false;\n        }\n        else {\n            return (this.termType === term.termType &&\n                this.value === term.value &&\n                this.language === term.language &&\n                this.datatype.equals(term.datatype));\n        }\n    }\n    toJSON() {\n        return {\n            termType: this.termType,\n            value: this.value,\n            language: this.language,\n            datatype: { termType: \"NamedNode\", value: this.datatype.value },\n        };\n    }\n}\nexport class BlankNode {\n    constructor(value) {\n        this.value = value;\n    }\n    get id() {\n        return `_:${this.value}`;\n    }\n    get termType() {\n        return \"BlankNode\";\n    }\n    equals(term) {\n        if (term === null || term === undefined) {\n            return false;\n        }\n        else {\n            return this.termType === term.termType && term.value === this.value;\n        }\n    }\n    toJSON() {\n        return {\n            termType: this.termType,\n            value: this.value,\n        };\n    }\n}\nexport class Variable {\n    constructor(value) {\n        this.value = value;\n    }\n    get id() {\n        return `?${this.value}`;\n    }\n    get termType() {\n        return \"Variable\";\n    }\n    equals(term) {\n        if (term === null || term === undefined) {\n            return false;\n        }\n        else {\n            return this.termType === term.termType && term.value === this.value;\n        }\n    }\n    toJSON() {\n        return {\n            termType: this.termType,\n            value: this.value,\n        };\n    }\n}\nexport class DefaultGraph {\n    get termType() {\n        return \"DefaultGraph\";\n    }\n    get id() {\n        return \"\";\n    }\n    get value() {\n        return \"\";\n    }\n    equals(term) {\n        if (term === null || term === undefined) {\n            return false;\n        }\n        else {\n            return this.termType === term.termType;\n        }\n    }\n    toJSON() {\n        return {\n            termType: this.termType,\n            value: \"\",\n        };\n    }\n}\nexport const Default = new DefaultGraph();\nexport function fromId(id) {\n    if (id === \"\") {\n        return Default;\n    }\n    switch (id[0]) {\n        case \"_\":\n            return new BlankNode(id.slice(2));\n        case \"?\":\n            return new Variable(id.slice(1));\n        case '\"':\n            const i = id.lastIndexOf('\"');\n            if (i === -1) {\n                throw new Error(`Invalid literal id ${id}`);\n            }\n            const value = id.slice(1, i);\n            if (id.length === i + 1) {\n                return new Literal(value, \"\", xsdString);\n            }\n            else if (id[i + 1] === \"@\") {\n                return new Literal(value, id.slice(i + 2), rdfLangString);\n            }\n            else if (id.slice(i, i + 4) === '\"^^<' && id[id.length - 1] === \">\") {\n                const datatype = new NamedNode(id.slice(i + 4, -1));\n                return new Literal(value, \"\", datatype);\n            }\n            else {\n                throw new Error(`Invalid literal id ${id}`);\n            }\n        case \"<\":\n            return new NamedNode(id.slice(1, -1));\n        default:\n            throw new Error(`Invalid term id ${id}`);\n    }\n}\nexport function toId(term) {\n    if (typeof term === \"string\") {\n        return term;\n    }\n    switch (term.termType) {\n        case \"NamedNode\":\n            return `<${term.value}>`;\n        case \"BlankNode\":\n            return \"_:\" + term.value;\n        case \"Variable\":\n            return \"?\" + term.value;\n        case \"DefaultGraph\":\n            return \"\";\n        case \"Literal\":\n            return ('\"' +\n                term.value +\n                '\"' +\n                (term.language\n                    ? \"@\" + term.language\n                    : term.datatype && term.datatype.value !== xsd.string\n                        ? \"^^<\" + term.datatype.value + \">\"\n                        : \"\"));\n        default:\n            throw new Error(\"Invalid term: \" + term);\n    }\n}\n// TODO: think about it\nexport class Quad extends Array {\n    constructor(subject, predicate, object, graph) {\n        super(subject, predicate, object, graph || Default);\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph || Default;\n    }\n    get termType() {\n        return \"Quad\";\n    }\n    get value() {\n        return \"\";\n    }\n    get id() {\n        if (this.graph.equals(Default)) {\n            return `${this.subject.id} ${this.predicate.id} ${this.object.id} .`;\n        }\n        else {\n            return `${this.subject.id} ${this.predicate.id} ${this.object.id} ${this.graph.id} .`;\n        }\n    }\n    toJSON() {\n        return {\n            termType: \"Quad\",\n            value: \"\",\n            subject: this.subject.toJSON(),\n            predicate: this.predicate.toJSON(),\n            object: this.object.toJSON(),\n            graph: this.graph.toJSON(),\n        };\n    }\n    equals(other) {\n        if (other === undefined || other === null) {\n            return false;\n        }\n        else {\n            return (other.termType === \"Quad\" &&\n                this.subject.equals(other.subject) &&\n                this.predicate.equals(other.predicate) &&\n                this.object.equals(other.object) &&\n                this.graph.equals(other.graph));\n        }\n    }\n}\nfunction namedNode(iri) {\n    return new NamedNode(iri);\n}\nfunction blankNode(name) {\n    return new BlankNode(name || `b${_blankNodeCounter++}`);\n}\nfunction literal(value, languageOrDataType) {\n    if (languageOrDataType === undefined) {\n        return new Literal(value, \"\", xsdString);\n    }\n    else if (typeof languageOrDataType === \"string\") {\n        return new Literal(value, languageOrDataType, rdfLangString);\n    }\n    else {\n        const datatype = new NamedNode(languageOrDataType.value);\n        return new Literal(value, \"\", datatype);\n    }\n}\nfunction variable(name) {\n    return new Variable(name);\n}\nfunction defaultGraph() {\n    return Default;\n}\nfunction quad(subject, predicate, object, graph) {\n    return new Quad(subject, predicate, object, graph);\n}\n// export function getTerm(\n// \tterm: null | string | Term\n// ): null | NamedNode | BlankNode | Literal | Variable | DefaultGraph {\n// \tif (term === null) {\n// \t\treturn null\n// \t} else if (typeof term === \"string\") {\n// \t\treturn fromId(term)\n// \t} else if (term instanceof BaseTerm) {\n// \t\treturn term\n// \t} else {\n// \t\tswitch (term.termType) {\n// \t\t\tcase \"NamedNode\":\n// \t\t\t\treturn new NamedNode(term.value)\n// \t\t\tcase \"BlankNode\":\n// \t\t\t\treturn new BlankNode(term.value)\n// \t\t\tcase \"Literal\":\n// \t\t\t\treturn new Literal(\n// \t\t\t\t\tterm.value,\n// \t\t\t\t\tterm.language || new NamedNode(term.datatype.value)\n// \t\t\t\t)\n// \t\t\tcase \"DefaultGraph\":\n// \t\t\t\treturn Default\n// \t\t\tcase \"Variable\":\n// \t\t\t\treturn new Variable(term.value)\n// \t\t}\n// \t}\n// }\nconst DataFactory = {\n    namedNode,\n    blankNode,\n    variable,\n    literal,\n    defaultGraph,\n    quad,\n};\nexport default DataFactory;\n","import DataFactory, { toId, fromId, Quad } from \"./DataFactory.js\";\nconst SPO = [\"subject\", \"predicate\", \"object\"];\nconst POS = [\"predicate\", \"object\", \"subject\"];\nconst OSP = [\"object\", \"subject\", \"predicate\"];\nexport default class Store {\n    constructor(quads) {\n        this.sizeCache = 0;\n        this.graphMap = new Map();\n        this.id = 0;\n        this.ids = new Map([[\"><\", 0]]);\n        this.entities = new Map();\n        this.blankNodeIndex = 0;\n        // Add quads if passed\n        if (quads !== undefined) {\n            this.addQuads(quads);\n        }\n    }\n    [Symbol.iterator]() {\n        return this.quads(null, null, null, null);\n    }\n    get size() {\n        if (this.sizeCache !== null) {\n            return this.sizeCache;\n        }\n        // Calculate the number of quads by counting to the deepest level\n        let size = 0;\n        for (const { subjects } of this.graphMap.values()) {\n            for (const predicates of subjects.values()) {\n                for (const objects of predicates.values()) {\n                    size += objects.size;\n                }\n            }\n        }\n        this.sizeCache = size;\n        return size;\n    }\n    // ## Private methods\n    // Returns if the index has changed, if the entry did not already exist.\n    addToIndex(index0, key0, key1, key2) {\n        // Create layers as necessary\n        let existed = false;\n        const index1 = index0.get(key0);\n        if (index1 === undefined) {\n            index0.set(key0, new Map([[key1, new Set([key2])]]));\n        }\n        else {\n            const index2 = index1.get(key1);\n            if (index2 === undefined) {\n                index1.set(key1, new Set([key2]));\n            }\n            else {\n                existed = index2.has(key2);\n                index2.add(key2);\n            }\n        }\n        return existed;\n    }\n    // ### `_removeFromIndex` removes a quad from a three-layered index\n    removeFromIndex(index0, key0, key1, key2) {\n        // Remove the quad from the index\n        const index1 = index0.get(key0);\n        const index2 = index1.get(key1);\n        index2.delete(key2);\n        if (index2.size === 0) {\n            index1.delete(key1);\n            if (index1.size === 0) {\n                index0.delete(key0);\n            }\n        }\n    }\n    *generateIndex(index0, key0, key1, key2, rotation, graph) {\n        const entities = [\"\", \"\", \"\"];\n        if (key0) {\n            const index1 = index0.get(key0);\n            if (index1 !== undefined) {\n                entities[0] = this.entities.get(key0);\n                yield* this.generateIndex1(entities, index1, key1 || null, key2 || null, rotation, graph);\n            }\n        }\n        else {\n            for (const [value0, index1] of index0) {\n                entities[0] = this.entities.get(value0);\n                yield* this.generateIndex1(entities, index1, key1 || null, key2 || null, rotation, graph);\n            }\n        }\n    }\n    *generateIndex1(e, index1, key1, key2, r, graph) {\n        if (key1) {\n            const index2 = index1.get(key1);\n            if (index2 !== undefined) {\n                e[1] = this.entities.get(key1);\n                yield* this.generateIndex2(e, key2, index2, r, graph);\n            }\n        }\n        else {\n            for (const [value1, index2] of index1) {\n                e[1] = this.entities.get(value1);\n                yield* this.generateIndex2(e, key2, index2, r, graph);\n            }\n        }\n    }\n    *generateIndex2(e, key2, index2, r, graph) {\n        if (key2) {\n            if (index2.has(key2)) {\n                e[2] = this.entities.get(key2);\n                yield this.makeQuad(e, r, graph);\n            }\n        }\n        else {\n            for (const value2 of index2) {\n                e[2] = this.entities.get(value2);\n                yield this.makeQuad(e, r, graph);\n            }\n        }\n    }\n    makeQuad([entity0, entity1, entity2], [name0, name1, name2], graph) {\n        const parts = { subject: null, predicate: null, object: null };\n        parts[name0] = fromId(entity0);\n        parts[name1] = fromId(entity1);\n        parts[name2] = fromId(entity2);\n        return new Quad(parts.subject, parts.predicate, parts.object, fromId(graph));\n    }\n    *loopByKey0(index0, key0) {\n        const index1 = index0.get(key0);\n        if (index1 !== undefined) {\n            yield* index1.keys();\n        }\n    }\n    *loopByKey1(index0, key1) {\n        for (const [key0, index1] of index0) {\n            if (index1.has(key1)) {\n                yield key0;\n            }\n        }\n    }\n    *loopBy2Keys(index0, key0, key1) {\n        const index1 = index0.get(key0);\n        if (index1 !== undefined) {\n            const index2 = index1.get(key1);\n            if (index2 !== undefined) {\n                yield* index2.keys();\n            }\n        }\n    }\n    // ### `countInIndex` counts matching quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n    countInIndex(index0, key0, key1, key2) {\n        let count = 0;\n        if (key0 === null) {\n            for (const index1 of index0.values()) {\n                count += this.countInIndex1(index1, key1, key2);\n            }\n        }\n        else {\n            const index1 = index0.get(key0);\n            if (index1 !== undefined) {\n                count = this.countInIndex1(index1, key1, key2);\n            }\n        }\n        return count;\n    }\n    countInIndex1(index1, key1, key2) {\n        let count = 0;\n        if (key1 === null) {\n            for (const index2 of index1.values()) {\n                count += key2 === null ? index2.size : index2.has(key2) ? 1 : 0;\n            }\n        }\n        else {\n            const index2 = index1.get(key1);\n            if (index2 !== undefined) {\n                count += key2 === null ? index2.size : index2.has(key2) ? 1 : 0;\n            }\n        }\n        return count;\n    }\n    // ### `getGraphIndices` returns an array with the given graph,\n    // or all graphs if the argument is null or undefined.\n    getGraphIndices(graph) {\n        if (graph === undefined || graph === null) {\n            return this.graphMap;\n        }\n        else {\n            const graphIndex = this.graphMap.get(graph);\n            return new Map([[graph, graphIndex]]);\n        }\n    }\n    getGraphIndex(graph) {\n        const graphIndex = this.graphMap.get(graph);\n        if (graphIndex !== undefined) {\n            return graphIndex;\n        }\n        const newGraphIndex = Object.freeze({\n            subjects: new Map(),\n            predicates: new Map(),\n            objects: new Map(),\n        });\n        this.graphMap.set(graph, newGraphIndex);\n        return newGraphIndex;\n    }\n    addQuad(...args) {\n        let [subject, predicate, object, graph] = [\"\", \"\", \"\", \"\"];\n        if (args.length === 1) {\n            subject = toId(args[0].subject);\n            predicate = toId(args[0].predicate);\n            object = toId(args[0].object);\n            graph = toId(args[0].graph);\n        }\n        else {\n            subject = toId(args[0]);\n            predicate = toId(args[1]);\n            object = toId(args[2]);\n            if (args[3] === undefined) {\n                graph = \"\";\n            }\n            else {\n                graph = toId(args[3]);\n            }\n        }\n        const graphIndex = this.getGraphIndex(graph);\n        // Since entities can often be long IRIs, we avoid storing them in every index.\n        // Instead, we have a separate index that maps entities to numbers,\n        // which are then used as keys in the other indexes.\n        if (!this.ids.has(subject)) {\n            const id = ++this.id;\n            this.entities.set(id, subject);\n            this.ids.set(subject, id);\n        }\n        const s = this.ids.get(subject);\n        if (!this.ids.has(predicate)) {\n            const id = ++this.id;\n            this.entities.set(id, predicate);\n            this.ids.set(predicate, id);\n        }\n        const p = this.ids.get(predicate);\n        if (!this.ids.has(object)) {\n            const id = ++this.id;\n            this.entities.set(id, object);\n            this.ids.set(object, id);\n        }\n        const o = this.ids.get(object);\n        const changed = this.addToIndex(graphIndex.subjects, s, p, o);\n        this.addToIndex(graphIndex.predicates, p, o, s);\n        this.addToIndex(graphIndex.objects, o, s, p);\n        // The cached quad count is now invalid\n        this.sizeCache = null;\n        return changed;\n    }\n    // ### `addQuads` adds multiple quads to the store\n    addQuads(quads) {\n        for (const quad of quads) {\n            this.addQuad(quad);\n        }\n    }\n    removeQuad(...args) {\n        let [subject, predicate, object, graph] = [\"\", \"\", \"\", \"\"];\n        if (args.length === 1) {\n            subject = toId(args[0].subject);\n            predicate = toId(args[0].predicate);\n            object = toId(args[0].object);\n            graph = toId(args[0].graph);\n        }\n        else if (args.length === 3) {\n            subject = toId(args[0]);\n            predicate = toId(args[1]);\n            object = toId(args[2]);\n            graph = \"\";\n        }\n        else if (args.length === 4) {\n            subject = toId(args[0]);\n            predicate = toId(args[1]);\n            object = toId(args[2]);\n            graph = toId(args[3]);\n        }\n        // Find internal identifiers for all components\n        // and verify the quad exists.\n        const index = this.graphMap.get(graph);\n        if (index === undefined) {\n            return false;\n        }\n        if (!this.ids.has(subject) ||\n            !this.ids.has(predicate) ||\n            !this.ids.has(object)) {\n            return false;\n        }\n        const [s, p, o] = [\n            this.ids.get(subject),\n            this.ids.get(predicate),\n            this.ids.get(object),\n        ];\n        const subjects = index.subjects.get(s);\n        if (subjects === undefined) {\n            return false;\n        }\n        const predicates = subjects.get(p);\n        if (predicates === undefined || !predicates.has(o)) {\n            return false;\n        }\n        // Remove it from all indexes\n        this.removeFromIndex(index.subjects, s, p, o);\n        this.removeFromIndex(index.predicates, p, o, s);\n        this.removeFromIndex(index.objects, o, s, p);\n        if (this.sizeCache !== null) {\n            this.sizeCache--;\n        }\n        if (index.subjects.size === 0) {\n            this.graphMap.delete(graph);\n        }\n        return true;\n    }\n    // ### `remove` removes a stream of quads from the store\n    remove(stream) {\n        for (const quad of stream) {\n            this.removeQuad(quad);\n        }\n    }\n    // ### `removeMatches` removes all matching quads from the store\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    removeMatches(subject, predicate, object, graph) {\n        return this.remove(this.quads(subject, predicate, object, graph));\n    }\n    // ### `deleteGraph` removes all triples with the given graph from the store\n    deleteGraph(graph) {\n        return this.removeMatches(null, null, null, graph);\n    }\n    getGraphId(graph) {\n        const graphId = toId(graph);\n        if (this.graphMap.has(graphId)) {\n            return graphId;\n        }\n        else {\n            return undefined;\n        }\n    }\n    // TODO::::::\n    getIds(s, p, o, graph) {\n        return [\n            s === null ? null : this.ids.get(toId(s)),\n            p === null ? null : this.ids.get(toId(p)),\n            o === null ? null : this.ids.get(toId(o)),\n            graph === null ? null : this.getGraphId(graph),\n        ];\n    }\n    *q(s, p, o, g) {\n        const graphs = this.getGraphIndices(g);\n        for (const [graphId, { subjects, predicates, objects }] of graphs) {\n            // Choose the optimal index, based on what fields are present\n            if (s) {\n                if (o) {\n                    // If subject and object are given, the object index will be the fastest\n                    yield* this.generateIndex(objects, o, s, p, OSP, graphId);\n                }\n                else {\n                    // If only subject and possibly predicate are given, the subject index will be the fastest\n                    yield* this.generateIndex(subjects, s, p, null, SPO, graphId);\n                }\n            }\n            else if (p) {\n                // If only predicate and possibly object are given, the predicate index will be the fastest\n                yield* this.generateIndex(predicates, p, o, null, POS, graphId);\n            }\n            else if (o) {\n                // If only object is given, the object index will be the fastest\n                yield* this.generateIndex(objects, o, null, null, OSP, graphId);\n            }\n            else {\n                // If nothing is given, iterate subjects and predicates first\n                yield* this.generateIndex(subjects, null, null, null, SPO, graphId);\n            }\n        }\n    }\n    // ### `match` returns a stream of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    *quads(subject, predicate, object, graph) {\n        const [s, p, o, g] = this.getIds(subject, predicate, object, graph);\n        if (s === undefined ||\n            p === undefined ||\n            o === undefined ||\n            g === undefined) {\n            return;\n        }\n        yield* this.q(s, p, o, g);\n    }\n    getQuads(subject, predicate, object, graph) {\n        return Array.from(this.quads(subject, predicate, object, graph));\n    }\n    countQuads(subject, predicate, object, graph) {\n        const [s, p, o, g] = this.getIds(subject, predicate, object, graph);\n        if (s === undefined ||\n            p === undefined ||\n            o === undefined ||\n            g === undefined) {\n            return 0;\n        }\n        const graphs = this.getGraphIndices(g);\n        let count = 0;\n        for (const content of graphs.values()) {\n            if (s) {\n                if (o) {\n                    // If subject and object are given, the object index will be the fastest\n                    count += this.countInIndex(content.objects, o, s, p);\n                }\n                else {\n                    // If only subject and possibly predicate are given, the subject index will be the fastest\n                    count += this.countInIndex(content.subjects, s, p, o);\n                }\n            }\n            else if (p) {\n                // If only predicate and possibly object are given, the predicate index will be the fastest\n                count += this.countInIndex(content.predicates, p, o, s);\n            }\n            else {\n                // If only object is possibly given, the object index will be the fastest\n                count += this.countInIndex(content.objects, o, s, p);\n            }\n        }\n        return count;\n    }\n    getSubjects(predicate, object, graph) {\n        return Array.from(this.subjects(predicate, object, graph));\n    }\n    *subjects(predicate, object, graph) {\n        const [_, p, o, g] = this.getIds(null, predicate, object, graph);\n        if (p === undefined || o === undefined || g === undefined) {\n            return;\n        }\n        const graphs = this.getGraphIndices(g);\n        const ids = new Set();\n        for (const { subjects, predicates, objects } of graphs.values()) {\n            // Choose optimal index based on which fields are wildcards\n            let iterator;\n            if (p) {\n                if (o) {\n                    // If predicate and object are given, the POS index is best.\n                    iterator = this.loopBy2Keys(predicates, p, o);\n                }\n                else {\n                    // If only predicate is given, the SPO index is best.\n                    iterator = this.loopByKey1(subjects, p);\n                }\n            }\n            else if (o) {\n                // If only object is given, the OSP index is best.\n                iterator = this.loopByKey0(objects, o);\n            }\n            else {\n                // If no params given, iterate all the subjects\n                iterator = subjects.keys();\n            }\n            for (const s of iterator) {\n                yield* this.unique(s, ids);\n            }\n        }\n    }\n    getPredicates(subject, object, graph) {\n        return Array.from(this.predicates(subject, object, graph));\n    }\n    *predicates(subject, object, graph) {\n        const [s, _, o, g] = this.getIds(subject, null, object, graph);\n        if (s === undefined || o === undefined || g === undefined) {\n            return;\n        }\n        const graphs = this.getGraphIndices(g);\n        const ids = new Set();\n        for (const { subjects, predicates, objects } of graphs.values()) {\n            // Choose optimal index based on which fields are wildcards\n            let iterator;\n            if (s) {\n                if (o) {\n                    // If subject and object are given, the OSP index is best.\n                    iterator = this.loopBy2Keys(objects, o, s);\n                }\n                else {\n                    // If only subject is given, the SPO index is best.\n                    iterator = this.loopByKey0(subjects, s);\n                }\n            }\n            else if (o) {\n                // If only object is given, the POS index is best.\n                iterator = this.loopByKey1(predicates, o);\n            }\n            else {\n                // If no params given, iterate all the predicates.\n                iterator = predicates.keys();\n            }\n            for (const p of iterator) {\n                yield* this.unique(p, ids);\n            }\n        }\n    }\n    // ### `getObjects` returns all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    getObjects(subject, predicate, graph) {\n        return Array.from(this.objects(subject, predicate, graph));\n    }\n    *objects(subject, predicate, graph) {\n        const [s, p, _, g] = this.getIds(subject, predicate, null, graph);\n        if (s === undefined || p === undefined || g === undefined) {\n            return;\n        }\n        const graphs = this.getGraphIndices(g);\n        const ids = new Set();\n        for (const { subjects, predicates, objects } of graphs.values()) {\n            // Choose optimal index based on which fields are wildcards\n            if (s) {\n                if (p) {\n                    // If subject and predicate are given, the SPO index is best.\n                    for (const o of this.loopBy2Keys(subjects, s, p)) {\n                        yield* this.unique(o, ids);\n                    }\n                }\n                else {\n                    // If only subject is given, the OSP index is best.\n                    for (const o of this.loopByKey1(objects, s)) {\n                        yield* this.unique(o, ids);\n                    }\n                }\n            }\n            else if (p) {\n                // If only predicate is given, the POS index is best.\n                for (const o of this.loopByKey0(predicates, p)) {\n                    yield* this.unique(o, ids);\n                }\n            }\n            else {\n                // If no params given, iterate all the objects.\n                for (const o of objects.keys()) {\n                    yield* this.unique(o, ids);\n                }\n            }\n        }\n    }\n    getGraphs(subject, predicate, object) {\n        return Array.from(this.graphs(subject, predicate, object));\n    }\n    *graphs(subject, predicate, object) {\n        const [s, p, o, _] = this.getIds(subject, predicate, object, null);\n        if (s === undefined || p === undefined || o === undefined) {\n            return;\n        }\n        for (const g of this.graphMap.keys()) {\n            const graph = fromId(g);\n            for (const _ of this.q(s, p, o, g)) {\n                yield graph;\n                break;\n            }\n        }\n    }\n    *unique(id, ids) {\n        if (!ids.has(id)) {\n            ids.add(id);\n            yield fromId(this.entities.get(id));\n        }\n    }\n    createBlankNode(suggestedName) {\n        let name = \"\";\n        if (suggestedName) {\n            // Generate a name based on the suggested name\n            name = \"_:\" + suggestedName;\n            for (let index = 1; this.ids.has(name); index++) {\n                name = \"_:\" + suggestedName + index;\n            }\n        }\n        else {\n            // Generate a generic blank node name\n            do {\n                name = \"_:b\" + this.blankNodeIndex++;\n            } while (this.ids.has(name));\n        }\n        // Add the blank node to the entities, avoiding the generation of duplicates\n        const id = ++this.id;\n        this.ids.set(name, id);\n        this.entities.set(id, name);\n        return DataFactory.blankNode(name.substr(2));\n    }\n}\n","import { Quad, NamedNode, BlankNode, Literal, Default, } from \"./DataFactory.js\";\nconst nnClosingTagError = () => new Error(`named node without closing angle bracket`);\nconst bnOpenTagError = () => new Error(`invalid blank node label`);\nconst unexpectedCharError = (identifier) => new Error(`Unexpected character '${identifier}'`);\nconst quadClosingPeriodError = (line) => new Error(`quad without closing period ${line}`);\nconst nnOpeningToken = \"<\";\nconst nnOpeningTokenOffset = nnOpeningToken.length;\nconst nnClosingToken = \">\";\nconst nnClosingPostfix = \"> \";\nconst nnClosingPostfixOffset = nnClosingPostfix.length;\nconst bnOpeningToken = \"_\";\nconst bnOpeningPrefix = \"_:\";\nconst bnOpeningPrefixOffset = bnOpeningPrefix.length;\nconst bnClosingToken = \" \";\nconst bnClosingTokenOffset = bnClosingToken.length;\nconst ltOpeningToken = '\"';\nconst ltOpeningTokenOffset = ltOpeningToken.length;\nconst quadClosingPostfix = \".\";\nconst ltReservedReplace = /\\\\(.)/g;\nconst ltReservedReplaceFn = (match) => {\n    switch (match) {\n        case \"\\\\n\":\n            return \"\\n\";\n        case \"\\\\r\":\n            return \"\\r\";\n        case '\\\\\"':\n            return '\"';\n        case \"\\\\\\\\\":\n            return \"\\\\\";\n        default:\n            throw new Error(`Unknown token ${match}`);\n    }\n};\n// const lgOpeningToken: string = \"@\"\n// const lgOpeningTokenOffset: number = lgOpeningToken.length\nconst lgOpeningPrefix = '\"@';\nconst lgOpeningPrefixOffset = lgOpeningPrefix.length;\nconst lgClosingToken = \" \";\nconst dtSplitPrefix = '\"^^<';\nconst dtSplitPrefixOffset = dtSplitPrefix.length;\nconst xsdString = new NamedNode(\"http://www.w3.org/2001/XMLSchema#string\");\nconst rdfLangString = new NamedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\");\nexport default function* Parse(input) {\n    if (!input || input.length === 0) {\n        return;\n    }\n    let rightBoundary, leftBoundary;\n    let lang, datatype;\n    let subject, predicate, object, graph;\n    for (const line of input.split(\"\\n\")) {\n        if (line === \"\") {\n            continue;\n        }\n        rightBoundary = -1;\n        leftBoundary = -1;\n        /*\n         * Parse the subject\n         */\n        switch (line.charAt(0)) {\n            case nnOpeningToken:\n                rightBoundary = line.indexOf(nnClosingPostfix);\n                if (rightBoundary === -1) {\n                    throw nnClosingTagError();\n                }\n                const namedNodeValue = line.substring(nnOpeningTokenOffset, rightBoundary);\n                subject = new NamedNode(namedNodeValue);\n                leftBoundary = rightBoundary + nnClosingPostfixOffset;\n                break;\n            case bnOpeningToken:\n                rightBoundary = line.indexOf(bnClosingToken);\n                const blankNodeValue = line.substring(bnOpeningPrefixOffset, rightBoundary);\n                subject = new BlankNode(blankNodeValue);\n                leftBoundary = rightBoundary + bnClosingTokenOffset;\n                break;\n            default:\n                throw unexpectedCharError(line.charAt(0));\n        }\n        /*\n         * Parse the predicate\n         */\n        // We currently assume blank nodes can't be predicates\n        rightBoundary = line.indexOf(nnClosingPostfix, leftBoundary);\n        if (rightBoundary === -1) {\n            throw nnClosingTagError();\n        }\n        leftBoundary =\n            line.indexOf(nnOpeningToken, leftBoundary) + nnOpeningTokenOffset;\n        predicate = new NamedNode(line.substring(leftBoundary, rightBoundary));\n        leftBoundary = rightBoundary + nnClosingPostfixOffset;\n        /*\n         * Parse the object\n         */\n        switch (line.charAt(leftBoundary)) {\n            case nnOpeningToken:\n                leftBoundary = leftBoundary + nnOpeningTokenOffset;\n                // When parsing ntriples, the space of the nnClosingPostfix might not exist, so it can't be used\n                rightBoundary = line.indexOf(nnClosingToken, leftBoundary);\n                if (rightBoundary === -1) {\n                    throw nnClosingTagError();\n                }\n                object = new NamedNode(line.substring(leftBoundary, rightBoundary));\n                leftBoundary = rightBoundary + nnClosingPostfixOffset;\n                break;\n            case bnOpeningToken:\n                leftBoundary =\n                    line.indexOf(bnOpeningPrefix, leftBoundary) + bnOpeningPrefixOffset;\n                rightBoundary = line.indexOf(bnClosingToken, leftBoundary);\n                if (rightBoundary === -1) {\n                    throw quadClosingPeriodError(line);\n                }\n                const value = line.substring(leftBoundary, rightBoundary);\n                object = new BlankNode(value);\n                leftBoundary = rightBoundary + bnClosingTokenOffset;\n                break;\n            case '\"':\n                leftBoundary = leftBoundary + ltOpeningTokenOffset;\n                const objEndIndex = line.lastIndexOf(ltOpeningToken);\n                const literalValue = line\n                    .substring(leftBoundary, objEndIndex)\n                    .replace(ltReservedReplace, ltReservedReplaceFn);\n                leftBoundary = objEndIndex;\n                // dtOrLgBoundary = line.indexOf(dtSplitPrefix, leftBoundary)\n                if (line.substring(leftBoundary, leftBoundary + dtSplitPrefixOffset) ===\n                    dtSplitPrefix) {\n                    // Typed literal\n                    rightBoundary = line.indexOf(nnClosingToken, leftBoundary + dtSplitPrefixOffset);\n                    if (rightBoundary === -1) {\n                        throw nnClosingTagError();\n                    }\n                    const value = line.substring(leftBoundary + dtSplitPrefixOffset, rightBoundary);\n                    lang = null;\n                    datatype = new NamedNode(value);\n                    leftBoundary = rightBoundary + nnClosingPostfixOffset;\n                }\n                else if (line.substring(leftBoundary, leftBoundary + lgOpeningPrefixOffset) ===\n                    lgOpeningPrefix) {\n                    rightBoundary = line.indexOf(lgClosingToken, leftBoundary + lgOpeningPrefixOffset);\n                    if (rightBoundary === -1) {\n                        throw quadClosingPeriodError(line);\n                    }\n                    lang = line.substring(leftBoundary + lgOpeningPrefixOffset, rightBoundary);\n                    datatype = rdfLangString;\n                    leftBoundary = rightBoundary;\n                }\n                else {\n                    // Implicit literals are strings\n                    lang = null;\n                    datatype = xsdString;\n                    leftBoundary += ltOpeningTokenOffset + 1;\n                }\n                object =\n                    lang === null\n                        ? new Literal(literalValue, \"\", datatype)\n                        : new Literal(literalValue, lang, rdfLangString);\n                break;\n            default:\n                throw unexpectedCharError(line.charAt(leftBoundary));\n        }\n        /*\n         * Parse the graph, if any\n         */\n        if (line[leftBoundary] === nnOpeningToken) {\n            leftBoundary += nnOpeningTokenOffset;\n            rightBoundary = line.indexOf(nnClosingPostfix, leftBoundary);\n            if (rightBoundary === -1) {\n                throw nnClosingTagError();\n            }\n            else if (line.substring(rightBoundary, rightBoundary + nnClosingPostfixOffset) !== nnClosingPostfix) {\n                throw nnClosingTagError();\n            }\n            const value = line.substring(leftBoundary, rightBoundary);\n            leftBoundary = rightBoundary + nnClosingPostfixOffset;\n            graph = new NamedNode(value);\n        }\n        else if (line[leftBoundary] === bnOpeningToken) {\n            if (line.substring(leftBoundary, leftBoundary + bnOpeningPrefixOffset) !==\n                bnOpeningPrefix) {\n                throw bnOpenTagError();\n            }\n            leftBoundary = leftBoundary + bnOpeningPrefixOffset;\n            rightBoundary = line.indexOf(bnClosingToken, leftBoundary);\n            if (rightBoundary === -1) {\n                throw quadClosingPeriodError(line);\n            }\n            const value = line.substring(leftBoundary, rightBoundary);\n            graph = new BlankNode(value);\n            leftBoundary = rightBoundary + bnClosingTokenOffset;\n        }\n        else {\n            graph = Default;\n        }\n        if (line.substring(leftBoundary) === quadClosingPostfix) {\n            yield new Quad(subject, predicate, object, graph);\n        }\n        else {\n            throw quadClosingPeriodError(line);\n        }\n    }\n}\n","const C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nexport class StyleModule {\n  // :: (Object<Style>, ?{process: (string) → string, extend: (string, string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `process` is given, it is called on regular (non-`@`)\n  // selector properties to provide the actual selector. When `extend`\n  // is given, it is called when a property containing an `&` is\n  // found, and should somehow combine the `&`-template (its first\n  // argument) with the selector (its second argument) to produce an\n  // extended selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {process, extend} = options || {}\n\n    function processSelector(selector) {\n      if (/^@/.test(selector)) return [selector]\n      let selectors = selector.split(\",\")\n      return process ? selectors.map(process) : selectors\n    }\n\n    function render(selectors, spec, target) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0])\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(selectors.map(s => extend ? extend(prop, s) : prop.replace(/&/, s)), value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(isAt[1] == \"keyframes\" ? [prop] : processSelector(prop), value, local)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || isAt && isAt[1] == \"keyframes\") target.push(selectors.join(\",\") + \" {\" + local.join(\" \") + \"}\")\n    }\n\n    for (let prop in spec) render(processSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  static mount(root, modules) {\n    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\n  }\n}\n\nlet adoptedSet = null\n\nclass StyleSet {\n  constructor(root) {\n    if (root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\n      if (adoptedSet) {\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets)\n        return root[SET] = adoptedSet\n      }\n      this.sheet = new CSSStyleSheet\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets)\n      adoptedSet = this\n    } else {\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\")\n      let target = root.head || root\n      target.insertBefore(this.styleTag, target.firstChild)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (!sheet) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst zip = (...args) => ({\n    [Symbol.iterator]() {\n        const iterators = args.map((arg) => arg[Symbol.iterator]());\n        let i = 0;\n        return {\n            next() {\n                const results = iterators.map((iter) => iter.next());\n                if (results.some(({ done }) => done)) {\n                    return { done: true, value: undefined };\n                }\n                else {\n                    const values = results.map(({ value }) => value);\n                    return { done: false, value: [...values, i++] };\n                }\n            },\n        };\n    },\n});\nexports.default = zip;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { openLintPanel } from \"@codemirror/next/lint\"\nimport { EditorState } from \"@codemirror/next/state\"\nimport { EditorView } from \"@codemirror/next/view\"\nimport { editableConfig, makeLinter } from \"../lib/tasl/index\"\n\nconst initialValue = `# Welcome to the schema editor!\n# If you're new, you probably want to read\n# the schema language documentation here:\n# http://r1.underlay.org/docs/schemas\n\nnamespace ex http://example.com#\nnamespace ul http://underlay.org/ns/\n\ntype foo {\n  ex:a -> ? uri ;\n  ex:b -> string ;\n  ex:c -> dateTime ;\n}\n\nedge ex:cool ==/ ex:map /=> ex:wau\n\nclass ex:cool unit\n\nclass ex:wau {\n  ex:bar -> foo ;\n  ex:age -> integer ;\n  ex:self -> * ex:wau ;\n}\n\n\n\n\n\n\n`\n\nconst linter = makeLinter()\nconst extensions = [...editableConfig, linter]\n\nconst state = EditorState.create({\n\tdoc: initialValue,\n\textensions,\n})\n\nconst view = new EditorView({\n\tstate,\n\tparent: document.getElementById(\"editor\"),\n})\n\nopenLintPanel(view)\nview.focus()\n"],"sourceRoot":""}